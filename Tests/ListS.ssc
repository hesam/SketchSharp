
using System;
using Microsoft.Contracts;

public class List {

    /*

    // ------------------------------------------------------------------   
    //  OT Definition
    // ------------------------------------------------------------------   

    // ------------------------------------------------------------------

    // C1:             
    //         op1 . T(op2, op1) = op2 . T(op1, op2)

    // C2:             
    //         T(T(op3, op1), T(op2, op1)) = T(T(op3, op2), T(op1, op2))


    // ------------------------------------------------------------------

    T(Insert(pos1, origPos1, pr1), Insert(pos2, origPos2, pr2)) = 
        Insert(pos1 > pos2 || 
                (pos1 == pos2 && 
                   (origPos1 > origPos2 || pr1 > pr2)) ? 
               pos1 + 1 : pos1, pr1, origPos1)

    T(Delete(pos1), Delete(pos2)) = 
        pos1 == pos2 ? Noop : Delete(pos1 > pos2 ? pos1 - 1 : pos1)

    T(Insert(pos1), Delete(pos2)) = 
        Insert(pos1 > pos2 ? pos1 - 1 : pos1)

    T(Delete(pos1), Insert(pos2)) = 
        Insert(pos1 >= pos2 ? pos1 + 1 : pos1)

    // ------------------------------------------------------------------

    */

    // ------------------------------------------------------------------   
    //  C1, C2 Verification
    // ------------------------------------------------------------------   

    // Insert__Insert_Insert 
    static int Insert__Insert_Insert(int[]! a, int[]! b, int size, int pos3, int val3, int pr3, int pos2, int val2, int pr2, int pos1, int val1, int pr1) 
        requires a != b;
        requires forall {int i in (0 : size); a[i] == b[i]};
        requires a.Length == b.Length;      
        requires size < a.Length - 2;
        requires size >= 0;
        requires pos1 <= size;
        requires pos2 <= size;
        requires pos3 <= size;
        requires pos1 >= 0;
        requires pos2 >= 0;
        requires pos3 >= 0;       
        requires pr1 != pr2;
        requires pr2 != pr3;
        requires pr3 != pr1;
        modifies a[*], b[*];
        ensures forall {int i in (0 : result); a[i] == b[i]};
    {
        int sizea = size, sizeb = size;

        // C1:

        // op3    << op2    << op1
        // Insert << Insert << Insert
        sizea = Insert(a, sizea, pos1, val1);       
        // Insert2 << Insert1
        int pos21 = T_Insert_Insert(pos2, pos2, pr2, pos1, pos1, pr1);//T(op2,op1)
        sizea = Insert(a, sizea, pos21, val2); 

        // op3    << op1    << op2
        // Insert << Insert << Insert
        sizeb = Insert(b, sizeb, pos2, val2);       
        // Insert1 << Insert2
        int pos12 = T_Insert_Insert(pos1, pos1, pr1, pos2, pos2, pr2);//T(op1,op2)
        sizeb = Insert(b, sizeb, pos12, val1);

        assert sizea == sizeb;
        assert forall {int i in (0 : sizea); a[i] == b[i]};

        // C2:

        // Insert3 << Insert1
        int pos31 = T_Insert_Insert(pos3, pos3, pr3, pos1, pos1, pr1);//T(op3,op1)
        // Insert3 << Insert2
        int pos321 = T_Insert_Insert(pos31, pos3, pr3, pos21, pos2, pr2);//T(T(op3,op1),T(op2,op1))
        sizea = Insert(a, sizea, pos321, val3);

        // Insert3 << Insert2
        int pos32 = T_Insert_Insert(pos3, pos3, pr3, pos2, pos2, pr2);//T(op3,op2)
        // Insert3 << Insert1
        int pos312 = T_Insert_Insert(pos32, pos3, pr3, pos12, pos1, pr1);//T(T(op3,op2),T(op1,op2))
        sizeb = Insert(b, sizeb, pos312, val3);

        assert sizea == sizeb;
        return sizea;
    }

    // Delete__Delete_Delete
    static int Delete__Delete_Delete(int[]! a, int[]! b, int size, int pos3, int pr3, int pos2, int pr2, int pos1, int pr1) 
        requires a != b;
        requires pr1!=pr2;
        requires pr2!=pr3;
        requires pr3!=pr1;
        requires forall {int i in (0 : size); a[i] == b[i]};
        requires a.Length == b.Length;      
        requires size < a.Length - 2;
        requires size >= 0;
        requires pos1 < size;
        requires pos2 < size;
        requires pos3 < size;
        requires pos1 >= 0;
        requires pos2 >= 0;
        requires pos3 >= 0;      
        modifies a[*], b[*];
        ensures forall {int i in (0 : result); a[i] == b[i]};
    {
        int sizea = size, sizeb = size;

        // C1:

        // op3    << op2    << op1
        // Delete << Delete << Delete        
        sizea = Delete(a, sizea, pos1);        
        // Delete2 << Delete1
        int pos21 = T_Delete_Delete(pos2,pos1);
        if (pos21 != -1) //not noOp;
            sizea = Delete(a, sizea, pos21);

        // op3    << op1    << op2
        // Delete << Delete << Delete
        sizeb = Delete(b, sizeb, pos2);
        // Delete2 << Delete1
        int pos12 = T_Delete_Delete(pos1,pos2);
        if (pos12 != -1) //not noOp;
            sizeb = Delete(b, sizeb, pos12);                

        assert sizea == sizeb;
        assert forall {int i in (0 : sizea); a[i] == b[i]};

        // C2:

        // Delete3 << Delete1
        int pos31 = T_Delete_Delete(pos3,pos1);             
        int pos321;
        if(pos31 == -1) //T(noOP,*) == noOP ??
            pos321 = -1;
        else
            {
                if(pos21 == -1) //T(*,noOP)= *                
                    pos321=pos31;
                else
                    pos321 = T_Delete_Delete(pos31,pos21);
            }
        if(pos321 != -1) //not noOP;
            sizea = Delete(a, sizea, pos321);

        // Delete3 << Delete2        
        int pos32 = T_Delete_Delete(pos3,pos2);     
        int pos312;
        if(pos32 == -1) //T(noOP,*) == noOP ??
            pos312 = -1;
        else
            {
                if(pos12 == -1) //T(*,noOP)= *
                    pos312 = pos32;
                else
                    pos312 = T_Delete_Delete(pos32,pos12);
            }
        if(pos312 != -1)//noOP;
            sizeb = Delete(b, sizeb, pos312);
		
        assert sizea == sizeb;
        return sizea;
    }

    // Insert__Delete_Delete
    static int Insert__Delete_Delete(int[]! a, int[]! b, int size, int pos3, int val3, int pr3, int pos2, int pr2, int pos1, int pr1) 
        requires a != b;
        requires forall {int i in (0 : size); a[i] == b[i]};
        requires a.Length == b.Length;      
        requires size < a.Length - 2;
        requires size >= 0;
        requires pos1 < size;
        requires pos2 < size;
        requires pos3 <= size;
        requires pos1 >= 0;
        requires pos2 >= 0;
        requires pos3 >= 0;      
        requires pr1 != pr2;       
        requires pr2 != pr3;
        requires pr3 != pr1;
        modifies a[*], b[*];
        ensures forall {int i in (0 : result); a[i] == b[i]};
    {
        int sizea = size, sizeb = size;

        // C1: 

        // op3    << op2    << op1
        // Insert << Delete << Delete        
        sizea = Delete(a, sizea, pos1);
        // Delete2 << Delete1
        int pos21 = T_Delete_Delete(pos2,pos1);
        if (pos21 != -1) //noOP;
            sizea = Delete(a, sizea, pos21);                

        // op3    << op1    << op2
        // Insert << Delete << Delete
        sizeb = Delete(b, sizeb, pos2);
        // Delete1 << Delete2
        int pos12 = T_Delete_Delete(pos1,pos2);
        if (pos12 != -1) //not noOP;
            sizeb = Delete(b, sizeb, pos12);                

        assert sizea == sizeb;
        assert forall {int i in (0 : sizea); a[i] == b[i]};

        // C2:

        // Insert3 << Delete1
        int pos31 = T_Insert_Delete(pos3,pos3,pr3,pos1);
        // Insert31 << Delete21        
        int pos321;
        if(pos21 == -1)
            pos321 = pos31;
        else
            pos321 = T_Insert_Delete(pos31,pos3,pr3,pos21);
        sizea = Insert(a, sizea, pos321, val3);

        // Insert3 << Delete2
        int pos32 = T_Insert_Delete(pos3,pos3,pr3,pos2);
        //Insert32 << Delete12        
        int pos312;
        if(pos12 == -1)
            pos312 = pos32;
        else
            pos312 = T_Insert_Delete(pos32,pos3,pr3,pos12);
        sizeb = Insert(b, sizeb, pos312, val3);

        assert sizea == sizeb;
        return sizea;
    }

    // Delete__Insert_Insert
    static int Delete__Insert_Insert_C2(int[]! a, int[]! b, int size, int pos3, int pos2, int val2, int pr2, int pos1, int val1, int pr1) 
        requires a != b;
        requires forall {int i in (0 : size); a[i] == b[i]};
        requires a.Length == b.Length;      
        requires size < a.Length - 2;
        requires size >= 0;
        requires pos1 <= size;
        requires pos2 <= size;
        requires pos3 < size;
        requires pos1 >= 0;
        requires pos2 >= 0;
        requires pos3 >= 0;       
        requires pr1 != pr2;
        modifies a[*], b[*];
        ensures forall {int i in (0 : result); a[i] == b[i]};
    {
        int sizea = size, sizeb = size;

        // C1:

        // op3    << op2    << op1
        // Delete << Insert << Insert
        sizea = Insert(a, sizea, pos1, val1);       
        // Insert2 << Insert1
        int pos21 = T_Insert_Insert(pos2,pos2,pr2,pos1,pos1,pr1);
        sizea = Insert(a, sizea, pos21, val2);

        // op3    << op1    << op2
        // Delete << Insert << Insert
        sizeb = Insert(b, sizeb, pos2, val2);       
        // Insert1 << Insert2
        int pos12 = T_Insert_Insert(pos1,pos1,pr1,pos2,pos2,pr2);
        sizeb = Insert(b, sizeb, pos12, val1);

        assert sizea == sizeb;
        assert forall {int i in (0 : sizea); a[i] == b[i]};

        // C2:

        // Delete3 << Insert1
        int pos31 = T_Delete_Insert(pos3,pos1,pos1,pr1);
        // Delete3 << Insert2
        int pos321 = T_Delete_Insert(pos31,pos21,pos2,pr2);
        sizea = Delete(a, sizea, pos321);

        // Delete3 << Insert1
        int pos32 = T_Delete_Insert(pos3,pos2,pos2,pr2);
        // Delete32 << Insert12
        int pos312 = T_Delete_Insert(pos32,pos12,pos1,pr1);
        sizeb = Delete(b, sizeb, pos312);

        assert sizea == sizeb;
        return sizea;
    }

    // Delete__Insert_Delete (Delete after the sequence Delete o Insert)
    // Delete__Delete_Insert (Delete after the sequence Insert o Delete)
    static int Delete__Insert_Delete(int[]! a, int[]! b, int size, int pos3, int pos2, int val2, int pr2, int pos1) 
        requires a != b;
        requires forall {int i in (0 : size); a[i] == b[i]};
        requires a.Length == b.Length;      
        requires size < a.Length - 2;
        requires size >= 0;
        requires pos1 < size;
        requires pos2 <= size;
        requires pos3 < size;
        requires pos1 >= 0;
        requires pos2 >= 0;
        requires pos3 >= 0;    
        modifies a[*], b[*];
        ensures forall {int i in (0 : result); a[i] == b[i]};
    {
        int sizea = size, sizeb = size;

        // op3    << op2    << op1
        // Delete << Insert << Delete
        sizea = Delete(a, sizea, pos1);
        // Insert2 << Delete1
        int pos21 = T_Insert_Delete(pos2,pos2,pr2,pos1);
        sizea = Insert(a, sizea, pos21, val2);

        // op3    << op1    << op2
        // Delete << Delete << Insert
        sizeb = Insert(b, sizeb, pos2, val2);
        // Delete1 << Insert2
        int pos12 = T_Delete_Insert(pos1, pos2, pos2, pr2);
        sizeb = Delete(b, sizeb, pos12);        

        assert sizea == sizeb;
        assert forall {int i in (0 : sizea); a[i] == b[i]};

        // C2:

        // Delete3 << Delete1
        int pos31 = T_Delete_Delete(pos3,pos1);
        if(pos31 != -1) //not noOp
            {
                int pos321 = T_Delete_Insert(pos31, pos21, pos2, pr2);
                sizea = Delete(a, sizea, pos321);                
            }

        // Delete3 << Insert2
        int pos32 = T_Delete_Insert(pos3, pos2, pos2, pr2);
        // Delete3 << Delete1
        int pos312 = T_Delete_Delete(pos32,pos12);
        if (pos312 != -1) //not noOp
            sizeb = Delete(b, sizeb, pos312);                

        assert sizea == sizeb;
        return sizea;
    }

    // Insert__Insert_Delete (Delete after the sequence Delete o Insert)
    // Insert__Delete_Insert (Delete after the sequence Insert o Delete)
    static int Insert__Insert_Delete_C2(int[]! a, int[]! b, int size, int pos3, int val3, int pr3, int pos2, int val2, int pr2, int pos1) 
        requires a != b;
        requires forall {int i in (0 : size); a[i] == b[i]};
        requires a.Length == b.Length;      
        requires size < a.Length - 2;
        requires size >= 0;
        requires pos1 < size;
        requires pos2 <= size;
        requires pos3 < size;
        requires pos1 >= 0;
        requires pos2 >= 0;
        requires pos3 >= 0;
        requires pr3 != pr2;
        modifies a[*], b[*];
        ensures forall {int i in (0 : result); a[i] == b[i]};    
    {
        int sizea = size, sizeb = size;

        // C1:

        // op3    << op2    << op1
        // Insert << Insert << Delete
        sizea = Delete(a, sizea, pos1);
        // Insert2 << Delete1
        int pos21 = T_Insert_Delete(pos2, pos2, pr2, pos1);
        sizea = Insert(a, sizea, pos21, val2);

        // op3    << op1    << op2
        // Insert << Delete << Insert
        sizeb = Insert(b, sizeb, pos2, val2);
        // Delete1 << Insert2
        int pos12 = T_Delete_Insert(pos1, pos2, pos2, pr2);
        sizeb = Delete(b, sizeb, pos12);

        assert sizea == sizeb;
        assert forall {int i in (0 : sizea); a[i] == b[i]};

        // C2: 

        // Insert3 << Delete1
        int pos31 = T_Insert_Delete(pos3, pos3, pr3, pos1);
        // Insert3 << Insert2
        int pos321 = T_Insert_Insert(pos31,pos3,pr3,pos21,pos2,pr2);
        sizea = Insert(a, sizea, pos321, val3);                

        // Insert3 << Insert2
        int pos32 = pos3 > pos2 || (pos3 == pos2 && pr3 > pr2) ? pos3 + 1 : pos3;
        // Insert3 << Delete1
        int pos312 = T_Insert_Delete(pos32, pos3, pr3, pos12);
        sizeb = Insert(b, sizeb, pos312, val3);

        assert sizea == sizeb;
        return sizea;
    }

    // ------------------------------------------------------------------   
    //  Transforms
    // ------------------------------------------------------------------   

    [Inline]
    static int T_Insert_Insert(int pos1, int posp1, int pr1, int pos2, int posp2, int pr2)
    {
        int retval = pos1;
        if (pos1 > pos2 || 
            (pos1 == pos2 && 
             (posp1 > posp2 || 
              (posp1 == posp2 && pr1 > pr2))))
            retval = pos1 + ?!;
        return retval;        
    }

    [Inline]
    static int T_Insert_Delete(int pos1, int posp1, int pr1, int pos2)
    {
        int retval = pos1;
        if (pos1 > pos2)
            retval = pos1 - 1;
        return retval;
    }

    [Inline]
    static int T_Delete_Insert(int pos1, int pos2, int posp2, int pr2)    
    {
        int retval = pos1;
        if (pos1 >= pos2)
            retval = pos1 + 1;        
        return retval;
    }

    [Inline]
    static int T_Delete_Delete(int pos1, int pos2)
    {
        int retval = pos1;
        if (pos1 > pos2)
            retval = pos1 - 1;
        if(pos1 == pos2)
            retval = -1;
        return retval;
    }

    // ------------------------------------------------------------------   
    //  Operations
    // ------------------------------------------------------------------   

    // Insert
    static int Insert(int[]! a, int size, int pos, int val)
        requires size < a.Length;
        requires pos >= 0;
        requires pos <= size;
        modifies a[*];    
        ensures forall {int i in (0 : pos); a[i] == old(a[i])};
        ensures a[pos] == val;
        ensures forall {int i in (pos+1 : size+1); a[i] == old(a[i-1])};
        ensures result == size + 1;
    {
        int[]! copy = ArrayCopy(a);
        return InsertH(a, size, pos, val, copy);
    }

    [Inline]
    static int InsertH(int[]! a, int size, int pos, int val, int[]! aCp)
        requires a != aCp;
        modifies a[*], aCp.0;
    {
        for (int i = size; i > pos; i--) 
            invariant i <= size;
            invariant forall {int j in (i+1 : size+1); a[j] == aCp[j-1]};
            invariant forall {int j in (0 : pos); a[j] == aCp[j]};
        {
            a[i] = aCp[i-1];
        }
        a[pos] = val;
        return size + 1;
    }

    // Delete
    static int Delete(int[]! a, int size, int pos)
        requires size <= a.Length;
        requires pos >= 0;
        requires pos < size;
        modifies a[*];    
        ensures forall {int i in (0 : pos); a[i] == old(a[i])};
        ensures forall {int i in (pos : size-1); a[i] == old(a[i+1])};
        ensures result == size - 1;
    {
        int[]! copy = ArrayCopy(a);
        return DeleteH(a, size, pos, copy);
    }

    [Inline]
    static int DeleteH(int[]! a, int size, int pos, int[]! aCp)
        requires a != aCp;
        modifies a[*], aCp.0;
        ensures forall {int i in (0 : size); aCp[i] == old(aCp[i])};
        ensures forall {int i in (pos : size-1); a[i] == old(a[i+1])};
    {
        for (int i = size - 1; i > pos; i--) 
            invariant i <= size - 1;
            invariant forall {int j in (0 : pos); a[j] == aCp[j]};
            invariant forall {int j in (i+1 : size); a[j-1] == aCp[j]};
        {
            a[i-1] = aCp[i];
        }
        return size - 1;
    }

    static int[]! ArrayCopy(int[]! src)    	
        ensures result.Length == src.Length;
        ensures forall {int i in (0 : src.Length); result[i] == src[i]};
        ensures result != src;
    {
        int[] dest = new int[src.Length];
        for(int i = 0; i < src.Length; i++)
            invariant forall{int j in (0:i); dest[j] == src[j]};
        {
            dest[i] = src[i];
        }
        return dest;	
    }

    public static void Main(string[] args) { }

}
    
