
using System;
using Microsoft.Contracts;

public class List {

    // ------------------------------------------------------------------   
    //  Globals
    // ------------------------------------------------------------------   
    
    const int LENGTH = 10;

    // ------------------------------------------------------------------   
    //  Fields
    // ------------------------------------------------------------------   

    [Peer] public int[]! elements;
    public int size;

    [Verify(false)]
    public List() { this.elements = new int[LENGTH]; }

    // ------------------------------------------------------------------   
    //  C1
    // ------------------------------------------------------------------   
    
    // Insert_Insert 

    [Verify(false)]
    static void Insert_Insert_C1(List! a, List! b, int pos1, int val1, int pos2, int val2) 
	requires a.elements.Length <= LENGTH;
        requires a.elements != b.elements;
        requires a.elements.Length == b.elements.Length;
        requires a.size == b.size;
        requires forall {int i in (0 : a.size); a.elements[i] == b.elements[i]};
        requires a.elements.Length == b.elements.Length;      
        requires a.size < a.elements.Length - 1;
        requires a.size >= 0;
        requires pos1 <= a.size;
        requires pos2 <= a.size;
        requires pos1 >= 0;
        requires pos2 >= 0;
        modifies a.size, a.elements[*], b.size, b.elements[*];
        ensures a.size == b.size;
        ensures forall {int i in (0 : a.size); a.elements[i] == b.elements[i]};
    {
	// op2     << op1
	// Insert2 << Insert1
	a.Insert(pos1, val1);       
	a.T_Insert_Insert(pos2, val2, pos1, val1);
	
	// op1     << op2
	// Insert1 << Insert2
	b.Insert(pos2, val2);       
	b.T_Insert_Insert(pos1, val1, pos2, val2);
    }

    // Insert_Delete 
    [Verify(true)]
    static void Insert_Delete_C1(List! a, List! b, int pos1, int val1, int pos2) 
	requires a.elements.Length <= LENGTH;
        requires a.elements != b.elements;
        requires a.elements.Length == b.elements.Length;
        requires a.size == b.size;
        requires forall {int i in (0 : a.size); a.elements[i] == b.elements[i]};
        requires a.elements.Length == b.elements.Length;      
        requires a.size < a.elements.Length;
        requires a.size >= 0;
        requires pos1 <= a.size;
        requires pos2 < a.size;
        requires pos1 >= 0;
        requires pos2 >= 0;
        modifies a.size, a.elements[*], b.size, b.elements[*];
        ensures a.size == b.size;
        ensures forall {int i in (0 : a.size); a.elements[i] == b.elements[i]};
    {
	// op2     << op1
	// Delete2 << Insert1
	a.Insert(pos1, val1);
	a.T_Delete_Insert(pos2, pos1, val1);
	
	// op1     << op2
	// Insert1 << Delete2
	b.Delete(pos2);       
	b.T_Insert_Delete(pos1, val1, pos2);
    }
    
    // ------------------------------------------------------------------   
    //  Transforms
    // ------------------------------------------------------------------   
    
    [Inline]
    [Verify(true)]
    void T_Insert_Insert(int pos1, int val1, int pos2, int val2)
	modifies size, elements[*];
    {
	if (pos1 > pos2)
	    Insert(pos1 + 1, val1);	
	else if (pos1 == pos2 && val1 > val2)
	    Insert(pos1 + 1, val1);
	else
	    Insert(pos1, val1);
    }

    [Inline]
    [Verify(true)]
    void T_Insert_Delete(int pos1, int val1, int pos2)
	modifies size, elements[*];
    {
// 	if (pos1 > pos2)	    
// 	    Insert(pos1 - 1, val1);
// 	else 
// 	    Insert(pos1, val1);
	?!{repeat: 1, ifbranches: 2, branchops: 1, conjunctions: 1, ops: {Insert}, condvars: {pos1, pos2}, argvars: {pos1}}
    }

    [Inline]
    [Verify(true)]
    void T_Delete_Insert(int pos1, int pos2, int val2)
	modifies size, elements[*];
    {
	if (pos1 >= pos2)
	    Delete(pos1 + 1);
	else
	    Delete(pos1);
// 	?!{repeat: 1, ifbranches: 2, branchops: 1, conjunctions: 1, ops: {Delete}, condvars: {pos1, pos2}, argvars: {pos1}}

    }
  
    // ------------------------------------------------------------------   
    //  Operations
    // ------------------------------------------------------------------   
    
    // Insert
    [Verify(false)]
    operation void Insert(transformable int pos, int val)
        requires size < elements.Length;
        requires pos >= 0;
        requires pos <= size;
        modifies size, elements[*];    
        ensures forall {int i in (0 : pos); elements[i] == old(elements[i])};
        ensures elements[pos] == val;
        ensures forall {int i in (pos+1 : size); elements[i] == old(elements[i-1])};
        ensures size == old(size) + 1;
    {
	int[]! copy = ArrayCopy(elements);
	InsertH(pos, val, copy);
    }
    
    [Inline]
    [Verify(false)]
    void InsertH(int pos, int val, int[]! elementsCp)
        modifies size, elements[*], elementsCp.0;
    {
	for (int i = size; i > pos; i--) 
	    invariant i <= size;
	    invariant forall {int j in (i+1 : size+1); elements[j] == elementsCp[j-1]};
	    invariant forall {int j in (0 : pos); elements[j] == elementsCp[j]};
	{
	    elements[i] = elementsCp[i-1];
	}
	elements[pos] = val;
	size++;
    }

    // Delete
    [Verify(false)]
    operation void Delete(transformable int pos)
        requires size <= elements.Length;
        requires pos >= 0;
        requires pos < size;
        modifies size, elements[*];
        ensures forall {int i in (0 : pos); elements[i] == old(elements[i])};
        ensures forall {int i in (pos : size); elements[i] == old(elements[i+1])};
        ensures size == old(size) - 1;
    {
        int[]! copy = ArrayCopy(elements);
        DeleteH(pos, copy);
    }

    [Inline]
    [Verify(false)]
    void DeleteH(int pos, int[]! elementsCp)
        modifies size, elements[*], elementsCp.0;
    {
        for (int i = size - 1; i > pos; i--) 
            invariant i <= size - 1;
            invariant forall {int j in (0 : pos); elements[j] == elementsCp[j]};
            invariant forall {int j in (i+1 : size); elements[j-1] == elementsCp[j]};
        {
            elements[i-1] = elementsCp[i];
        }
        size--;
    }
    
    // ------------------------------------------------------------------   
    //  Helpers
    // ------------------------------------------------------------------   
    
    [Verify(false)]
    static int[]! ArrayCopy(int[]! src)
	modifies src.0;
	ensures result.Length == src.Length;
        ensures forall {int i in (0 : src.Length); result[i] == src[i]};
        ensures result != src;
    {
	int[] dest = new int[src.Length];
	for(int i = 0; i < src.Length; i++)
	    invariant forall{int j in (0:i); dest[j] == src[j]};
	{
	    dest[i] = src[i];
	}
	return dest;	
    }
    
    [Verify(false)]
    public static void Main(string[] args) { }
    
}
    
