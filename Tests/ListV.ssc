
using System;
using Microsoft.Contracts;

public class List {

    /*

    // ------------------------------------------------------------------   
    //  OT Definition
    // ------------------------------------------------------------------   

    // ------------------------------------------------------------------

    // C1:             
    //         op1 . T(op2, op1) = op2 . T(op1, op2)

    // C2:             
    //         T(T(op3, op1), T(op2, op1)) = T(T(op3, op2), T(op1, op2))


    // ------------------------------------------------------------------

    T(Insert(pos1, origPos1, pr1), Insert(pos2, origPos2, pr2)) = 
        Insert(pos1 > pos2 || 
                (pos1 == pos2 && 
                   (origPos1 > origPos2 || pr1 > pr2)) ? 
               pos1 + 1 : pos1, pr1, origPos1)

    T(Delete(pos1), Delete(pos2)) = 
        pos1 == pos2 ? Noop : Delete(pos1 > pos2 ? pos1 - 1 : pos1)

    T(Insert(pos1), Delete(pos2)) = 
        Insert(pos1 > pos2 ? pos1 - 1 : pos1)

    T(Delete(pos1), Insert(pos2)) = 
        Insert(pos1 >= pos2 ? pos1 + 1 : pos1)

    // ------------------------------------------------------------------

    */

    /*


    // ------------------------------------------------------------------   
    //  Redundant Tests
    // ------------------------------------------------------------------   

    // Redundant Test1: 4 sites
    //
    // Insert__Insert_Insert_Delete

    static int Insert__Insert_Insert_Delete(int[]! a1, int[]! a2, int[]! a3, int[]! a4, int[]! a5, int[]! a6, int size, int pos4, int val4, int pr4, int pos3, int val3, int pr3, int pos2, int val2, int pr2, int pos1) 
        requires a1 != a2;
        requires a1 != a3;
        requires a1 != a4;
        requires a1 != a5;
        requires a1 != a6;
        requires a2 != a3;
        requires a2 != a4;
        requires a2 != a5;
        requires a2 != a6;
        requires a3 != a4;
        requires a3 != a5;
        requires a3 != a6;
        requires a4 != a5;
        requires a4 != a6;
        requires a5 != a6;
        requires forall {int i in (0 : size); a1[i] == a2[i]};
        requires forall {int i in (0 : size); a2[i] == a3[i]};
        requires forall {int i in (0 : size); a3[i] == a4[i]};
        requires forall {int i in (0 : size); a4[i] == a5[i]};
        requires forall {int i in (0 : size); a5[i] == a6[i]};
        requires a1.Length == a2.Length;
        requires a2.Length == a3.Length;
        requires a3.Length == a4.Length;
        requires a4.Length == a5.Length;
        requires a5.Length == a6.Length;
        requires size < a1.Length - 3;
        requires size >= 0;
        requires pos1 < size;
        requires pos2 <= size;
        requires pos3 <= size;
        requires pos4 <= size;
        requires pos1 >= 0;
        requires pos2 >= 0;
        requires pos3 >= 0; 
        requires pos4 >= 0;
        requires pr2 != pr3;
        requires pr3 != pr4;
        requires pr4 != pr2;
        modifies a1[*], a2[*], a3[*], a4[*], a5[*], a6[*];
        ensures forall {int i in (0 : result); a1[i] == a2[i]};
        ensures forall {int i in (0 : result); a2[i] == a3[i]};
        ensures forall {int i in (0 : result); a3[i] == a4[i]};
        ensures forall {int i in (0 : result); a4[i] == a5[i]};
        ensures forall {int i in (0 : result); a5[i] == a6[i]};    

        requires a1.Length <= 7;
    {
        int size1 = size, size2 = size, size3 = size, size4 = size, size5 = size, size6 = size;

        // case: 1 / 6
        // op4    << op3    << op2    << op1 
        // Insert << Insert << Insert << Delete
        size1 = Delete(a1, size1, pos1);       
        // Insert2 << Delete1
        int pos21 = T_Insert_Delete(pos2, pos2, pr2, pos1);
        size1 = Insert(a1, size1, pos21, val2);        
        // Insert3 << Delete1
        int pos31 = T_Insert_Delete(pos3, pos3, pr3, pos1);        
        // Insert3 << Insert2
        int pos321 = T_Insert_Insert(pos31, pos3, pr3, pos21, pos2, pr2);
        size1 = Insert(a1, size1, pos321, val3);
        // Insert4 << Delete1
        int pos41 = T_Insert_Delete(pos4, pos4, pr4, pos1);        
        // Insert4 << Insert2
        int pos421 = T_Insert_Insert(pos41, pos4, pr4, pos21, pos2, pr2);
        // Insert4 << Insert3
        int pos4321 = T_Insert_Insert(pos421, pos4, pr4, pos321, pos3, pr3);
        size1 = Insert(a1, size1, pos4321, val4);

        // case: 2 / 6
        // op4    << op2    << op3    << op1 
        // Insert << Insert << Insert << Delete
        size2 = Delete(a2, size2, pos1);       
        // Insert3 << Delete1
        pos31 = T_Insert_Delete(pos3, pos3, pr3, pos1);
        size2 = Insert(a2, size2, pos31, val3);        
        // Insert2 << Delete1
        pos21 = T_Insert_Delete(pos2, pos2, pr2, pos1);        
        // Insert2 << Insert3
        int pos231 = T_Insert_Insert(pos21, pos2, pr2, pos31, pos3, pr3);
        size2 = Insert(a2, size2, pos231, val2);
        // Insert4 << Delete1
        pos41 = T_Insert_Delete(pos4, pos4, pr4, pos1);        
        // Insert4 << Insert3
        int pos431 = T_Insert_Insert(pos41, pos4, pr4, pos31, pos3, pr3);
        // Insert4 << Insert2
        int pos4231 = T_Insert_Insert(pos431, pos4, pr4, pos231, pos2, pr2);
        size2 = Insert(a2, size2, pos4231, val4);

        // case: 3 / 6
        // op4    << op3    << op1    << op2 
        // Insert << Insert << Delete << Insert 
        size3 = Insert(a3, size3, pos2, val2);       
        // Delete1 << Insert2
        int pos12 = T_Delete_Insert(pos1,pos2,pos2,pr2);
        size3 = Delete(a3, size3, pos12);       
        // Insert3 << Insert2
        int pos32 = T_Insert_Insert(pos3, pos3, pr3, pos2, pos2, pr2);
        // Insert3 << Delete1
        int pos312 = T_Insert_Delete(pos32, pos3, pr3, pos12);
        size3 = Insert(a3, size3, pos312, val3);
        // Insert4 << Insert2
        int pos42 = T_Insert_Insert(pos4, pos4, pr4, pos2, pos2, pr2);
        // Insert4 << Delete1
        int pos412 = T_Insert_Delete(pos42, pos4, pr4, pos12);        
        // Insert4 << Insert3
        int pos4312 = T_Insert_Insert(pos412, pos4, pr4, pos312, pos3, pr3);
        size3 = Insert(a3, size3, pos4312, val4);

        // case: 4 / 6
        // op4    << op2    << op1    << op3
        // Insert << Insert << Delete << Insert
        size4 = Insert(a4, size4, pos3, val3);       
        // Delete1 << Insert3
        int pos13 = T_Delete_Insert(pos1, pos3, pos3, pr3);
        size4 = Delete(a4, size4, pos13);       
        // Insert2 << Insert3
        int pos23 = T_Insert_Insert(pos2, pos2, pr2, pos3, pos3, pr3);
        // Insert2 << Delete1
        int pos213 = T_Insert_Delete(pos23, pos2, pr2, pos13);
        size4 = Insert(a4, size4, pos213, val2);       
        // Insert4 << Insert3
        int pos43 = T_Insert_Insert(pos4, pos4, pr4, pos3, pos3, pr3);
        // Insert4 << Delete1
        int pos413 = T_Insert_Delete(pos43, pos4, pr4, pos13);        
        // Insert4 << Insert2
        int pos4213 = T_Insert_Insert(pos413, pos4, pr4, pos213, pos2, pr2);
        size4 = Insert(a4, size4, pos4213, val4);

        // case: 5 / 6
        // op4    << op1    << op2    << op3
        // Insert << Delete << Insert << Insert
        size5 = Insert(a5, size5, pos3, val3);       
        // Insert2 << Insert3
        pos23 = T_Insert_Insert(pos2, pos2, pr2, pos3, pos3, pr3);
        size5 = Insert(a5, size5, pos23, val2);
        // Delete1 << Insert3
        pos13 = T_Delete_Insert(pos1, pos3, pos3, pr3);
        // Delete1 << Insert2
        int pos123 = T_Delete_Insert(pos13, pos23, pos2, pr2);
        size5 = Delete(a5, size5, pos123);       
        // Insert4 << Insert3
        pos43 = T_Insert_Insert(pos4, pos4, pr4, pos3, pos3, pr3);
        // Insert4 << Insert2
        int pos423 = T_Insert_Insert(pos43, pos4, pr4, pos23, pos2, pr2);
        // Insert4 << Delete1
        int pos4123 = T_Insert_Delete(pos423, pos4, pr4, pos123);        
        size5 = Insert(a5, size5, pos4123, val4);

        // case: 6 / 6
        // op4    << op1    << op3    << op2
        // Insert << Delete << Insert << Insert
        size6 = Insert(a6, size6, pos2, val2);       
        // Insert3 << Insert2
        pos32 = T_Insert_Insert(pos3, pos3, pr3, pos2, pos2, pr2);
        size6 = Insert(a6, size6, pos32, val3);
        // Delete1 << Insert2
        pos12 = T_Delete_Insert(pos1, pos2, pos2, pr2);
        // Delete1 << Insert3
        int pos132 = T_Delete_Insert(pos12, pos32, pos3, pr3);
        size6 = Delete(a6, size6, pos132);       
        // Insert4 << Insert2
        pos42 = T_Insert_Insert(pos4, pos4, pr4, pos2, pos2, pr2);
        // Insert4 << Insert3
        int pos432 = T_Insert_Insert(pos42, pos4, pr4, pos32, pos3, pr3);
        // Insert4 << Delete1
        int pos4132 = T_Insert_Delete(pos432, pos4, pr4, pos132);        
        size6 = Insert(a6, size6, pos4132, val4);

        assert size1 == size2;
        assert size2 == size3;
        assert size3 == size4;
        assert size4 == size5;
        assert size5 == size6;

        return size1;
    }
    */

    /*
    // Redundant Test2: 4 sites
    //
    // Insert__Insert_Insert_Delete
    // Delete__Insert_Insert_Insert

    static int Insert__Insert_Insert_Delete(int[]! a1, int[]! a2, int size, int pos4, int val4, int pr4, int pos3, int val3, int pr3, int pos2, int val2, int pr2, int pos1) 
        requires a1 != a2;
        requires forall {int i in (0 : size); a1[i] == a2[i]};
        requires a1.Length == a2.Length;
        requires size < a1.Length - 2;
        requires size >= 0;
        requires pos1 < size;
        requires pos2 <= size;
        requires pos3 <= size;
        requires pos4 <= size;
        requires pos1 >= 0;
        requires pos2 >= 0;
        requires pos3 >= 0;
        requires pos4 >= 0;       
        requires pr2 != pr3;
        requires pr3 != pr4;
        requires pr4 != pr2;
        modifies a1[*], a2[*];
        ensures forall {int i in (0 : result); a1[i] == a2[i]};
    {
        int size1 = size, size2 = size;

        // op4    << op3    << op2    << op1 
        // Insert << Insert << Insert << Delete
        size1 = Delete(a1, size1, pos1);       
        // Insert2 << Delete1
        int pos21 = T_Insert_Delete(pos2, pos2, pr2, pos1);
        size1 = Insert(a1, size1, pos21, val2);        
        // Insert3 << Delete1
        int pos31 = T_Insert_Delete(pos3, pos3, pr3, pos1);        
        // Insert3 << Insert2
        int pos321 = T_Insert_Insert(pos31, pos3, pr3, pos21, pos2, pr2);
        size1 = Insert(a1, size1, pos321, val3);
        // Insert4 << Delete1
        int pos41 = T_Insert_Delete(pos4, pos4, pr4, pos1);        
        // Insert4 << Insert2
        int pos421 = T_Insert_Insert(pos41, pos4, pr4, pos21, pos2, pr2);
        // Insert4 << Insert3
        int pos4321 = T_Insert_Insert(pos421, pos4, pr4, pos321, pos3, pr3);
        size1 = Insert(a1, size1, pos4321, val4);

        // case: 7 / 12
        // op1    << op3    << op2    << op4 
        // Delete << Insert << Insert << Insert
        size2 = Insert(a2, size2, pos4, val4);       
        // Insert2 << Insert4
        int pos24 = T_Insert_Insert(pos2, pos2, pr2, pos4, pos4, pr4);
        size2 = Insert(a2, size2, pos24, val2);
        // Insert3 << Insert4
        int pos34 = T_Insert_Insert(pos3, pos3, pr3, pos4, pos4, pr4);
        // Insert3 << Insert2
        int pos324 = T_Insert_Insert(pos34, pos3, pr3, pos24, pos2, pr2);
        size2 = Insert(a2, size2, pos324, val3);
        // Delete1 << Insert4
        int pos14 = T_Delete_Insert(pos1, pos4, pos4, pr4);
        // Delete1 << Insert2
        int pos124 = T_Delete_Insert(pos14, pos24, pos2, pr2);
        // Delete1 << Insert3
        int pos1324 = T_Delete_Insert(pos124, pos324, pos3, pr3);
        size2 = Delete(a2, size2, pos1324);

        assert size1 == size2;

        return size1;
    }
    */

    /*
    // Redundant Test3: 5 sites
    //
    // Insert__Insert_Insert_Delete_Delete

    static int Insert__Insert_Insert_Delete_Delete(int[]! a1, int[]! a2, int size, int pos5, int val5, int pr5, int pos4, int val4, int pr4, int pos3, int val3, int pr3, int pos2, int pos1) 
        requires a1 != a2;
        requires forall {int i in (0 : size); a1[i] == a2[i]};
        requires a1.Length == a2.Length;
        requires size < a1.Length - 2;
        requires size >= 0;
        requires pos1 < size;
        requires pos2 <= size;
        requires pos3 <= size;
        requires pos4 <= size;
        requires pos1 >= 0;
        requires pos2 >= 0;
        requires pos3 >= 0;
        requires pos4 >= 0;       
        requires pr2 != pr3;
        requires pr3 != pr4;
        requires pr4 != pr2;
        modifies a1[*], a2[*];
        ensures forall {int i in (0 : result); a1[i] == a2[i]};
    {
        int size1 = size, size2 = size;

        // op5    << op4    << op3    << op2    << op1 
        // Insert << Insert << Insert << Delete << Delete
        size1 = Delete(a1, size1, pos1);       
        // Delete2 << Delete1
        int pos21 = T_Delete_Delete(pos2, pos1);
        if (pos21 != -1) //not noOp;
            sizea = Delete(a, sizea, pos21);
        // Insert3 << Delete1
        int pos31 = T_Insert_Delete(pos3, pos3, pr3, pos1);        
        // Insert3 << Delete2
        int pos321;
        if (pos21 == -1)
            pos321 = pos31;
        else
            pos321 = T_Insert_Delete(pos31, pos3, pr3, pos21);
        size1 = Insert(a1, size1, pos321, val3);
        // Insert4 << Delete1
        int pos41 = T_Insert_Delete(pos4, pos4, pr4, pos1);        
        // Insert4 << Delete2
        int pos421;
        if (pos21 == -1)
            pos421 = pos41;
        else
            pos421 = T_Insert_Delete(pos41, pos4, pr4, pos21);                
        // Insert4 << Insert3
        int pos4321 = T_Insert_Insert(pos421, pos4, pr4, pos321, pos3, pr3);
        size1 = Insert(a1, size1, pos4321, val4);
        // Insert5 << Delete1
        int pos51 = T_Insert_Delete(pos5, pos5, pr5, pos1);        
        // Insert5 << Delete2
        int pos521;
        if (pos21 == -1)
            pos521 = pos51;
        else
            pos521 = T_Insert_Delete(pos51, pos5, pr5, pos21);                
        // Insert5 << Insert3
        int pos5321 = T_Insert_Insert(pos521, pos5, pr5, pos321, pos3, pr3);
        // Insert5 << Insert4
        int pos54321 = T_Insert_Insert(pos5321, pos5, pr5, pos4321, pos4, pr4);
        size1 = Insert(a1, size1, pos4321, val5);


    }
    */

    // ------------------------------------------------------------------   
    //  C1, C2 Verification
    // ------------------------------------------------------------------   

    // Insert__Insert_Insert 
    static int Insert__Insert_Insert(int[]! a, int[]! b, int size, int pos3, int val3, int pr3, int pos2, int val2, int pr2, int pos1, int val1, int pr1) 
        requires a != b;
        requires forall {int i in (0 : size); a[i] == b[i]};
        requires a.Length == b.Length;      
        requires size < a.Length - 2;
        requires size >= 0;
        requires pos1 <= size;
        requires pos2 <= size;
        requires pos3 <= size;
        requires pos1 >= 0;
        requires pos2 >= 0;
        requires pos3 >= 0;       
        requires pr1 != pr2;
        requires pr2 != pr3;
        requires pr3 != pr1;
        modifies a[*], b[*];
        ensures forall {int i in (0 : result); a[i] == b[i]};
    {
        int sizea = size, sizeb = size;

        // C1:

        // op3    << op2    << op1
        // Insert << Insert << Insert
        sizea = Insert(a, sizea, pos1, val1);       
        // Insert2 << Insert1
        int pos21 = T_Insert_Insert(pos2, pos2, pr2, pos1, pos1, pr1);//T(op2,op1)
        sizea = Insert(a, sizea, pos21, val2); 

        // op3    << op1    << op2
        // Insert << Insert << Insert
        sizeb = Insert(b, sizeb, pos2, val2);       
        // Insert1 << Insert2
        int pos12 = T_Insert_Insert(pos1, pos1, pr1, pos2, pos2, pr2);//T(op1,op2)
        sizeb = Insert(b, sizeb, pos12, val1);

        assert sizea == sizeb;
        assert forall {int i in (0 : sizea); a[i] == b[i]};

        // C2:

        // Insert3 << Insert1
        int pos31 = T_Insert_Insert(pos3, pos3, pr3, pos1, pos1, pr1);//T(op3,op1)
        // Insert3 << Insert2
        int pos321 = T_Insert_Insert(pos31, pos3, pr3, pos21, pos2, pr2);//T(T(op3,op1),T(op2,op1))
        sizea = Insert(a, sizea, pos321, val3);

        // Insert3 << Insert2
        int pos32 = T_Insert_Insert(pos3, pos3, pr3, pos2, pos2, pr2);//T(op3,op2)
        // Insert3 << Insert1
        int pos312 = T_Insert_Insert(pos32, pos3, pr3, pos12, pos1, pr1);//T(T(op3,op2),T(op1,op2))
        sizeb = Insert(b, sizeb, pos312, val3);

        assert sizea == sizeb;
        return sizea;
    }

    // Delete__Delete_Delete
    static int Delete__Delete_Delete(int[]! a, int[]! b, int size, int pos3, int pr3, int pos2, int pr2, int pos1, int pr1) 
        requires a != b;
        requires pr1!=pr2;
        requires pr2!=pr3;
        requires pr3!=pr1;
        requires forall {int i in (0 : size); a[i] == b[i]};
        requires a.Length == b.Length;      
        requires size < a.Length - 2;
        requires size >= 0;
        requires pos1 < size;
        requires pos2 < size;
        requires pos3 < size;
        requires pos1 >= 0;
        requires pos2 >= 0;
        requires pos3 >= 0;      
        modifies a[*], b[*];
        ensures forall {int i in (0 : result); a[i] == b[i]};
    {
        int sizea = size, sizeb = size;

        // C1:

        // op3    << op2    << op1
        // Delete << Delete << Delete        
        sizea = Delete(a, sizea, pos1);        
        // Delete2 << Delete1
        int pos21 = T_Delete_Delete(pos2,pos1);
        if (pos21 != -1) //not noOp;
            sizea = Delete(a, sizea, pos21);

        // op3    << op1    << op2
        // Delete << Delete << Delete
        sizeb = Delete(b, sizeb, pos2);
        // Delete2 << Delete1
        int pos12 = T_Delete_Delete(pos1,pos2);
        if (pos12 != -1) //not noOp;
            sizeb = Delete(b, sizeb, pos12);                

        assert sizea == sizeb;
        assert forall {int i in (0 : sizea); a[i] == b[i]};

        // C2:

        // Delete3 << Delete1
        int pos31 = T_Delete_Delete(pos3,pos1);             
        int pos321;
        if(pos31 == -1) //T(noOP,*) == noOP ??
            pos321 = -1;
        else
            {
                if(pos21 == -1) //T(*,noOP)= *                
                    pos321=pos31;
                else
                    pos321 = T_Delete_Delete(pos31,pos21);
            }
        if(pos321 != -1) //not noOP;
            sizea = Delete(a, sizea, pos321);

        // Delete3 << Delete2        
        int pos32 = T_Delete_Delete(pos3,pos2);     
        int pos312;
        if(pos32 == -1) //T(noOP,*) == noOP ??
            pos312 = -1;
        else
            {
                if(pos12 == -1) //T(*,noOP)= *
                    pos312 = pos32;
                else
                    pos312 = T_Delete_Delete(pos32,pos12);
            }
        if(pos312 != -1)//noOP;
            sizeb = Delete(b, sizeb, pos312);
		
        assert sizea == sizeb;
        return sizea;
    }

    // Insert__Delete_Delete
    static int Insert__Delete_Delete(int[]! a, int[]! b, int size, int pos3, int val3, int pr3, int pos2, int pr2, int pos1, int pr1) 
        requires a != b;
        requires forall {int i in (0 : size); a[i] == b[i]};
        requires a.Length == b.Length;      
        requires size < a.Length - 2;
        requires size >= 0;
        requires pos1 < size;
        requires pos2 < size;
        requires pos3 <= size;
        requires pos1 >= 0;
        requires pos2 >= 0;
        requires pos3 >= 0;      
        requires pr1 != pr2;       
        requires pr2 != pr3;
        requires pr3 != pr1;
        modifies a[*], b[*];
        ensures forall {int i in (0 : result); a[i] == b[i]};
    {
        int sizea = size, sizeb = size;

        // C1: 

        // op3    << op2    << op1
        // Insert << Delete << Delete        
        sizea = Delete(a, sizea, pos1);
        // Delete2 << Delete1
        int pos21 = T_Delete_Delete(pos2,pos1);
        if (pos21 != -1) //noOP;
            sizea = Delete(a, sizea, pos21);                

        // op3    << op1    << op2
        // Insert << Delete << Delete
        sizeb = Delete(b, sizeb, pos2);
        // Delete1 << Delete2
        int pos12 = T_Delete_Delete(pos1,pos2);
        if (pos12 != -1) //not noOP;
            sizeb = Delete(b, sizeb, pos12);                

        assert sizea == sizeb;
        assert forall {int i in (0 : sizea); a[i] == b[i]};

        // C2:

        // Insert3 << Delete1
        int pos31 = T_Insert_Delete(pos3,pos3,pr3,pos1);
        // Insert31 << Delete21        
        int pos321;
        if(pos21 == -1)
            pos321 = pos31;
        else
            pos321 = T_Insert_Delete(pos31,pos3,pr3,pos21);
        sizea = Insert(a, sizea, pos321, val3);

        // Insert3 << Delete2
        int pos32 = T_Insert_Delete(pos3,pos3,pr3,pos2);
        //Insert32 << Delete12        
        int pos312;
        if(pos12 == -1)
            pos312 = pos32;
        else
            pos312 = T_Insert_Delete(pos32,pos3,pr3,pos12);
        sizeb = Insert(b, sizeb, pos312, val3);

        assert sizea == sizeb;
        return sizea;
    }

    // Delete__Insert_Insert
    static int Delete__Insert_Insert_C2(int[]! a, int[]! b, int size, int pos3, int pos2, int val2, int pr2, int pos1, int val1, int pr1) 
        requires a != b;
        requires forall {int i in (0 : size); a[i] == b[i]};
        requires a.Length == b.Length;      
        requires size < a.Length - 2;
        requires size >= 0;
        requires pos1 <= size;
        requires pos2 <= size;
        requires pos3 < size;
        requires pos1 >= 0;
        requires pos2 >= 0;
        requires pos3 >= 0;       
        requires pr1 != pr2;
        modifies a[*], b[*];
        ensures forall {int i in (0 : result); a[i] == b[i]};
    {
        int sizea = size, sizeb = size;

        // C1:

        // op3    << op2    << op1
        // Delete << Insert << Insert
        sizea = Insert(a, sizea, pos1, val1);       
        // Insert2 << Insert1
        int pos21 = T_Insert_Insert(pos2,pos2,pr2,pos1,pos1,pr1);
        sizea = Insert(a, sizea, pos21, val2);

        // op3    << op1    << op2
        // Delete << Insert << Insert
        sizeb = Insert(b, sizeb, pos2, val2);       
        // Insert1 << Insert2
        int pos12 = T_Insert_Insert(pos1,pos1,pr1,pos2,pos2,pr2);
        sizeb = Insert(b, sizeb, pos12, val1);

        assert sizea == sizeb;
        assert forall {int i in (0 : sizea); a[i] == b[i]};

        // C2:

        // Delete3 << Insert1
        int pos31 = T_Delete_Insert(pos3,pos1,pos1,pr1);
        // Delete3 << Insert2
        int pos321 = T_Delete_Insert(pos31,pos21,pos2,pr2);
        sizea = Delete(a, sizea, pos321);

        // Delete3 << Insert1
        int pos32 = T_Delete_Insert(pos3,pos2,pos2,pr2);
        // Delete32 << Insert12
        int pos312 = T_Delete_Insert(pos32,pos12,pos1,pr1);
        sizeb = Delete(b, sizeb, pos312);

        assert sizea == sizeb;
        return sizea;
    }

    // Delete__Insert_Delete (Delete after the sequence Delete o Insert)
    // Delete__Delete_Insert (Delete after the sequence Insert o Delete)
    static int Delete__Insert_Delete(int[]! a, int[]! b, int size, int pos3, int pos2, int val2, int pr2, int pos1) 
        requires a != b;
        requires forall {int i in (0 : size); a[i] == b[i]};
        requires a.Length == b.Length;      
        requires size < a.Length - 2;
        requires size >= 0;
        requires pos1 < size;
        requires pos2 <= size;
        requires pos3 < size;
        requires pos1 >= 0;
        requires pos2 >= 0;
        requires pos3 >= 0;    
        modifies a[*], b[*];
        ensures forall {int i in (0 : result); a[i] == b[i]};
    {
        int sizea = size, sizeb = size;

        // op3    << op2    << op1
        // Delete << Insert << Delete
        sizea = Delete(a, sizea, pos1);
        // Insert2 << Delete1
        int pos21 = T_Insert_Delete(pos2,pos2,pr2,pos1);
        sizea = Insert(a, sizea, pos21, val2);

        // op3    << op1    << op2
        // Delete << Delete << Insert
        sizeb = Insert(b, sizeb, pos2, val2);
        // Delete1 << Insert2
        int pos12 = T_Delete_Insert(pos1, pos2, pos2, pr2);
        sizeb = Delete(b, sizeb, pos12);        

        assert sizea == sizeb;
        assert forall {int i in (0 : sizea); a[i] == b[i]};

        // C2:

        // Delete3 << Delete1
        int pos31 = T_Delete_Delete(pos3,pos1);
        if(pos31 != -1) //not noOp
            {
                int pos321 = T_Delete_Insert(pos31, pos21, pos2, pr2);
                sizea = Delete(a, sizea, pos321);                
            }

        // Delete3 << Insert2
        int pos32 = T_Delete_Insert(pos3, pos2, pos2, pr2);
        // Delete3 << Delete1
        int pos312 = T_Delete_Delete(pos32,pos12);
        if (pos312 != -1) //not noOp
            sizeb = Delete(b, sizeb, pos312);                

        assert sizea == sizeb;
        return sizea;
    }

    // Insert__Insert_Delete (Delete after the sequence Delete o Insert)
    // Insert__Delete_Insert (Delete after the sequence Insert o Delete)
    static int Insert__Insert_Delete_C2(int[]! a, int[]! b, int size, int pos3, int val3, int pr3, int pos2, int val2, int pr2, int pos1) 
        requires a != b;
        requires forall {int i in (0 : size); a[i] == b[i]};
        requires a.Length == b.Length;      
        requires size < a.Length - 2;
        requires size >= 0;
        requires pos1 < size;
        requires pos2 <= size;
        requires pos3 < size;
        requires pos1 >= 0;
        requires pos2 >= 0;
        requires pos3 >= 0;
        requires pr3 != pr2;
        modifies a[*], b[*];
        ensures forall {int i in (0 : result); a[i] == b[i]};    
    {
        int sizea = size, sizeb = size;

        // C1:

        // op3    << op2    << op1
        // Insert << Insert << Delete
        sizea = Delete(a, sizea, pos1);
        // Insert2 << Delete1
        int pos21 = T_Insert_Delete(pos2, pos2, pr2, pos1);
        sizea = Insert(a, sizea, pos21, val2);

        // op3    << op1    << op2
        // Insert << Delete << Insert
        sizeb = Insert(b, sizeb, pos2, val2);
        // Delete1 << Insert2
        int pos12 = T_Delete_Insert(pos1, pos2, pos2, pr2);
        sizeb = Delete(b, sizeb, pos12);

        assert sizea == sizeb;
        assert forall {int i in (0 : sizea); a[i] == b[i]};

        // C2: 

        // Insert3 << Delete1
        int pos31 = T_Insert_Delete(pos3, pos3, pr3, pos1);
        // Insert3 << Insert2
        int pos321 = T_Insert_Insert(pos31,pos3,pr3,pos21,pos2,pr2);
        sizea = Insert(a, sizea, pos321, val3);                

        // Insert3 << Insert2
        int pos32 = pos3 > pos2 || (pos3 == pos2 && pr3 > pr2) ? pos3 + 1 : pos3;
        // Insert3 << Delete1
        int pos312 = T_Insert_Delete(pos32, pos3, pr3, pos12);
        sizeb = Insert(b, sizeb, pos312, val3);

        assert sizea == sizeb;
        return sizea;
    }

    // ------------------------------------------------------------------   
    //  Transforms
    // ------------------------------------------------------------------   

    [Inline]
    static int T_Insert_Insert(int pos1, int posp1, int pr1, int pos2, int posp2, int pr2)
    {
        int retval = pos1;
        if (pos1 > pos2 || 
            (pos1 == pos2 && 
             (posp1 > posp2 || 
              (posp1 == posp2 && pr1 > pr2))))
            retval = pos1 + 1;        
        return retval;        
    }

    [Inline]
    static int T_Insert_Delete(int pos1, int posp1, int pr1, int pos2)
    {
        int retval = pos1;
        if (pos1 > pos2)
            retval = pos1 - 1;
        return retval;
    }

    [Inline]
    static int T_Delete_Insert(int pos1, int pos2, int posp2, int pr2)    
    {
        int retval = pos1;
        if (pos1 >= pos2)
            retval = pos1 + 1;        
        return retval;
    }

    [Inline]
    static int T_Delete_Delete(int pos1, int pos2)
    {
        int retval = pos1;
        if (pos1 > pos2)
            retval = pos1 - 1;
        if(pos1 == pos2)
            retval = -1;
        return retval;
    }

    // ------------------------------------------------------------------   
    //  Operations
    // ------------------------------------------------------------------   

    // Insert
    static int Insert(int[]! a, int size, int pos, int val)
        requires size < a.Length;
        requires pos >= 0;
        requires pos <= size;
        modifies a[*];    
        ensures forall {int i in (0 : pos); a[i] == old(a[i])};
        ensures a[pos] == val;
        ensures forall {int i in (pos+1 : size+1); a[i] == old(a[i-1])};
        ensures result == size + 1;
    {
        int[]! copy = ArrayCopy(a);
        return InsertH(a, size, pos, val, copy);
    }

    [Inline]
    static int InsertH(int[]! a, int size, int pos, int val, int[]! aCp)
        requires a != aCp;
        modifies a[*], aCp.0;
    {
        for (int i = size; i > pos; i--) 
            invariant i <= size;
            invariant forall {int j in (i+1 : size+1); a[j] == aCp[j-1]};
            invariant forall {int j in (0 : pos); a[j] == aCp[j]};
        {
            a[i] = aCp[i-1];
        }
        a[pos] = val;
        return size + 1;
    }

    // Delete
    static int Delete(int[]! a, int size, int pos)
        requires size <= a.Length;
        requires pos >= 0;
        requires pos < size;
        modifies a[*];    
        ensures forall {int i in (0 : pos); a[i] == old(a[i])};
        ensures forall {int i in (pos : size-1); a[i] == old(a[i+1])};
        ensures result == size - 1;
    {
        int[]! copy = ArrayCopy(a);
        return DeleteH(a, size, pos, copy);
    }

    [Inline]
    static int DeleteH(int[]! a, int size, int pos, int[]! aCp)
        requires a != aCp;
        modifies a[*], aCp.0;
        ensures forall {int i in (0 : size); aCp[i] == old(aCp[i])};
        ensures forall {int i in (pos : size-1); a[i] == old(a[i+1])};
    {
        for (int i = size - 1; i > pos; i--) 
            invariant i <= size - 1;
            invariant forall {int j in (0 : pos); a[j] == aCp[j]};
            invariant forall {int j in (i+1 : size); a[j-1] == aCp[j]};
        {
            a[i-1] = aCp[i];
        }
        return size - 1;
    }

    static int[]! ArrayCopy(int[]! src)    	
        ensures result.Length == src.Length;
        ensures forall {int i in (0 : src.Length); result[i] == src[i]};
        ensures result != src;
    {
        int[] dest = new int[src.Length];
        for(int i = 0; i < src.Length; i++)
            invariant forall{int j in (0:i); dest[j] == src[j]};
        {
            dest[i] = src[i];
        }
        return dest;	
    }

    public static void Main(string[] args) { }

}
    
