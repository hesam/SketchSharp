using System;
using System.Collections;
using System.Compiler;
using System.Diagnostics;
using System.Text;
using System.Xml;
using System.IO;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.ComponentModel.Design.Serialization;
using System.Compiler.Metadata;

namespace Microsoft.Comega{

  public class SerializationProvider : ISerializationProvider{
    static Hashtable cache = new Hashtable();
    static Hashtable genCache = new Hashtable();
    ErrorNodeList errors;
    ErrorHandler errorHandler;
    CompilationUnit cunit;
    Module module;
    Hashtable serializers = new Hashtable();
    Hashtable schemaElementDeclCache = new Hashtable();
    Checker tempChecker;
    TypeSystem tempTypeSystem;

    static string DumpOption = null;

    private void Init(){
      ErrorNodeList tempErrors = new ErrorNodeList();
      ErrorHandler tempErrorHandler = new ErrorHandler(tempErrors);
      tempTypeSystem = new TypeSystem(tempErrorHandler);
      // Here we ignore the errors generated by this temporary checker on purpose!
      tempChecker = new Checker(tempErrorHandler, tempTypeSystem, null, null, null);
      if (errorHandler == null) {
        errors = new ErrorNodeList();
        errorHandler = new ErrorHandler(errors);
      }
    }

    public SerializationProvider() {
      Init();
    }

    internal SerializationProvider(CompilationUnit cunit) {
      this.cunit = cunit;
      this.module = cunit.TargetModule;
      Init();
    }
    internal SerializationProvider(Module module) {
      this.module = module;
      Init();
    }
    internal Module Module {
      get { return this.module; }
    }

    internal TypeNode GetTypeNodeFor(AssemblyNode assembly, Type t) {
      if (t.IsArray) {
        int rank = t.GetArrayRank();
        Type et = t.GetElementType();
        TypeNode type = assembly.GetType(Identifier.For(et.Namespace), Identifier.For(et.Name));
        return type.GetArrayType(rank);
      } else {        
        return assembly.GetType(Identifier.For(t.Namespace), Identifier.For(t.Name));
      }    
    }

    public Type GetSerializer(XmlSerializer caller, Type t, ref string rootName, ref string rootNamespace) {
      // start again with clean error list - do NOT return errors from the temporary checker.
      errors = new ErrorNodeList();
      errorHandler = new ErrorHandler(errors);

      TypeNode type = TypeNode.GetTypeNode(t);

      string nspace = GetSerializerNamespace(type);
      string serializerClassName = GetSerializerName(type);
      string fullName = nspace + ((nspace != "" && nspace != null) ? "." : "") + serializerClassName;

      // Structural types have no container element name.
      if (!IsStructuralType(type) && !(type is EnumNode)) {
        if (rootName == null) {
          Identifier name = Checker.GetDefaultElementName(type);
          rootName = name.Name;
          if (rootNamespace == null && name.Prefix != null) {
            rootNamespace = name.Prefix.Name;
          }
        }
      }
     
      if (caller.GetType().FullName == fullName)
        return caller.GetType();


      AssemblyNode assembly = AssemblyNode.GetAssembly(t.Assembly, cache, false, true);

      // see if we can find a serializer in the same assembly as the given type.
      TypeNode serializerType = assembly.GetType(Identifier.For(nspace), Identifier.For(serializerClassName));
      if (serializerType != null) {
        Type result = serializerType.GetRuntimeType();
        Debug.Assert(result != null, "GetRuntimeType() failed on " + serializerType.FullName);
        return result;
      }

      System.Reflection.Assembly sasm = (System.Reflection.Assembly)genCache[t];
      if (sasm == null) {
        ComegaCompilerOptions options = new ComegaCompilerOptions();
        options.OutputAssembly = type.Name +  "Serializer.dll";
        options.GenerateExecutable = false;
        options.ModuleKind = ModuleKindFlags.DynamicallyLinkedLibrary;
        if (DumpOption == null) {
          DumpOption = System.Environment.GetEnvironmentVariable("DEBUG_SERIALIZER");
          if (DumpOption == null) DumpOption = "";
        }
        options.GenerateInMemory = (DumpOption == "");
        options.DumpTree = (DumpOption != "");
        options.IncludeDebugInformation = (DumpOption != "");
        options.TempFiles = new TempFileCollection(Directory.GetCurrentDirectory(), true);
        string writerAssembly = typeof(XmlSerializationWriter).Assembly.Location;
        options.ReferencedAssemblies.Add(writerAssembly);
        string xmlAssembly = typeof(XmlTextReader).Assembly.Location;
        options.ReferencedAssemblies.Add(xmlAssembly);

        Compiler compiler = new Compiler();
        Module module = compiler.CreateModule(options, errors);
        CompilationUnit cu = CreateCompilationUnit(module, type);
        // so we can find all the structural types already defined in the assembly 
        // associated with the type we are building the serializer for.
        cu.TargetModule.AssemblyReferences.Add(new AssemblyReference(assembly));

        CompilerResults results = compiler.CompileAssemblyFromIR(options, cu, errors);

        if (errors.Length > 0) {
          throw new XmlSerializerException(errors[0].GetMessage());
        } else if (results.Errors.Count>0) {
          throw new XmlSerializerException(results.Errors[0].ErrorText);
        } else {
          sasm = results.CompiledAssembly;
          if (sasm == null) 
            throw new XmlSerializerException(RuntimeError.SerializationAssembly);
          genCache[t] = sasm;
        }
      }

      Type instanceType = sasm.GetType(fullName, false, false);
      if (instanceType == null) 
        throw new XmlSerializerException(RuntimeError.SerializationClass, fullName);

      return instanceType;

    }
    
    CompilationUnit CreateCompilationUnit(Module module, TypeNode type) {
      
      CompilationUnit cu = new CompilationUnit();
      cu.Namespaces = new NamespaceList();      
      cu.TargetModule = module;
      this.cunit = cu;
      this.module = module;

      Namespace ns = new Namespace(Identifier.Empty, Identifier.Empty, new AliasDefinitionList(), new UsedNamespaceList(), new NamespaceList(), new TypeNodeList());
      cu.Namespaces.Add(ns);      

      ns.UsedNamespaces.Add(new UsedNamespace(Identifier.For("System")));
      ns.UsedNamespaces.Add(new UsedNamespace(Identifier.For("System.Xml")));
      ns.UsedNamespaces.Add(new UsedNamespace(Identifier.For("Microsoft.Comega"))); // XmlSerializationWriter

      CreateSerializerFor(type);
      return cu;
    }
    
    bool IsStructuralType(TypeNode type) {
      return (type is TupleType ||
        type is TypeUnion || //???
        IsStream(type));
    }

    bool IsStream(TypeNode type) {
      if (type == null) return false;
      return Checker.IsList(type) || type.Template == SystemTypes.GenericBoxed;
    }

    internal bool HasSerializerFor(TypeNode type) {
      Class c = (Class)serializers[type];
      return (c != null);
    }

    internal Class CreateSerializerFor(TypeNode type, ErrorHandler errorHandler) {
      this.errorHandler = errorHandler;
      this.errors = errorHandler.Errors;
      return CreateSerializerFor(type);
    }

    internal string GetSerializerName(TypeNode type) {
      string typeName = type.Name == null ? null : type.Name.Name;
      if (typeName == null) {
        if (type is ArrayType) {
          TypeNode ceType = Checker.GetCollectionElementType(type);
          typeName = "ArrayOf"+ceType.Name.Name;
        }
      }
      return typeName + "Serializer";
    }

    internal string GetSerializerNamespace(TypeNode type) {
      string ns = type.Namespace == null ? null : type.Namespace.Name;
      if (ns == null) {
        if (type is ArrayType) {
          TypeNode ceType = Checker.GetCollectionElementType(type);
          ns = ceType.Namespace.Name;
        }
      }
      return ns;
    }

    internal Class CreateSerializerFor(TypeNode type) {
      // todo: look in the genCache for other serializer assemblies that may have already
      // created the serializer for this type and make an assembly reference to that 
      // serializer instead of creating a complete duplicate.
      TypeNode saved = tempChecker.currentType;

      Class c = (Class)serializers[type];
      if (c != null) return c;
      c = new Class();      
      c.Flags = TypeFlags.Class | TypeFlags.BeforeFieldInit;
      // copy the accessibility of the type we are serializing.
      c.Flags |= (type.Flags & (TypeFlags.Public | TypeFlags.NestedAssembly));
      c.Name = Identifier.For(GetSerializerName(type));
      c.Namespace = Identifier.For(GetSerializerNamespace(type));
      c.DeclaringModule = this.module;
      c.Members = new MemberList();
      c.Attributes = new AttributeList();
      c.BaseClass = Runtime.XmlSerializer;
      tempChecker.currentType = c;

      InstanceInitializer ii = Runtime.XmlSerializerAttribute.GetConstructor();
      MemberBinding mb = new MemberBinding(null, ii);
      mb.Type = Runtime.XmlSerializerAttribute;
      c.Attributes.Add(new AttributeNode(mb, null));
      if (cunit != null) {
        cunit.Namespaces[0].Types.Add(c);
      }
      this.module.Types.Add(c);

      Identifier typeId = Identifier.For("type"); // what we are writing to.
      Identifier rootName = Identifier.For("rootName"); // what we are writing to.
      Identifier rootNamespace = Identifier.For("rootNamespace"); // what we are writing to.

      // Constructor
      Method constructor = new InstanceInitializer();
      constructor.Name = StandardIds.Ctor;
      constructor.DeclaringType = c;
      constructor.Flags = MethodFlags.Public|MethodFlags.HideBySig|MethodFlags.SpecialName|MethodFlags.RTSpecialName;
      constructor.Parameters = new ParameterList();
      constructor.Parameters.Add(new Parameter(new AttributeList(), ParameterFlags.In, typeId, SystemTypes.Type, null, null));
      constructor.Parameters.Add(new Parameter(new AttributeList(), ParameterFlags.In, rootName, SystemTypes.String, null, null));
      constructor.Parameters.Add(new Parameter(new AttributeList(), ParameterFlags.In, rootNamespace, SystemTypes.String, null, null));
      constructor.ReturnType = SystemTypes.Void;
      c.Members.Add(constructor);

      // pass args thru to base XmlSerializer constructor.
      Block b = constructor.Body = new Block(new StatementList());
      b.Statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(new Base(), StandardIds.Ctor), 
        new ExpressionList(typeId, rootName, rootNamespace), NodeType.Call)));      
      //AddConsoleWrite(b.Statements, new Literal("Hello!!",SystemTypes.String));

      // Serialize(T source, XmlSerializationWriter writer) method
      Identifier src = Identifier.For("source"); // object being serialized.
      Identifier writer = Identifier.For("writer"); // what we are writing to.

      Method serialize = new Method();
      serialize.Name = Identifier.For("Serialize");        
      serialize.DeclaringType = c;
      serialize.Flags = MethodFlags.Public|MethodFlags.Static|MethodFlags.HideBySig;
      serialize.Parameters = new ParameterList();
      serialize.Parameters.Add(new Parameter(new AttributeList(), ParameterFlags.In, src, type, null, null));
      serialize.Parameters.Add(new Parameter(new AttributeList(), ParameterFlags.In, writer, Runtime.XmlSerializationWriter, null, null));
      serialize.Parameters.Add(new Parameter(new AttributeList(), ParameterFlags.In, rootName, SystemTypes.String, null, null));
      serialize.Parameters.Add(new Parameter(new AttributeList(), ParameterFlags.In, rootNamespace, SystemTypes.String, null, null));
      serialize.ReturnType = SystemTypes.Void;
      c.Members.Add(serialize);

      // T Deserialize(XmlReader reader, bool required, out bool result) method
      Identifier reader = Identifier.For("reader"); // what we are reading from.
      Identifier required = Identifier.For("required"); // whether an object is required or not.
      Identifier result = Identifier.For("result"); // whether we found anything.

      Method deserialize = new Method();
      deserialize.Name = Identifier.For("Deserialize");        
      deserialize.DeclaringType = c;
      deserialize.Flags = MethodFlags.Public|MethodFlags.Static|MethodFlags.HideBySig;
      deserialize.Parameters = new ParameterList();
      deserialize.Parameters.Add(new Parameter(new AttributeList(), ParameterFlags.In, reader, Runtime.XmlSerializationReader, null, null));
      deserialize.Parameters.Add(new Parameter(new AttributeList(), ParameterFlags.In, required, SystemTypes.Boolean, null, null));
      deserialize.Parameters.Add(new Parameter(new AttributeList(), ParameterFlags.Out, result, SystemTypes.Boolean.GetReferenceType(), null, null));
      deserialize.ReturnType = type;
      c.Members.Add(deserialize);

      // It is important that we add the serializer to the cache AFTER we create the methods, but 
      // BEFORE we create the method bodies so that we can handle recurrsive calls to AddCallSerializer which
      // happens in recurrsive structures like "class Foo { public Foo f; }".  Otherwise we'd get stuck in an
      // infinite loop.
      serializers[type] = c;

      // Body of serialize method.
      b = serialize.Body = new Block(new StatementList());
      StatementList statements = b.Statements;
      
      if (!AddWriteSimpleType(type, statements, c, writer, src, rootName, rootNamespace)) {
        MethodCall call = new MethodCall();
        call.Callee = new QualifiedIdentifier(writer,Identifier.For("WriteStartElement"));
        call.Operands = new ExpressionList();
        call.Operands.Add(rootName);
        call.Operands.Add(rootNamespace);
        statements.Add(new If(new BinaryExpression(rootName,Literal.Null,NodeType.Ne),
          new Block(new StatementList(new ExpressionStatement(call))),null));

        Expression source = src;

        if (type.Template == SystemTypes.GenericBoxed) {
          statements = AddCheckForNull(statements, Duplicate(src, c), type);
          type = Checker.GetCollectionElementType(type); 
          source = CastTo(src, type);//unbox it
        }

        if (type is TupleType) {
          AddWriteTuple(type as TupleType, statements, c, source, writer);
        } else if (type is TypeUnion) {
          AddWriteChoice(type as TypeUnion, statements, c, source, writer);
        } else if (IsStream(type)) {
          AddWriteStream(type, statements, c, source, writer);
        } else {
          SchemaElementDecl sd = SchemaElementDecl.Compile(this.module, type, Checker.GetCollectionElementType(type), this.errorHandler, schemaElementDeclCache);
          SchemaValidator validator = validator = sd.CreateValidator(this.errorHandler);      
          statements = AddCheckForNull(statements, Duplicate(src, c), type);
          AddWriteAttributes(statements, c, writer, source, validator);
          AddWriteContent(type, statements, c, writer, source, validator);        
        }
        call = new MethodCall();
        call.Callee = new QualifiedIdentifier(writer,Identifier.For("WriteEndElement"));
        call.Operands = new ExpressionList();
        statements.Add(new If(new BinaryExpression(rootName,Literal.Null,NodeType.Ne),
          new Block(new StatementList(new ExpressionStatement(call))),null));
      }
      // body of deserialize method.
      b = deserialize.Body = new Block(new StatementList());
      statements = b.Statements;

      Local target = new Local(Identifier.Empty, type);

      if (type.Template == SystemTypes.GenericBoxed){
        type = Checker.GetCollectionElementType(type);
      }

      if (type is TupleType) {
        AddReadTuple(b, type as TupleType, statements, reader, target, required, result);
      } else if (type is TypeUnion) {
        AddReadChoice(b, type as TypeUnion, statements, reader, target, required, result);
      } else if (IsStream(type)) {
        AddReadStream(b, type, statements, reader, target, result);
      } else {
        if (type is TypeAlias) {
          type = ((TypeAlias)type).AliasedType;
        }

        // Then we are already positioned on the element to be deserialized. 
        statements.Add(new AssignmentStatement(required, Literal.True));
        if (!AddReadSimpleType(type, statements, reader, target, result, false)) {
          if (!type.IsValueType && !type.IsAbstract && type.GetConstructor() != null) {
            Construct cons = new Construct(new MemberBinding(null, type), new ExpressionList(), type);
            statements.Add(new AssignmentStatement(target, cons));
          }
          SchemaElementDecl sd = SchemaElementDecl.Compile(this.module, type, Checker.GetCollectionElementType(type), this.errorHandler, schemaElementDeclCache);
          SchemaValidator validator = validator = sd.CreateValidator(this.errorHandler);      
          AddReadAttributes(type, statements, reader, target, validator);
          AddReadContent(c, b, type, statements, reader, target, required, result, validator);
        }
      }
      statements.Add(new Return(target));
      tempChecker.currentType = saved;
      return c;
    }

    Expression GetConvertToString(TypeNode srcType, Expression src, bool always) {

      TypeNode type = Unwrap(srcType);

      if (type is EnumNode) {
        Method method = SystemTypes.Enum.GetMethod(Identifier.For("ToString"));
        return new MethodCall(new MemberBinding(src, method), 
          new ExpressionList(), NodeType.Callvirt, SystemTypes.String);
      } 
      
      // See if it has a type converter.
      Class converterClass = Checker.GetTypeConverter(type);
      if (converterClass != null) {
        TypeConverter converter = TypeDescriptor.GetConverter(type.GetRuntimeType());
        if (converter != null) {
          Type converterType = converter.GetType();
          AssemblyNode converterAssembly = AssemblyNode.GetAssembly(converterType.Assembly, cache, false, true);
          converterClass = converterAssembly.GetType(Identifier.For(converterType.Namespace), Identifier.For(converterType.Name)) as Class;
          Expression e = tempChecker.GetConverterToString(converter, converterClass, type, src);
          if (e != null) {
            //Do I need to add namespace and assembly reference for type converter?
            return e;
          }
        }   
      }
      if (always) {        
        if (this.tempTypeSystem.ImplicitCoercionFromTo(src, src.Type, SystemTypes.String)) {
          return CastTo(src, SystemTypes.String);
        } else {
          Method method = type.GetMethod(Identifier.For("ToString"));
          if (method != null) {
            MethodCall call = new MethodCall(new MemberBinding(src, method), 
              new ExpressionList(), NodeType.Call, SystemTypes.String);
            if (!src.Type.IsValueType) call.NodeType = NodeType.Callvirt;
            return call;
          }
        }
      }
      return null;
    }

    Expression GetConvertFromString(TypeNode targetType, Expression src, bool always) {
      if (targetType == SystemTypes.String) 
        return src;// nothing to do!

      if (targetType is EnumNode) {
        // e.g. return (DayOfWeek)Enum.Parse(typeof(DayOfWeek),"Sunday");
        Method method = SystemTypes.Enum.GetMethod(Identifier.For("Parse"), new TypeNode[2]{ SystemTypes.Type, SystemTypes.String});
        UnaryExpression typeOfEnum = new UnaryExpression(new MemberBinding(null, targetType), NodeType.Typeof);
        MethodCall call = new MethodCall(new MemberBinding(new MemberBinding(null, targetType), method), 
          new ExpressionList(new Expression[2]{typeOfEnum, src }), NodeType.Call, SystemTypes.Object);
        return CastTo(call, targetType);
      }
      // See if it has a type converter.
      Class converterClass = Checker.GetTypeConverter(targetType);
      if (converterClass != null) {
        TypeConverter converter = TypeDescriptor.GetConverter(targetType.GetRuntimeType());
        if (converter != null) {
          Type converterType = converter.GetType();
          AssemblyNode converterAssembly = AssemblyNode.GetAssembly(converterType.Assembly, cache, false, true);
          converterClass = converterAssembly.GetType(Identifier.For(converterType.Namespace), Identifier.For(converterType.Name)) as Class;          
          Expression e = tempChecker.GetConverterFromString(converter, converterClass, SystemTypes.String, src, SystemTypes.Object);
          if (e != null) {
            //Do I need to add namespace and assembly reference for type converter?
            return CastTo(e, targetType);
          }
        }   
      }
      if (always) {
        // e.g. return PointArray.Parse("10,20 30,40 50,60");
        Method method = targetType.GetImplicitCoercionFromMethod(SystemTypes.String);
        if (method == null) {
          method = targetType.GetMethod(Identifier.For("Parse"), new TypeNode[1]{ SystemTypes.String});
        }
        if (method != null) {
          MemberBinding typeBinding  = new MemberBinding(null, targetType);
          MethodCall call = new MethodCall(new MemberBinding(typeBinding, method), 
            new ExpressionList(new Expression[1]{ src }), NodeType.Call, targetType );
          return call;
        }
      }
      return null;
    }

    Expression Duplicate(Expression e, TypeNode referringType) {
      Duplicator dup = new Duplicator(this.module, referringType);
      return dup.VisitExpression(e);
    }

    StatementList AddCheckForNull(StatementList statements, Expression src, TypeNode type) {
      if (type.Template == SystemTypes.GenericBoxed) {
        If checknull = new If(new BinaryExpression(
          new MethodCall(new MemberBinding(src, type.GetMethod(Identifier.For("IsNull"),null)), new ExpressionList()),
          Literal.True, NodeType.Ne), 
          new Block(new StatementList()), null);
        statements.Add(checknull);
        return checknull.TrueBlock.Statements;        
      }
      else if (type is TypeAlias) {
        // cast to underlying type and check that for null.
        TypeNode atype = ((TypeAlias)type).AliasedType;
        return AddCheckForNull(statements, CastTo(src, atype), atype); 
      }
      else if (type is ConstrainedType) {
        // cast to underlying type and check that for null.
        TypeNode atype = ((ConstrainedType)type).UnderlyingType;
        return AddCheckForNull(statements, CastTo(src, atype), atype); 
      }
      else if (!IsStream(type) && !type.IsValueType) { //stream types are doing weird things to the null check?
        if (type == SystemTypes.String || IsStream(type))
          src = CastTo(src, SystemTypes.Object);
        If checknull = new If(new BinaryExpression(src, Literal.Null, NodeType.Ne), 
          new Block(new StatementList()), null);
        statements.Add(checknull);
        return checknull.TrueBlock.Statements;        
      }
      return statements;
    }

    void AddWriteAttributes(StatementList statements, TypeNode referringType, Identifier writer, Expression source, SchemaValidator validator) {
      if (validator.Attributes != null) {
        foreach (SchemaAttDef ad in validator.Attributes) {
          Identifier name = ad.Name;
          Expression src = GetMemberBinding(source, ad.Member);
          if (src.Type == null) continue; // type resolution error.
          if (!AddWriteSimpleAttribute(src.Type, name, statements, referringType, writer, src)) {
            // throw exception, attribute has complex type!
          }
        }
      }
    }

    MemberBinding GetMemberBinding(Expression source, Member m) {
      MemberBinding src = new MemberBinding(source, m);
      src.Type = Checker.GetMemberType(m);
      return src;
    }

    MemberBinding GetMemberBinding(Expression source, Member m, TypeNode t) {
      MemberBinding src = new MemberBinding(source, m);
      src.Type = t;
      return src;
    }

    void AddWriteContent(TypeNode type, StatementList statements, TypeNode referringType, Identifier writer, Expression source, SchemaValidator validator) {
      if (validator.validator is AllElementsContentValidator) {
        ValidationState context = new ValidationState();
        context.ErrorHandler = this.errorHandler;
        validator.validator.InitValidation(context);
        ArrayList members = validator.validator.ExpectedElements(context, false, false);
        foreach (NamedNode childNode in members) {
          if (childNode.TypeNode == null) continue; // type resolution error.
          Expression src = GetMemberBinding(source, childNode.Member, childNode.TypeNode);
          AddWriteElement(statements, referringType, writer, childNode.Name, src, childNode.TypeNode, false);
        }
      } else {
        // Note: there is a SequenceNode wrapper we need to remove and throw away.
        SequenceNode seq = validator.RootNode as SequenceNode;
        if (seq != null) {
          // if seq is null then it's ContentType.Empty or Mixed and mixed is handled at the end.
          ContentNode n = seq.LeftChild;
          AddWriteContentNode(n, statements, referringType, writer, source);
        }
      }
      Member mixed = validator.validator.MixedMember;
      if (mixed != null) {
        MemberBinding mb = GetMemberBinding(source, mixed);
        if (mb.Type != null)
          AddWriteString(statements, referringType, writer, mb);
      }
    }

    void AddWriteContentNode(ContentNode n, StatementList statements, TypeNode referringType, Identifier writer, Expression source) {
      if (n.TypeNode == null) {
        Debug.Assert(n is SequenceNode);
        // In the class inheritance case we have two independent left and right children inside
        // a parent sequence that has no unified type or member.
        SequenceNode s = (SequenceNode)n;
        AddWriteContentNode(s.LeftChild, statements, referringType, writer, source);
        AddWriteContentNode(s.RightChild, statements, referringType, writer, source);
        return;
      }
      TypeNode ct = n.TypeNode;
      Expression src = source;
      if (n.Member != null && !(n.Member is Method))  {
        src = GetMemberBinding(source, n.Member, ct);
      }
      if (ct.Template == SystemTypes.GenericBoxed) {
        statements = AddCheckForNull(statements, Duplicate(src, referringType), ct);
        ct = Checker.GetCollectionElementType(ct);  
        src = CastTo(src, ct);//unbox it
      }
      if (ct is TupleType) {
        AddWriteTuple(ct as TupleType, statements, referringType, src, writer);
      } else if (ct is TypeUnion) {
        AddWriteChoice(ct as TypeUnion, statements, referringType, src, writer);
      } else if (IsStream(ct)) {
        AddWriteStream(ct, statements, referringType, src, writer);
      } else if (ct is TypeAlias) {
        TypeAlias alias = (TypeAlias)ct;
        src = CastTo(src, alias.AliasedType); //unbox it
        AddWriteElement(statements, referringType, writer, alias.Name, src, alias.AliasedType, true);
      } else {
        AddWriteElement(statements, referringType, writer, ct.Name, src, ct, true);
      }        
    }

    void AddWriteElement(StatementList statements, TypeNode referringType, Identifier writer, Identifier name, Expression src, TypeNode mt, bool emptyElementOnNull) {

      if (mt.Template == SystemTypes.GenericBoxed) {
        statements = AddCheckForNull(statements, Duplicate(src, referringType), mt);     
        mt = Checker.GetCollectionElementType(mt); // check for null and unbox 
        src = CastTo(src, mt); //unbox it
      }

      Literal nameLit = new Literal(name.ToString(), SystemTypes.String);
      Literal nsLit = (name.Prefix != null) ? new Literal(name.Prefix.Name, SystemTypes.String) : Literal.Null;

      if (!emptyElementOnNull) {
        statements = AddCheckForNull(statements, Duplicate(src, referringType), mt);         
      }
      if (!AddWriteSimpleType(mt, statements, referringType, writer, src, nameLit, nsLit)) {
        AddCallSerializer(mt, statements, src, writer, nameLit, nsLit);
      }

    }

    void AddWriteString(StatementList statements, TypeNode referringType, Identifier writer, Expression src) {
      statements = AddCheckForNull(statements, Duplicate(src, referringType), SystemTypes.String);
      statements.Add( new ExpressionStatement(
        new MethodCall(new QualifiedIdentifier(writer,Identifier.For("WriteString")),
        new ExpressionList(src))));
    }

    void AddCallSerializer(TypeNode srcType, StatementList statements, Expression src, Identifier writer, Expression rootName, Expression rootNamespace ) {

      TypeNode type = Unwrap(srcType);

      Class memberSerializer = this.CreateSerializerFor(type);
      // call the Serialize method on it, passing the member we're serializing.
      ExpressionList args = new ExpressionList();
      args.Add(src);
      args.Add(writer);
      args.Add(rootName);
      args.Add(rootNamespace);
      MethodCall call = new MethodCall();
      Method serialize = memberSerializer.GetMethod(Identifier.For("Serialize"), new TypeNode[4] { type, Runtime.XmlSerializationWriter, SystemTypes.String, SystemTypes.String} );
      call.Callee = new MemberBinding(new MemberBinding(null, memberSerializer), serialize);
      call.Operands = args;
      statements.Add( new ExpressionStatement( call ) );    
    }

    void AddWriteMember(Member child, Identifier name, StatementList statements, TypeNode referringType, Expression src, Identifier writer, bool emptyElementOnNull) {

      src = GetMemberBinding(src, child);
      TypeNode type = src.Type;
      if (type == null) return;

      if (type.Template == SystemTypes.GenericBoxed) {
        statements = AddCheckForNull(statements, Duplicate(src, referringType), type);
        type = Checker.GetCollectionElementType(type);  
        src = CastTo(src, type);//unbox it
      }

      if (child.IsAnonymous) {
        if (type is TypeAlias) {
          TypeAlias alias = (TypeAlias)type;
          src = CastTo(src, alias.AliasedType); //unbox it
          AddWriteElement(statements, referringType, writer, alias.Name, src, alias.AliasedType, emptyElementOnNull);
        } else if (!AddWriteSimpleType(type, statements, referringType, writer, src, Literal.Null, Literal.Null)) {
          if (type is TupleType || type is TypeUnion || IsStream(type)) {
            AddCallSerializer(type, statements, src, writer, Literal.Null, Literal.Null);
          } else {
            AddWriteElement(statements, referringType, writer, type.Name, src, type, emptyElementOnNull);
          }
        }
          
      } else if (type is TypeAlias) {
        TypeAlias alias = (TypeAlias)type;
        src = CastTo(src, alias.AliasedType); //unbox it
        AddWriteElement(statements, referringType, writer, name, src, alias.AliasedType, emptyElementOnNull);
      } else {
        AddWriteElement(statements, referringType, writer, name, src, type, emptyElementOnNull);
      }
    }

    void AddWriteTuple(TupleType tuple, StatementList statements, TypeNode referringType, Expression src, Identifier writer) {
      TypeNode singleton = UnwrapSingletonTuple(tuple, true);
      if (singleton != null && singleton == SystemTypes.String) {
        // special case which looks like mixed content.
        // happens a lot when XML Schema contains SimpleTypes that extend xsd:string.
        AddWriteSimpleType(singleton, statements, referringType, writer, src, null, null);
      } else {
        for (int i = 0, n = tuple.Members.Length; i < n; i++) {
          Member child = tuple.Members[i];          
          if (child is Field) {
            Field f = (Field)child;
            if (f.Type == null) continue; // type resolution error.
            // bugbug - what about [XmlElement] custom attributes?
            AddWriteMember(f, f.Name, statements, referringType, src, writer, true);
          }
        }
      }
    }

    TypeNode UnwrapSingletonTuple(TypeNode type, bool mustBeAnonymous) {
      if (type is TupleType) {
        TupleType tt = (TupleType)type;
        Field f = null;
        for (int j = 0, m = tt.Members.Length; j < m; j++) {
          Member tm = tt.Members[j];
          if (tm is Field) {
            if (f != null) {
              f = null; 
              break; // more than one field.
            } else {
              f = (Field)tm;
            }
          }
        }
        if (f != null && (!mustBeAnonymous || (f.IsAnonymous && !(f.Type is TypeAlias)))) {
          return f.Type;
        }
      }
      return null;
    }

    void AddWriteChoice(TypeUnion tu, StatementList statements, TypeNode referringType, Expression src, Identifier writer) {
      // generate the following code:
      //    Type srcType = src.GetType();
      //    if (choiceType.IsAssignableFrom(srcType)){ 
      //      XxxxSerializer s = new XxxxSerializer();
      //      s.Serialize((runtimeType)src, writer);
      //    } else if (...) {
      //      // and so on.
      //    }
      // What we cannot do here is by creating nested XmlSerializers
      // based on runtime type because this could cause infinite recurrsion.
      // So we cannot serialize a type union where one of the choices is "object".

      TypeNodeList choices = tu.Types;

      MethodCall call = new MethodCall();
      call.Callee = new QualifiedIdentifier(src, Identifier.For("GetType"));
      call.Operands = new ExpressionList();

      Local local = new Local(SystemTypes.Type);
      statements.Add(new AssignmentStatement(local, call));

      for (int i = 0, n = choices.Length; i < n; i++) {
        TypeNode choiceType = choices[i];
        if (choiceType == null) continue; // type resolution error.

        // if (choiceType.IsAssignableFrom(srcType)){ 
        BinaryExpression condition = new BinaryExpression(
          new MethodCall(
            new QualifiedIdentifier(new UnaryExpression(new MemberBinding(null, choiceType), NodeType.Typeof), Identifier.For("IsAssignableFrom")),
            new ExpressionList(new Expression[] { local })),
          Literal.True,
          NodeType.Eq);

        Block block = new Block();
        block.Statements = new StatementList();
        BinaryExpression cast = CastTo(src, choiceType);

        Expression name = null, ns = null;
        GetNameAndNamespace(choiceType, out name, out ns);
        Expression simplename = name, simplens = ns;

        // Check for choice of type: [string] and match this with XmlTextNode.
        TypeNode unwrapped = UnwrapSingletonTuple(choiceType, true);
        if (unwrapped == null) unwrapped = choiceType;
        if (unwrapped != null && unwrapped.IsPrimitive) {
          simplename = simplens = null;
          choiceType = unwrapped;
        }

        if (!AddWriteSimpleType(choiceType, block.Statements, referringType, writer, cast, simplename, simplens)) {
          AddCallSerializer(choiceType, block.Statements, cast, writer, name, ns);
        }
        If ifStatement = new If(condition, block, null);
        statements.Add(ifStatement);
      } 
    }

    void AddWriteStream(TypeNode type, StatementList statements, TypeNode referringType, Expression src, Identifier writer) {
      // Generate the following code:
      // XxxxSerializer s = new XxxxSerializer();
      // foreach (Xxxx x in src) {
      //    s.Serialize(x,writer);
      // }
      // Where Xxxx is the element type for the given stream type.

      if (type.Template == SystemTypes.GenericNonEmptyIEnumerable) {
        type = Checker.GetIEnumerableTypeFromNonEmptyIEnumerableStruct(this.module, type);
      } else {
        statements = AddCheckForNull(statements, Duplicate(src, referringType), type);
      }
      TypeNode ceType = Checker.GetCollectionElementType(type);  
      //todo: should check that type has an IEnumerator.

      Identifier loopVariable = Identifier.For("e");
      loopVariable.Type = ceType;
      Block body = new Block();
      body.Statements = new StatementList();

      Expression name, ns;
      GetNameAndNamespace(ceType, out name, out ns);

      // call the Serialize method on it, passing the member we're serializing.  
      if (!AddWriteSimpleType(ceType, body.Statements, referringType, writer, loopVariable, name, ns)) {
        AddCallSerializer(ceType, body.Statements, loopVariable, writer, name, ns);
      }

      ForEach fe = new ForEach(ceType, loopVariable, src, body);      
      statements.Add(fe);
    }

    void GetNameAndNamespace(TypeNode type, out Expression name, out Expression ns) {
      name = Literal.Null;
      ns = Literal.Null;
      if (!IsStructuralType(type)) {
        Identifier id = Checker.GetDefaultElementName(type);
        name = new Literal(id.Name, SystemTypes.String);
        if (id.Prefix != null) {
          ns = new Literal(id.Prefix.Name, SystemTypes.String);
        }
      }
    }

    //================= reader methods ==========================================    
    void AddReadAttributes(TypeNode type, StatementList statements, Identifier reader, Expression target, SchemaValidator validator) {

      if (validator.Attributes != null) {
        Block whileBody = new Block(new StatementList());
        Literal trueLit = Literal.True;
        MethodCall movenext = new MethodCall(new QualifiedIdentifier(reader, Identifier.For("MoveToNextAttribute")), new ExpressionList());
        BinaryExpression condition = new BinaryExpression(movenext, trueLit, NodeType.Eq);
        While w = new While(condition, whileBody);
        statements.Add(w);
        Block lastElseBlock = null;

        Local nameLocal = new Local(SystemTypes.String);
        whileBody.Statements.Add(new AssignmentStatement(nameLocal, new QualifiedIdentifier(reader, Identifier.For("LocalName"))));
        Local nsLocal = new Local(SystemTypes.String);
        whileBody.Statements.Add(new AssignmentStatement(nsLocal, new QualifiedIdentifier(reader, Identifier.For("NamespaceURI"))));

        foreach (SchemaAttDef ad in validator.Attributes) {
          // todo: any way to do tokenized compares?
          BinaryExpression nameEqual = new BinaryExpression(nameLocal,
            new Literal(ad.Name.Name, SystemTypes.String), NodeType.Eq);
          BinaryExpression nsEqual = new BinaryExpression(nsLocal,
            new Literal(ad.Name.Prefix != null ? ad.Name.Prefix.Name : "", SystemTypes.String), NodeType.Eq);
          Block elseBlock = new Block(new StatementList());
          If ifExpr = new If(new BinaryExpression(nameEqual, nsEqual, NodeType.And), new Block(new StatementList()), elseBlock);
          if (lastElseBlock != null) {
            lastElseBlock.Statements.Add(ifExpr);
          } else {
            whileBody.Statements.Add(ifExpr);
          }
          lastElseBlock = elseBlock;

          // body of if test, parse the attribute value as the specified type.
          Debug.Assert(ad.Member is Field || ad.Member is Property);
          AddReadSimpleType(Checker.GetMemberType(ad.Member), ifExpr.TrueBlock.Statements, reader, GetMemberBinding(target, ad.Member), null, true);
        }
        //todo: report unknown attributes?
      }
    }

    void AddReadContent(Class serializer, Block block, TypeNode type, StatementList statements, Identifier reader, 
      Expression target, Expression required, Expression result, SchemaValidator validator) {
    
      // position us in the content.
      statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(reader, Identifier.For("MoveToContent")), new ExpressionList())));
      Local elementName = new Local(Identifier.Empty,SystemTypes.String);
      statements.Add(new AssignmentStatement(elementName, new QualifiedIdentifier(reader, Identifier.For("LocalName"))));
      
      // make sure the element is not empty.
      If isEmpty = AddEmptyElementCheck(statements, reader);

      // Read the contents.
      statements = isEmpty.FalseBlock.Statements;
      statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(reader, Identifier.For("Read")), new ExpressionList())));
      statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(reader, Identifier.For("MoveToContent")), new ExpressionList())));

      ValidationState context = new ValidationState();
      context.ErrorHandler = this.errorHandler;
      validator.validator.InitValidation(context);
      ArrayList members = null;
      if (validator.validator is AllElementsContentValidator) {
        members = validator.validator.ExpectedElements(context, false, false);
        AddReadAllGroup(serializer, block, type, statements, reader, target, required, result, members, validator.validator.MixedMember);
      } else {

        // There should be one root level anonymous Item0 member.
        SequenceNode seq = (SequenceNode)validator.RootNode; // this is a wrapper node.
        if (seq == null) {
          // perhaps it is ContentType.Empty or Mixed.
          if (validator.validator.ContentType == XmlSchemaContentType.Mixed ||
            validator.validator.ContentType == XmlSchemaContentType.TextOnly){
            Debug.Assert(validator.validator.MixedMember != null);
            statements.Add(new AssignmentStatement(GetMemberBinding(target, validator.validator.MixedMember), 
              new MethodCall(new QualifiedIdentifier(reader, Identifier.For("ReadStringElement")), new ExpressionList())));         
          }
          return;
        } else {
          ContentNode n = seq.LeftChild;
          AddReadContentNode(n, block, statements, reader, target, required, result, validator);
        }
      }    

      // consume final end tag
      statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(reader, Identifier.For("ReadEndTag")), new ExpressionList(elementName))));
    }

    void AddReadContentNode(ContentNode n, Block block, StatementList statements, Identifier reader, 
      Expression target, Expression required, Expression result, SchemaValidator validator) {
      if (n.TypeNode == null) {
        Debug.Assert(n is SequenceNode);
        // In the class inheritance case we have two independent left and right children inside
        // a parent sequence that has no unified type or member.
        SequenceNode s = (SequenceNode)n;
        AddReadContentNode(s.LeftChild, block, statements, reader, target, required, result, validator);
        AddReadContentNode(s.RightChild, block, statements, reader, target, required, result, validator);
        return;
      }
      TypeNode ct = n.TypeNode;
      Debug.Assert(ct != null);
      if (n.Member != null && !(n.Member is Method))  {
        target = GetMemberBinding(target, n.Member);
        ct = target.Type;
      }

      // todo: might be content model AND mixed, in which case we have to pass the MixedMember
      // to AddReadTuple, AddReadChoice and AddReadStream.
      if (ct.Template == SystemTypes.GenericBoxed){
        ct = Checker.GetCollectionElementType(ct);
      }
      if (ct is TupleType) {
        AddReadTuple(block, ct as TupleType, statements, reader, target, required, result);
      } else if (ct is TypeUnion) {
        AddReadChoice(block, ct as TypeUnion, statements, reader, target, required, result);
      } else if (IsStream(ct)) {
        AddReadStream(block, ct, statements, reader, target, result);
      } else if (ct is TypeAlias) {
        AddReadAlias(block, ct as TypeAlias, statements, reader, target, required, result);
      } else {
        Identifier name = Checker.GetDefaultElementName(ct);
        AddReadRequiredChild(block, statements, name, ct, target, reader, result, required, true, false);
      }
    }

    If AddEmptyElementCheck(StatementList statements, Identifier reader) {
      // make sure the element is not empty.
      If isEmpty = new If(new BinaryExpression(new QualifiedIdentifier(reader, Identifier.For("IsEmptyElement")), Literal.True, NodeType.Eq),
        new Block(new StatementList()), new Block(new StatementList()));

      statements.Add(isEmpty);

      statements = isEmpty.TrueBlock.Statements;
      // consume empty start tag and just return.
      statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(reader, Identifier.For("Read")), new ExpressionList())));
  
      return isEmpty;
    }

    void AddReadAllGroup(Class serializer, Block block, TypeNode type, StatementList statements, Identifier reader, 
      Expression target, Expression required, Expression result, ArrayList members, Member mixedMember) {

      // todo: keep track of which members have been read and report error on duplicates
      MethodCall read = new MethodCall(new QualifiedIdentifier(reader, Identifier.For("Read")), new ExpressionList());

      Local sb = new Local(SystemTypes.StringBuilder);
      bool isMixed = mixedMember != null;
      if (isMixed) {
        statements.Add(new AssignmentStatement(sb,
          new Construct(new MemberBinding(null, SystemTypes.StringBuilder), new ExpressionList(), SystemTypes.StringBuilder)));
      }

      Block whileBody = new Block(new StatementList());
      BinaryExpression notEndTag = new BinaryExpression(
        new QualifiedIdentifier(reader, Identifier.For("NodeType")) ,
        new QualifiedIdentifier(Identifier.For("XmlNodeType"), Identifier.For("EndElement")), NodeType.Ne);
      BinaryExpression notEOF = new BinaryExpression(
        new QualifiedIdentifier(reader, Identifier.For("EOF")), Literal.True, NodeType.Ne);
      While w = new While(new BinaryExpression(notEndTag, notEOF, NodeType.And), whileBody);
      statements.Add(w);

      Local nameLocal = new Local(Identifier.For("name"),SystemTypes.String,block);
      Local nsLocal = new Local(Identifier.For("ns"),SystemTypes.String,block);
      Local nodeType = new Local(Identifier.For("nodeType"),Runtime.XmlNodeType,block);

      whileBody.Statements.Add(new AssignmentStatement(nameLocal, new QualifiedIdentifier(reader, Identifier.For("LocalName"))));
      whileBody.Statements.Add(new AssignmentStatement(nsLocal, new QualifiedIdentifier(reader, Identifier.For("NamespaceURI"))));
      whileBody.Statements.Add(new AssignmentStatement(nodeType, new QualifiedIdentifier(reader, Identifier.For("NodeType"))));
      
      Block childBlock = whileBody;

      if (isMixed) {
        // Append the text node to the current StringBuilder contents.
        childBlock = new Block(new StatementList());
        If ifText = new If(IsTextNode(nodeType), new Block(new StatementList()), childBlock);

        whileBody.Statements.Add(ifText);
        ExpressionList args = new ExpressionList();
        args.Add(new QualifiedIdentifier(reader, Identifier.For("Value")));
        ifText.TrueBlock.Statements.Add(new ExpressionStatement(new MethodCall(
          new QualifiedIdentifier(sb, Identifier.For("Append")), args)));
        ifText.TrueBlock.Statements.Add(new ExpressionStatement(read)); // advance to next node
      }      

      If ifElement = new If(new BinaryExpression(nodeType,
        new QualifiedIdentifier(Identifier.For("XmlNodeType"), Identifier.For("Element")), NodeType.Eq),
        new Block(new StatementList()), new Block(new StatementList()));
      childBlock.Statements.Add(ifElement);
      childBlock = ifElement.TrueBlock;

      //AddConsoleWrite(statements, new Literal("name=",SystemTypes.String));
      //AddConsoleWriteLine(statements, nameLocal);
      //AddConsoleWrite(statements, new Literal("nodeType=",SystemTypes.String));
      //AddConsoleWriteLine(statements, nodeType);

      foreach (NamedNode childNode in members) {
        if (!(childNode.Member is Field || childNode.Member is Property)) {
          AddError(statements, reader, RuntimeError.SerializationOfTypeNotSupported, 
            new Literal(childNode.Member.GetType().FullName, SystemTypes.String));
        } else {
          Expression mb = GetMemberBinding(target, childNode.Member);
          childBlock = AddReadChild(block, childBlock.Statements, childNode.Name, childNode.TypeNode, mb, reader, result, true, false).FalseBlock;
          // todo: throw error if child is required. (e.g. NonEmptyIEnumerable...)
        }
      }
      // if it isn't any of the expected elements then throw an error.
      AddError(childBlock.Statements, reader, RuntimeError.NoSuchMember,
        new Expression[2]{new Literal(tempChecker.GetTypeName(type),SystemTypes.String), nameLocal});

      // If it's not an element then consume it anyway to keep the reader advancing.
      // Probably a comment or PI or something.
      ifElement.FalseBlock.Statements.Add(new ExpressionStatement(new MethodCall(
        new QualifiedIdentifier(reader, Identifier.For("Skip")), new ExpressionList())));

      if (isMixed) {
        statements.Add(new AssignmentStatement(GetMemberBinding(target, mixedMember), 
          new MethodCall(new QualifiedIdentifier(sb, Identifier.For("ToString")), new ExpressionList())));         
      }
      statements.Add(new AssignmentStatement(result, Literal.True));

    }

    void AddReadTuple(Block block, TupleType tuple, StatementList statements, Identifier reader, 
      Expression target, Expression required, Expression result){

      Local lt = new Local(Identifier.Empty, tuple, block);

      StatementList currentBlock = statements;

      for(int i = 0, n = tuple.Members.Length; i < n; i++) {
        Member mem = tuple.Members[i];
        if (mem is Field) {
          Field f = (Field)mem;
          TypeNode mt = f.Type;
          if (mt == null) continue; // type resolution error.
          Expression mb = GetMemberBinding(target, f, mt);
          if (mt.Template == SystemTypes.GenericBoxed){
            AddReadOptional(block, statements, f, mb, reader, result);
          }          
          else if (mem.IsAnonymous) {
            if (mt is TupleType || mt is TypeUnion || IsStream(mt)) {
              AddCallDeserializer(mt, statements, reader, mb, required, result);        
            } else  {
              Identifier name = Checker.GetDefaultElementName(mt);
              AddReadRequiredChild(block, statements, name, mt, mb, reader, result, Literal.True, true, true);
            }            
          } else {
            // could reduce a bit of code if we could assign currentName and pass the local to AddReadChild...
            AddReadRequiredChild(block, statements, mem.Name, mt, mb, reader, result, required, false, true);
          }
        }
      }
    }

    void AddReadOptional(Block block, StatementList statements, Member mem, Expression target, Identifier reader, Expression result) {
      TypeNode boxed = Checker.GetMemberType(mem);
      TypeNode type = Checker.GetCollectionElementType(boxed);
      statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(reader, Identifier.For("MoveToContent")), new ExpressionList())));
      Local nameLocal = new Local(Identifier.For("name"),SystemTypes.String, block);
      Local nsLocal = new Local(Identifier.For("ns"),SystemTypes.String, block);
      statements.Add(new AssignmentStatement(nameLocal, new QualifiedIdentifier(reader, Identifier.For("LocalName"))));
      statements.Add(new AssignmentStatement(nsLocal, new QualifiedIdentifier(reader, Identifier.For("NamespaceURI"))));
      StringBuilder expecting = new StringBuilder();
      Expression isFound = null;
      if (mem.IsAnonymous) {
        isFound = IsStartOf(block, type, statements, nameLocal, nsLocal, expecting);    
      } else {
        ExpressionList args = new ExpressionList();
        args.Add(new Literal(mem.Name.Name, SystemTypes.String));
        isFound = new MethodCall(new QualifiedIdentifier(reader, Identifier.For("IsStartElement")), args);
      }
      StatementList trueStatements = new StatementList();
      If ifIsFound = new If(isFound, new Block(trueStatements), null);
      statements.Add(ifIsFound);
      
      if (!AddReadSimpleType(type, trueStatements, reader, target, result, false)) {
        Local localRequired = new Local(Identifier.Empty,SystemTypes.Boolean,block);
        statements.Add(new AssignmentStatement(localRequired, Literal.True));
        AddCallDeserializer(type, trueStatements, reader, target, localRequired, result);            
      } 
    }

    void AddReadRequiredChild(Block scope, StatementList statements, Identifier name, TypeNode type, Expression target, Identifier reader, Expression result, Expression required, bool unwrapChild, bool ignoreNamespace) {
      Block elseBlock = AddReadChild(scope, statements, name, type, target, reader, result, unwrapChild, ignoreNamespace).FalseBlock;
      If notFoundButRequired = new If(new BinaryExpression(required,Literal.True,NodeType.Eq),
        new Block(new StatementList()), null);
      InvalidContent(notFoundButRequired.TrueBlock.Statements, reader, name.Name.ToString());
      elseBlock.Statements.Add(notFoundButRequired);
    }

    void AddConsoleWrite(StatementList statements, Expression e) {
      statements.Add(new ExpressionStatement(
        new MethodCall(new QualifiedIdentifier(Identifier.For("Console"), Identifier.For("Write")),
        new ExpressionList(new Expression[1] { e }
        ))));
    }
    void AddConsoleWriteLine(StatementList statements, Expression e) {
      statements.Add(new ExpressionStatement(
        new MethodCall(new QualifiedIdentifier(Identifier.For("Console"), Identifier.For("WriteLine")),
        new ExpressionList(new Expression[1] { e }
        ))));
    }
    BinaryExpression IsTextNode(Expression nodeType) {
      return new BinaryExpression(
        new BinaryExpression(nodeType,
          new QualifiedIdentifier(Identifier.For("XmlNodeType"), Identifier.For("Text")), NodeType.Eq),
        new BinaryExpression(nodeType,
          new QualifiedIdentifier(Identifier.For("XmlNodeType"), Identifier.For("CDATA")), NodeType.Eq), NodeType.Or);
    }

    void AddReadChoice(Block block, TypeUnion tu, StatementList statements, Identifier reader, 
      Expression target, Expression required, Expression result){
      // Read next element and figure out which of the choices in the type union it is then read the matching Type.
      
      Local nameLocal = new Local(Identifier.For("name"),SystemTypes.String,block);
      Local nsLocal = new Local(Identifier.For("ns"),SystemTypes.String,block);
      Local nodeType = new Local(Identifier.For("nodeType"),Runtime.XmlNodeType,block);
      statements.Add(new AssignmentStatement(nameLocal, new QualifiedIdentifier(reader, Identifier.For("LocalName"))));
      statements.Add(new AssignmentStatement(nsLocal, new QualifiedIdentifier(reader, Identifier.For("NamespaceURI"))));
      statements.Add(new AssignmentStatement(nodeType, new QualifiedIdentifier(reader, Identifier.For("NodeType"))));

      Local localRequired = new Local(Identifier.Empty,SystemTypes.Boolean,block);
      statements.Add(new AssignmentStatement(localRequired, Literal.True));

      Expression readString = new MethodCall(new QualifiedIdentifier(reader, Identifier.For("ReadString")), null, NodeType.Callvirt, SystemTypes.String);
      
      If ifIsElement = new If(new BinaryExpression(nodeType, 
                              new QualifiedIdentifier(Identifier.For("XmlNodeType"), Identifier.For("Element")), NodeType.Eq),
                              new Block(new StatementList()), new Block(new StatementList()));
      statements.Add(ifIsElement);
        
      StatementList elseList = ifIsElement.TrueBlock.Statements;
      StringBuilder expecting = new StringBuilder();
      Expression bestCoercion = null;
      TypeNode bestChoice = null;
      TypeNode bestUnwrappedChoice = null;
      bool stringCoercionAmbiguous = false;

      for (int i = 0, n = tu.Types.Length; i < n; i++) {
        TypeNode choice = tu.Types[i];
        if (choice == null) continue; // type resolution error.

        TypeNode unwrapped = UnwrapSingletonTuple(Unwrap(choice), false);
        if (unwrapped == null) unwrapped = choice;
        Expression coercion = GetConvertFromString(unwrapped, readString, false);
        if (coercion != null) {
          // Keep track of the best coercion to string and use this to handle text nodes below.
          if (bestChoice == null){
            bestChoice = choice;
            bestUnwrappedChoice = unwrapped;
            bestCoercion = coercion;
          } else if (tempTypeSystem.IsBetterMatch(unwrapped, bestUnwrappedChoice, SystemTypes.String)) {
            bestChoice = choice;
            bestUnwrappedChoice = unwrapped;
            bestCoercion = coercion;
          } else {
            stringCoercionAmbiguous = true;
          }
        }

        BinaryExpression be = IsStartOf(block, choice, statements, nameLocal, nsLocal, expecting);    
        StatementList trueStatements = new StatementList();
        If ifIsStartOf = new If(be, new Block(trueStatements), new Block(new StatementList()));
        elseList.Add(ifIsStartOf);
        Local choiceTarget = new Local(Identifier.Empty, choice, block);
        if (choice.Template == SystemTypes.GenericBoxed){
          choice = Checker.GetCollectionElementType(choice);
        }
        if (!AddReadSimpleType(choice, trueStatements, reader, choiceTarget, result, false)) {
          AddCallDeserializer(choice, trueStatements, reader, choiceTarget, localRequired, result);            
        } 
        trueStatements.Add(new AssignmentStatement(target, 
          CastTo(choiceTarget, target.Type)));

        elseList = ifIsStartOf.FalseBlock.Statements;
      }
      if (bestCoercion != null && !stringCoercionAmbiguous) {      
        // Then we can also accept text nodes
        StatementList ifTextStatements = new StatementList();
        If ifIsText = new If(IsTextNode(nodeType), new Block(ifTextStatements), null);            
        ifIsElement.FalseBlock.Statements.Add(ifIsText);
        // then we can also handle text nodes in this choice.
        ifTextStatements.Add(new AssignmentStatement(target, CastTo(CastTo(bestCoercion, bestChoice), tu)));
        ifTextStatements.Add(new AssignmentStatement(result, Literal.True));        
      }

      // If this was a required element, then throw an error.
      If isRequired = new If(new BinaryExpression(required, Literal.True, NodeType.Eq), 
        new Block(new StatementList()), new Block(new StatementList()));
      elseList.Add(isRequired);
      InvalidContent(isRequired.TrueBlock.Statements, reader, expecting.ToString());
      isRequired.FalseBlock.Statements.Add(new AssignmentStatement(result, Literal.False));

    }

    BinaryExpression CastTo(Expression source, TypeNode targetType) {
      return new BinaryExpression(source, new MemberBinding(null,targetType), NodeType.Castclass, targetType);
    }

    BinaryExpression IsStartOf(Block block, TypeNode type, StatementList statements, Expression nameLocal, Expression nsLocal, StringBuilder expecting) {
      BinaryExpression result = null;
      if (IsStructuralType(type)) {
        SchemaElementDecl sd = SchemaElementDecl.Compile(this.module, type, Checker.GetCollectionElementType(type), this.errorHandler, schemaElementDeclCache);
        SchemaValidator validator = validator = sd.CreateValidator(this.errorHandler);   
        ValidationState context = new ValidationState();
        context.ErrorHandler = this.errorHandler;
        validator.validator.InitValidation(context);
        ArrayList members = validator.validator.ExpectedElements(context, false, false);
      
        foreach (TerminalNode node in members) {
          if (node is NamedNode) {
            NamedNode n = node as NamedNode;
            Identifier name = n.Name;
            if (expecting.Length>0) expecting.Append(" | ");
            expecting.Append(name.Name);
            BinaryExpression isName = new BinaryExpression(nameLocal, new Literal(name.Name, SystemTypes.String), NodeType.Eq);
            if (name.Prefix != null) {
              isName = new BinaryExpression(isName,
                new BinaryExpression(nsLocal, new Literal(name.Prefix.Name, SystemTypes.String), NodeType.Eq), 
                NodeType.And);
            }

            if (result == null) result = isName;
            else result = new BinaryExpression(result, isName, NodeType.Or);
          } else if (node is WildcardNode) {
            // todo:???
          }
        }
      } else {
        Identifier name = Checker.GetDefaultElementName(type);
        if (expecting.Length>0) expecting.Append(" | ");
        expecting.Append(name.Name);
        result = new BinaryExpression(nameLocal, new Literal(name.Name, SystemTypes.String), NodeType.Eq);
        if (name.Prefix != null) {
          result = new BinaryExpression(result,
            new BinaryExpression(nsLocal, new Literal(name.Prefix.Name, SystemTypes.String), NodeType.Eq), 
            NodeType.And);
        }
      }
      return result;
    }

    int streamCount;

    void AddReadStream(Block block, TypeNode type, StatementList statements, Identifier reader, 
      Expression target, Expression result){
      // Read next element and figure out if it matches the stream element type, if so read it and add it to the list
      // If not, then return (throw an error if there are no items and the list is the non-empty type).

      // flexArray = new flexarray();
      // while (reader.Read() && read.NodeType != XmlNodeType.EndElement) {
      //    if (reader.NodeType == XmlNodeType.Element) {
      //      readchild(flexarray);
      //    }
      // }
      // target = flexArray; 

      Local nameLocal = new Local(Identifier.For("name"),SystemTypes.String, block);
      Local nsLocal = new Local(Identifier.For("ns"),SystemTypes.String, block);
      Local nodeType = new Local(Identifier.For("nodeType"),Runtime.XmlNodeType, block);
      Local optional = new Local(Identifier.Empty, SystemTypes.Boolean, block);
      Local foundChild = new Local(Identifier.Empty, SystemTypes.Boolean, block);
      statements.Add(new AssignmentStatement(optional, Literal.False));

      TypeNode eType = Checker.GetCollectionElementType(type);
      Local local = new Local(Identifier.Empty, eType, block);
      Method addMethod = null;
      Local localArray = null;

      if (type.Template == SystemTypes.GenericBoxed) {

        addMethod = null; // only needs one!

      } else if (Checker.IsGenericList(type)) {
        //TODO: this call is invalid if the eType is not public
        TypeNode flexArrayType = SystemTypes.GenericList.GetTemplateInstance(this.module, eType);
        localArray = new Local(Identifier.For("stream"+streamCount++), flexArrayType, block);

        statements.Add(new AssignmentStatement(localArray,
          new Construct(new MemberBinding(null, flexArrayType), new ExpressionList(), flexArrayType)));

        addMethod = flexArrayType.GetMethod(Identifier.For("Add"), eType);
      } else  {        
        TypeNode arrayType = SystemTypes.ArrayList;
        localArray = new Local(Identifier.Empty, arrayType, block);
        statements.Add(new AssignmentStatement(localArray,
          new Construct(new MemberBinding(null, arrayType), new ExpressionList(), arrayType)));

        addMethod = arrayType.GetMethod(Identifier.For("Add"), SystemTypes.Object);
      }

      Block whileBody = new Block(new StatementList());
      MethodCall moveToContent = new MethodCall(new QualifiedIdentifier(reader, Identifier.For("MoveToContent")), new ExpressionList());
      BinaryExpression notAtEnd = new BinaryExpression(moveToContent, 
        new QualifiedIdentifier(Identifier.For("XmlNodeType"), Identifier.For("EndElement")), NodeType.Ne);
      BinaryExpression notEOF = new BinaryExpression(
        new QualifiedIdentifier(reader, Identifier.For("EOF")), Literal.True, NodeType.Ne);

      While w = new While(new BinaryExpression(notAtEnd, notEOF, NodeType.And), whileBody);
      statements.Add(w);

      whileBody.Statements.Add(new AssignmentStatement(nameLocal, new QualifiedIdentifier(reader, Identifier.For("LocalName"))));
      whileBody.Statements.Add(new AssignmentStatement(nsLocal, new QualifiedIdentifier(reader, Identifier.For("NamespaceURI"))));
      whileBody.Statements.Add(new AssignmentStatement(nodeType, new QualifiedIdentifier(reader, Identifier.For("NodeType"))));

      StatementList trueStatements = whileBody.Statements;
      if (type.Template == SystemTypes.GenericBoxed){
        type = Checker.GetCollectionElementType(type);
      }

      trueStatements.Add(new AssignmentStatement(foundChild, Literal.False));

      if (eType is TupleType || eType is TypeUnion || IsStream(eType)) {
        AddCallDeserializer(eType, trueStatements, reader, local, optional, foundChild);        
      } else  {
        AddReadChild(whileBody, trueStatements, Checker.GetDefaultElementName(eType), eType, local, reader, foundChild, true, false);
      }

      If ifFound = new If(new BinaryExpression(foundChild, Literal.True, NodeType.Eq),
        new Block(new StatementList()), new Block(new StatementList()));
      ifFound.TrueBlock.Statements.Add(new AssignmentStatement(result, Literal.True)); // set our result to true then.
      ifFound.FalseBlock.Statements.Add(new Exit()); // break out of loop then.

      trueStatements.Add(ifFound);

      if (addMethod == null) {        
        trueStatements.Add(new AssignmentStatement(target, 
          CastTo(local, type))); // box the result.
        trueStatements.Add(new Exit()); // break out of loop we have it!
      } else {
        MemberBinding addCall = new MemberBinding(localArray, addMethod);
        trueStatements.Add(new ExpressionStatement(new MethodCall(addCall, 
          new ExpressionList(new Expression[1] {local}))));
      }

      // clear out the local, it is a struct of some sort.
      if (local.Type.IsValueType && ! local.Type.IsPrimitive) {
        trueStatements.Add(new AssignmentStatement(local, 
          new Construct(new MemberBinding(null,local.Type), new ExpressionList(), local.Type)));
      }

      // end while
      // assign resulting array to the target object (if we have anything to assign).
      If ifResult = new If(new BinaryExpression(result, Literal.True, NodeType.Eq),
        new Block(new StatementList()), null);
      statements.Add(ifResult);
      statements = ifResult.TrueBlock.Statements;

      if (addMethod != null) {
        if (type is ArrayType) {
          // target = (type)localArray.ToArray(etype);
          Method toArray = SystemTypes.ArrayList.GetMethod(Identifier.For("ToArray"), SystemTypes.Type);
          ExpressionList args = new ExpressionList();
          args.Add(new UnaryExpression(new Literal(eType, SystemTypes.Type), NodeType.Typeof, SystemTypes.Type));
          statements.Add(new AssignmentStatement(target, 
            CastTo(new MethodCall(new MemberBinding(localArray, toArray), 
                     args, NodeType.Callvirt, SystemTypes.Array), type)));

        } else if (type.Template == SystemTypes.GenericNonEmptyIEnumerable) {
          // Explicit coercion of IEnumerable to NonEmptyIEnumerable requires constructing 
          // the NonEmptyIEnumerable object passing in the IEnumerable as an argument.
          TypeNode ienumtype = Checker.GetIEnumerableTypeFromNonEmptyIEnumerableStruct(this.module, type);
          Debug.Assert(ienumtype!=null);
          //TODO: this call is invalid if the eType is not public
          TypeNode nonEmptyIEnum = SystemTypes.GenericNonEmptyIEnumerable.GetTemplateInstance(this.module, eType);

          InstanceInitializer ii = nonEmptyIEnum.GetConstructor(ienumtype);
          Construct c = new Construct(new MemberBinding(null, ii), new ExpressionList(localArray), nonEmptyIEnum);
          statements.Add(new AssignmentStatement(target, c));
        } else {
          statements.Add(new AssignmentStatement(target, localArray));
        }
      }
    }

    void AddReadAlias( Block block, TypeAlias alias, StatementList statements, Identifier reader, 
      Expression target, Expression required, Expression result) {

      Local local = new Local(Identifier.Empty, alias.AliasedType, block);
      AddReadRequiredChild(block, statements, alias.Name, alias.AliasedType, local, reader, result, required, true, true);
      statements.Add(new AssignmentStatement(target, this.tempChecker.typeSystem.ImplicitCoercion(local, target.Type)));

    }

    void AddError(StatementList statements, Identifier reader, RuntimeError code, params Expression[] args) {
      ExpressionList list = new ExpressionList();
      list.Add(new Literal(code, Runtime.RuntimeError));
      foreach (Expression e in args) list.Add(e);
      statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(reader, Identifier.For("Error")), list)));
    }

    void InvalidContent(StatementList statements, Identifier reader, string expecting) {
      statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(reader, Identifier.For("InvalidContent")),
        new ExpressionList(new Expression[1]{ new Literal(expecting, SystemTypes.String)}))));
    }

    If AddReadChild(Block scope, StatementList statements, Identifier name, TypeNode type, Expression target, Identifier reader, Expression result, bool unwrapChild, bool ignoreNamespace) {
      ExpressionList args = new ExpressionList();
      args.Add(new Literal(name.Name, SystemTypes.String));
      if (name.Prefix != null) args.Add(new Literal(name.Prefix.Name, SystemTypes.String));
      
      // see if we're on a text node...
      Local nodeType = new Local(Identifier.For("nodeType"), Runtime.XmlNodeType, scope);
      statements.Add(new AssignmentStatement(nodeType, new QualifiedIdentifier(reader, Identifier.For("NodeType"))));
      StatementList ifTextStatements = new StatementList();      
      If ifIsText = new If(
        new BinaryExpression(IsTextNode(nodeType),
          new BinaryExpression(nodeType,
            new QualifiedIdentifier(Identifier.For("XmlNodeType"), Identifier.For("EndElement")), NodeType.Eq),
        NodeType.Or), new Block(ifTextStatements), new Block(new StatementList()));            
      statements.Add(ifIsText);
      
      // then see if we can force the text into the desired type.
      TypeNode unwrapped = UnwrapSingletonTuple(Unwrap(type), false);
      if (unwrapped == null) unwrapped = type;
      Expression readString = new MethodCall(new QualifiedIdentifier(reader, Identifier.For("ReadString")), null, NodeType.Callvirt, SystemTypes.String);
      Expression coercion = GetConvertFromString(unwrapped, readString, false);
      if (coercion != null) {
        ifTextStatements = ifIsText.TrueBlock.Statements;
        ifTextStatements.Add(new AssignmentStatement(target, CastTo(CastTo(coercion, unwrapped),type)));
        ifTextStatements.Add(new AssignmentStatement(result, Literal.True));        
      }
      statements = ifIsText.FalseBlock.Statements;

      If ifFound = null;
      string method = ignoreNamespace ? "IsStartElementIgnoreNamespace" : "IsStartElement";
      MethodCall isStartEle = new MethodCall(new QualifiedIdentifier(reader, Identifier.For(method)), args);
      ifFound = new If(isStartEle, new Block(new StatementList()), new Block(new StatementList()));
      statements.Add(ifFound);
      statements = ifFound.TrueBlock.Statements;       
      
      statements.Add(new AssignmentStatement(result, Literal.True));

      // body of if test, parse the child element as the specified type.
      MethodCall read = new MethodCall(new QualifiedIdentifier(reader, Identifier.For("Read")), new ExpressionList());
      bool isStructuralType = this.IsStructuralType(type);
      if (isStructuralType && unwrapChild) {
        // consume member element wrapper.
        statements.Add(new ExpressionStatement(read));
      }
      if (type.Template == SystemTypes.GenericBoxed){
        type = Checker.GetCollectionElementType(type);
      }

      if (!AddReadSimpleType(type, statements, reader, target, result, false)) {
        AddCallDeserializer(type, statements, reader, target, result, result);
      }
      if (isStructuralType && unwrapChild) {
        // consume member element end tag wrapper.
        statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(reader, Identifier.For("ReadEndTag")), new ExpressionList(new Literal(name.Name, SystemTypes.String)))));
      }
      return ifFound;
    }

    
    void AddCallDeserializer(TypeNode type, StatementList statements, Identifier reader, 
      Expression target, Expression required, Expression result) {

      Class memberSerializer = this.CreateSerializerFor(type);      
      // call the Deserialize method on it, and assign result to target object.
      ExpressionList args = new ExpressionList();
      args.Add(reader);
      args.Add(required);
      if (result is Local) 
        result = new UnaryExpression(result, NodeType.AddressOf);
      args.Add(result);
      MethodCall call = new MethodCall();
      Method deserialize = memberSerializer.GetMethod(Identifier.For("Deserialize"), new TypeNode[3] { Runtime.XmlSerializationReader, SystemTypes.Boolean, SystemTypes.Boolean.GetReferenceType() } );
      call.Callee = new MemberBinding(new MemberBinding(null, memberSerializer), deserialize);
      call.Operands = args;
      statements.Add(new AssignmentStatement(target, call));
    }

    TypeNode Unwrap(TypeNode type) {
      if (type is TypeAlias) {
        return Unwrap(((TypeAlias)type).AliasedType);
      }
      if (type is ConstrainedType) {
        return Unwrap(((ConstrainedType)type).UnderlyingType);
      }      
      return type;
    }

    bool AddWriteSimpleType(TypeNode simpleType, StatementList statements, TypeNode referringType, Identifier writer, Expression src, Expression name, Expression ns) {

      Identifier method = null;
      TypeNode type = Unwrap(simpleType);

      ExpressionList args = new ExpressionList(src);

      if (type == SystemTypes.String) {
        method = Identifier.For("WriteString");
      } else if( type == SystemTypes.Boolean) {
        method = Identifier.For("WriteBoolean");
      } else if( type == SystemTypes.Int8) {
        method = Identifier.For("WriteSByte");
      } else if( type == SystemTypes.Char) {
        method = Identifier.For("WriteChar");
      } else if( type == SystemTypes.DateTime) {
        method = Identifier.For("WriteDateTime");
      } else if( type == SystemTypes.Decimal) {
        method = Identifier.For("WriteDecimal");
      } else if( type == SystemTypes.Double) {
        method = Identifier.For("WriteDouble");
      } else if( type == SystemTypes.Guid) {
        method = Identifier.For("WriteGuid");
      } else if( type == SystemTypes.Int16) {
        method = Identifier.For("WriteInt16");
      } else if( type == SystemTypes.Int32) {
        method = Identifier.For("WriteInt32");
      } else if( type == SystemTypes.Int64) {
        method = Identifier.For("WriteInt64");
      } else if( type == SystemTypes.UInt8) {
        method = Identifier.For("WriteByte");
      } else if( type == SystemTypes.Single) {
        method = Identifier.For("WriteSingle");
      } else if( type == SystemTypes.TimeSpan) {
        method = Identifier.For("WriteTimeSpan");
      } else if( type == SystemTypes.UInt16 ) {
        method = Identifier.For("WriteUInt16");
      } else if( type == SystemTypes.UInt32) {
        method = Identifier.For("WriteUInt32");
      } else if( type == SystemTypes.UInt64) {
        method = Identifier.For("WriteUInt64");
      } else {
        Expression conversion = GetConvertToString(type, src, false);
        if (conversion != null) {
          statements = AddCheckForNull(statements, Duplicate(src, referringType), type);
          method = Identifier.For("WriteString");
          args = new ExpressionList(conversion);
        } else {
          return false;
        } 
      }
    
      if (name != null) {        
        Identifier id = Checker.GetDefaultElementName(type);
        string defaultName = id.Name;
        string defaultNamespace = (id.Prefix != null) ? id.Prefix.Name : null;
        Expression localName = new Local(SystemTypes.String);
        Expression localNamespace = new Local(SystemTypes.String);
        Expression safeName = name;
        if (name is Literal) {
          if (name == Literal.Null) {
            localName =  new Literal(defaultName, SystemTypes.String);
            localNamespace = new Literal(defaultNamespace, SystemTypes.String);
          } else {
            localName = name;
            localNamespace = ns;
          }
        } else {
          If nameNull = new If(new BinaryExpression(name, Literal.Null, NodeType.Eq), new Block(new StatementList()), new Block(new StatementList()));
          nameNull.TrueBlock.Statements.Add(new AssignmentStatement(localName, new Literal(defaultName, SystemTypes.String)));
          nameNull.TrueBlock.Statements.Add(new AssignmentStatement(localNamespace, new Literal(defaultNamespace, SystemTypes.String)));
          nameNull.FalseBlock.Statements.Add(new AssignmentStatement(localName, name));
          nameNull.FalseBlock.Statements.Add(new AssignmentStatement(localNamespace, ns));
          statements.Add(nameNull);
        }

        MethodCall call = new MethodCall();
        call.Callee = new QualifiedIdentifier(writer,Identifier.For("WriteStartElement"));
        call.Operands = new ExpressionList();
        call.Operands.Add(localName);
        call.Operands.Add(localNamespace);
        statements.Add( new ExpressionStatement( call ) );
      }
      StatementList notNull = statements;
      if (!type.IsValueType) {
        notNull = AddCheckForNull(statements, Duplicate(src, referringType), type);
      }        
      notNull.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, method), args)));

      if (name != null) {
        MethodCall call = new MethodCall();
        call.Callee = new QualifiedIdentifier(writer,Identifier.For("WriteEndElement"));
        call.Operands = new ExpressionList();
        statements.Add( new ExpressionStatement( call ) );      
      }
      return true;
    }

    static Identifier xmlnsuri = Identifier.For("http://www.w3.org/XML/1998/namespace");

    Literal GetXmlNameFromId(Identifier id) {
      if (id.Prefix != null && id.Prefix.UniqueKey == xmlnsuri.UniqueKey) {
        // this is a special namespace
        return new Literal("xml:"+id.Name, SystemTypes.String);
      }
      return new Literal(id.Name, SystemTypes.String);
    }
    Literal GetXmlNamespaceFromId(Identifier id) {
      if (id.Prefix == null ) {
        return Literal.Null;
      } else if (id.Prefix.UniqueKey == xmlnsuri.UniqueKey) {
        // this is a special namespace
        return Literal.Null;
      }
      // Let the XmlTextWriter generate an XML prefix for us.
      return new Literal(id.Prefix.Name, SystemTypes.String);
    }
    bool AddWriteSimpleAttribute(TypeNode type, Identifier name, StatementList statements, TypeNode referringType, Identifier writer, Expression src) {
      ExpressionList args = new ExpressionList();
      args.Add(GetXmlNameFromId(name));
      args.Add(GetXmlNamespaceFromId(name));
      args.Add(src);

      if (type == SystemTypes.String) {
        statements = AddCheckForNull(statements, Duplicate(src, referringType), type);
        statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, Identifier.For("WriteAttributeString")), args)));
      } else if( type == SystemTypes.Boolean) {
        statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, Identifier.For("WriteAttributeBoolean")), args)));
      } else if( type == SystemTypes.Int8) {
        statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, Identifier.For("WriteAttributeSByte")), args)));
      } else if( type == SystemTypes.Char) {
        statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, Identifier.For("WriteAttributeChar")), args)));
      } else if( type == SystemTypes.DateTime) {
        statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, Identifier.For("WriteAttributeDateTime")), args)));
      } else if( type == SystemTypes.Decimal) {
        statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, Identifier.For("WriteAttributeDecimal")), args)));
      } else if( type == SystemTypes.Double) {
        statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, Identifier.For("WriteAttributeDouble")), args)));
      } else if( type == SystemTypes.Guid) {
        statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, Identifier.For("WriteAttributeGuid")), args)));
      } else if( type == SystemTypes.Int16) {
        statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, Identifier.For("WriteAttributeInt16")), args)));
      } else if( type == SystemTypes.Int32) {
        statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, Identifier.For("WriteAttributeInt32")), args)));
      } else if( type == SystemTypes.Int64) {
        statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, Identifier.For("WriteAttributeInt64")), args)));
      } else if( type == SystemTypes.UInt8) {
        statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, Identifier.For("WriteAttributeByte")), args)));
      } else if( type == SystemTypes.Single) {
        statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, Identifier.For("WriteAttributeSingle")), args)));
      } else if( type == SystemTypes.TimeSpan) {
        statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, Identifier.For("WriteAttributeTimeSpan")), args)));
      } else if( type == SystemTypes.UInt16 ) {
        statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, Identifier.For("WriteAttributeUInt16")), args)));
      } else if( type == SystemTypes.UInt32) {
        statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, Identifier.For("WriteAttributeUInt32")), args)));
      } else if( type == SystemTypes.UInt64) {
        statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, Identifier.For("WriteAttributeUInt64")), args)));
      } else {
        Expression conversion = GetConvertToString(type, src, true);
        if (conversion != null) {         
          statements = AddCheckForNull(statements, Duplicate(src, referringType), type);
          ExpressionList args2 = new ExpressionList();
          args2.Add(args[0]);
          args2.Add(args[1]);
          args2.Add(conversion);          
          statements.Add(new ExpressionStatement(new MethodCall(new QualifiedIdentifier(writer, Identifier.For("WriteAttributeString")), args2)));
        } else {
          return false;
        } 
      }
      return true;
    }

    bool AddReadSimpleType(TypeNode simpleType, StatementList statements, Identifier reader, Expression mb, Expression result, bool always) {
      TypeNode type = Unwrap(simpleType);

      string method = null;
      Expression conversion = null;

      if (type == SystemTypes.String) {
        method = "ReadStringElement";
      } else if (type == SystemTypes.Boolean) {
        method = "ReadBool";
      } else if (type == SystemTypes.Int8) {
        method = "ReadSByte";
      } else if (type == SystemTypes.Char) {
        method = "ReadChar";
      } else if (type == SystemTypes.DateTime) {
        method = "ReadDateTime";
      } else if (type == SystemTypes.Decimal) {
        method = "ReadDecimal";
      } else if (type == SystemTypes.Double) {
        method = "ReadDouble";
      } else if (type == SystemTypes.Guid) {
        method = "ReadGuid";
      } else if (type == SystemTypes.Int16) {
        method = "ReadInt16";
      } else if (type == SystemTypes.Int32) {
        method = "ReadInt32";
      } else if (type == SystemTypes.Int64) {
        method = "ReadInt64";
      } else if (type == SystemTypes.UInt8) {
        method = "ReadInt8";
      } else if (type == SystemTypes.Single) {
        method = "ReadSingle";
      } else if (type == SystemTypes.TimeSpan) {
        method = "ReadTimeSpan";
      } else if (type == SystemTypes.UInt16) {
        method = "ReadUInt16";
      } else if (type == SystemTypes.UInt32) {
        method = "ReadUInt32";
      } else if (type == SystemTypes.UInt64) {
        method = "ReadUInt64";
      } else {
        // see if there's a type converter for it.
        conversion = GetConvertFromString(type, new MethodCall(new QualifiedIdentifier(reader, Identifier.For("ReadStringElement")), null), always);         
      }
      if (method != null) {
        conversion = new MethodCall(new QualifiedIdentifier(reader, Identifier.For(method)), null, NodeType.Callvirt, type);
      }
      if (conversion == null)
        return false; // there is no simple conversion!
      
      statements.Add(new AssignmentStatement(mb, CastTo(conversion, simpleType)));      
      if (result != null)
        statements.Add(new AssignmentStatement(result, Literal.True));
      return true;
    }
  }
}