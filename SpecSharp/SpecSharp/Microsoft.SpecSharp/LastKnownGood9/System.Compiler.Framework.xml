<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.Compiler.Framework</name>
    </assembly>
    <members>
        <member name="T:System.Compiler.Verifier">
            <summary>
            Walks an IR looking for preconditions that have not been satisfied
            </summary>
        </member>
        <member name="F:System.Compiler.LanguageService.currentSymbolTable">
            <summary>Tracks the symbol table (Module) associated with the current editor window</summary>
        </member>
        <member name="F:System.Compiler.LanguageService.EnableDropDownCombos">
            <summary>Set this to True if you want drop downs showing types and members</summary>
        </member>
        <member name="M:System.Compiler.AuthoringSink.MatchPair(System.Compiler.SourceContext,System.Compiler.SourceContext)">
            <summary>
            Whenever a matching pair is parsed, e.g. '{' and '}', this method is called
            with the text span of both the left and right item. The
            information is used when a user types "ctrl-]" in VS
            to find a matching brace and when auto-highlight matching
            braces is enabled.
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringSink.MatchTriple(System.Compiler.SourceContext,System.Compiler.SourceContext,System.Compiler.SourceContext)">
            <summary>
            Matching tripples are used to highlight in bold a completed statement.  For example
            when you type the closing brace on a foreach statement VS highlights in bold the statement
            that was closed.  The first two source contexts are the beginning and ending of the statement that
            opens the block (for example, the span of the "foreach(...){" and the third source context
            is the closing brace for the block (e.g., the "}").
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringSink.StartName(System.Compiler.Identifier)">
            <summary>
            In support of Member Selection, CompleteWord, QuickInfo, 
            MethodTip, and Autos, the StartName and QualifyName methods
            are called.
            StartName is called for each identifier that is parsed (e.g. "Console")
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringSink.QualifyName(System.Compiler.SourceContext,System.Compiler.Identifier)">
            <summary>
            QualifyName is called for each qualification with both
            the text span of the selector (e.g. ".")  and the text span 
            of the name ("WriteLine").
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringSink.AutoExpression(System.Compiler.SourceContext)">
            <summary>
            AutoExpression is in support of IVsLanguageDebugInfo.GetProximityExpressions.
            It is called for each expression that might be interesting for
            a user in the "Auto Debugging" window. All names that are
            set using StartName and QualifyName are already automatically
            added to the "Auto" window! This means that AutoExpression
            is rarely used.
            </summary>   
        </member>
        <member name="M:System.Compiler.AuthoringSink.CodeSpan(System.Compiler.SourceContext)">
            <summary>
            CodeSpan is in support of IVsLanguageDebugInfo.ValidateBreakpointLocation.
            It is called for each region that contains "executable" code.
            This is used to validate breakpoints. Comments are
            automatically taken care of based on TokenInfo returned from scanner. 
            Normally this method is called when a procedure is started/ended.
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringSink.StartParameters(System.Compiler.SourceContext)">
            <summary>
            The StartParameters, Parameter and EndParameter methods are
            called in support of method tip intellisense (ECMD_PARAMINFO).
            [StartParameters] is called when the parameters of a method
            are started, ie. "(".
            [NextParameter] is called on the start of a new parameter, ie. ",".
            [EndParameter] is called on the end of the paramters, ie. ")".
            REVIEW: perhaps this entire scheme should go away
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringSink.NextParameter(System.Compiler.SourceContext)">
            <summary>
            NextParameter is called after StartParameters on the start of each new parameter, ie. ",".
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringSink.EndParameters(System.Compiler.SourceContext)">
            <summary>
            EndParameter is called on the end of the paramters, ie. ")".
            </summary>
        </member>
        <member name="M:System.Compiler.AuthoringSink.AddError(System.Compiler.ErrorNode)">
            <summary>
            Send a message to the development enviroment. The kind of message
            is specified through the given severity. 
            </summary>
        </member>
        <member name="T:System.Compiler.TypeAndMemberDropdownBars">
            <summary>
            Represents the two drop down bars on the top of a text editor window that allow types and type members to be selected by name.
            </summary>
        </member>
        <member name="F:System.Compiler.TypeAndMemberDropdownBars.languageService">
            <summary>The language service object that created this object and calls its SynchronizeDropdowns method</summary>
        </member>
        <member name="F:System.Compiler.TypeAndMemberDropdownBars.sortedDropDownTypes">
            <summary>The list of types that appear in the type drop down list. Sorted by full type name.</summary>
        </member>
        <member name="F:System.Compiler.TypeAndMemberDropdownBars.dropDownTypes">
            <summary>The list of types that appear in the type drop down list. Textual order.</summary>
        </member>
        <member name="F:System.Compiler.TypeAndMemberDropdownBars.dropDownMembers">
            <summary>The list of types that appear in the member drop down list. Sorted by name.</summary>
        </member>
        <member name="F:System.Compiler.TypeAndMemberDropdownBars.sortedDropDownMembers">
            <summary>The list of members that appear in the member drop down list. Textual order.</summary>
        </member>
        <member name="M:System.Compiler.TypeAndMemberDropdownBars.SynchronizeDropdowns(System.String,System.Int32,System.Int32)">
            <summary>
            Updates the state of the drop down bars to match the current contents of the text editor window. Call this initially and every time
            the cursor position changes.
            </summary>
            <param name="textView">The editor window</param>
            <param name="line">The line on which the cursor is now positioned</param>
            <param name="col">The column on which the cursor is now position</param>
        </member>
        <member name="T:System.Compiler.Optimizer">
            <summary>
            Runs after Normalizer and Analyzer. Performs rewrites that we don't want the analyzer to see, e.g., removes
            calls to conditional methods.
            It can also take advantage of invariants learned during the Analyzer phase.
            </summary>
        </member>
        <member name="T:System.Compiler.Normalizer">
            <summary>
            Walks an IR, mutuating it into a form that can be serialized to IL+MD by Writer
            </summary>
        </member>
        <member name="M:System.Compiler.Normalizer.NormalizeToPointerCoercion(System.Compiler.BinaryExpression)">
            <summary>
            Hook for other languages to do something different. Normal C#,Spec# don't emit any particular coercion to pointer types.
            </summary>
            <param name="binaryExpr">NodeType.Castclass, Type is Pointer</param>
        </member>
        <member name="M:System.Compiler.Normalizer.CreateTryCatchBlock(System.Compiler.Method,System.Compiler.Block,System.Compiler.Block,System.Compiler.Local)">
            <summary>
            Creates a block containing the given tryBlock and catchBlocks and
            returns it. The method is modified by having new ExceptionHandlers
            added to it which points to the right places in the blocks.
            The type of exception caught by each catch block should be the type
            of the corresponding local l.
            </summary>
            <param name="m">The method in which the try-catch block will be
            inserted into.</param>
            <param name="tryBody">A block of statements that will be the body
            of the try-catch statement.</param>
            <param name="catchBodies">A sequence of blocks; each one contains the
            statements that will be the body of a catch clause on the try-catch statement.
            </param>
            <param name="l">The local into which the exception will be
            assigned. Presumably, the body of the catch clause does something
            with this local.</param>
            <returns>A single block which must be inserted into m by the client.
            </returns>
        </member>
        <member name="T:System.Compiler.StackDepth2">
            <summary>
            Replacement for StackDepth, which is good, but slow. This one
            takes advantage of the layout of blocks to do it in a linear scan rather
            than the heavy weight dataflow appraoch of StackDepth.
            
            Cannot currently be used, since layout of blocks after all our transformations
            (finally dup) does not correspond to needed layout.
            </summary>
            <remarks> On mscorlib, StackDepth2 is 5 times faster than StackDepth (1 instead of 5 secs total time spent)
            </remarks>
        </member>
        <member name="M:System.Compiler.StackDepth2.DepthBeforeStat(System.Compiler.Statement)">
            <summary>
            Returns the stack depth right before executing the statement <c>stat</c>.
            </summary>
        </member>
        <member name="M:System.Compiler.StackDepth2.DepthBeforeBlock(System.Compiler.Block)">
            <summary>
            Returns the stack depth at the beginning of block <c>block</c>.
            </summary>
        </member>
        <member name="T:System.Compiler.StackDepth">
            <summary>
            StackDepth analysis.  Objects of this class are query objects: once you construct a
            StackDepth object for a specific method, you can query it about the stack depth
            at specific points in the method code.  The analysis is completely executed during the
            construction of the object.
            </summary>
        </member>
        <member name="M:System.Compiler.StackDepth.#ctor(System.Compiler.LowLevelControlFlowGraph)">
            <summary>
            Constructs a <c>StackDepth</c> object that can answer queries about the
            depth of the stack in any point of the analyzed method control flow graph.
            </summary>
            <param name="cfg">Control Flow Graph of the analyzed method.</param>
        </member>
        <member name="M:System.Compiler.StackDepth.DepthBeforeStat(System.Compiler.Statement)">
            <summary>
            Returns the stack depth right before executing the statement <c>stat</c>.
            </summary>
        </member>
        <member name="M:System.Compiler.StackDepth.DepthBeforeBlock(System.Compiler.Block)">
            <summary>
            Returns the stack depth at the beginning of block <c>block</c>.
            </summary>
        </member>
        <member name="M:System.Compiler.StackDepth.Display(System.IO.TextWriter)">
            <summary>
            Prints the analyzed CFG, decorated with the stack depth in any statement / block.
            </summary>
            <param name="tw">Where to print.</param>
        </member>
        <member name="T:System.Compiler.StackDepth.WrongStackDepthException">
            <summary>
            Exception thrown when the stack depth in some program point is not the expected one.
            E.g., different stack depths in a merge point, non-empty stack before a return statement, etc.
            TODO: add some explicit info about the error source.
            </summary>
        </member>
        <member name="T:System.Compiler.IDataFlowInfo">
            <summary>
            General interface for the information manipulated by a dataflow analysis
            (i.e., the information attached to the progarm points).
            </summary>
        </member>
        <member name="M:System.Compiler.IDataFlowInfo.Dump">
            <summary>
            Prints a description of <c>this</c> object, for debug purposes.
            </summary>
        </member>
        <member name="T:System.Compiler.AnalysisSpec">
             <summary>
             Abstract root for the specification of a forward dataflow analysis.
             Each analysis should subclass this class.  An analysis specification is
             composed of the transfer function(s) and the merge operation on the
             dataflow info lattice.
             
             <p/>
             Subclasses are expected to override the <c>JoinWithMutation</c> (always)
             and the transfer functions, as follows:
             
             <ul>
             <li>
             If only a core solver (<see cref="T:System.Compiler.ICoreDataFlowSolver">ICoreDataFlowSolver</see>)
             will be executed for this analysis,
             then only Transfer(Block) is needed.  For this, one can either override it
             directly, or implement Transfer(Statement) and rely on the default implementation
             of Transfer(Block) (see the comments attached to it).
             </li>
            
             <li>
             If a full solver (<see cref="T:System.Compiler.IDataFlowSolver">IDataFlowSolver</see>)
             will be executed
             for this analysis, then both Transfer(Block) and Transfer(Statement) should be up and
             running!
             </li>
             
             </ul>
             </summary>
        </member>
        <member name="M:System.Compiler.AnalysisSpec.Transfer(System.Compiler.Statement,System.Compiler.IDataFlowInfo)">
            <summary>
            Transfer function for a statement: given a statement and the dataflow
            info before the statement, returns a pair consisting of two dataflow
            pieces of info for the state after the statement, corresponding to the cases
            when the execution proceeded normally / with an exception.
            
            IMPORTANT:  This method CAN mutate its <c>info</c> argument.  It can also
            produce any kind of aliasing between the info argument and the two components
            of the returned TransferFunctionResult.
            </summary>
        </member>
        <member name="M:System.Compiler.AnalysisSpec.TransferInitBlock(System.Compiler.Block,System.Compiler.IDataFlowInfo)">
            <summary>
            Transfer function attached to the hidden semantics of the beginning of a block.
            E.g., for a catch block, the caught exception is pushed on the stack, even if there
            is no explicit instruction in the block that does this (that's what "hidden" refers to).
            
            IMPORTANT: This method CAN mutate its <c>info</c> argument.  It can also produce any kind of
            aliasing between the info argument and the two components of the returned TransferFunctionResult.
            
            NOTE: the default implementation just returns new TransferFunctionResult(info, null).  Override
            if you need something else.
            </summary>
        </member>
        <member name="M:System.Compiler.AnalysisSpec.Transfer(System.Compiler.Block,System.Compiler.IDataFlowInfo)">
            <summary>
            Transfer function for a block: given a block and the dataflow
            info before the block, returns a pair consisting of two dataflow
            pieces of info for the state after the block, corresponding to the cases
            when the execution proceeded normally / with an exception.
            
            IMPORTANT: it is OK to have any kind of aliasing between the <c>info</c> argument
            and the two components of the returned TransferFunctionResult.  However, <c>info</c> SHOULD
            NOT BE MUTATED in any way.
            
            <p>
            The default implementation of this method does a smart composition of
            the transfer functions for the statements composing the block.  Overriders
            should preserve this semantics, but they are free to do whatever optimizations
            they can imagine. E.g., compose the functions the first time to obtain a simplified
            function (encoded in some way), and apply only this function later on.</p> 
            </summary>
        </member>
        <member name="M:System.Compiler.AnalysisSpec.JoinWithMutation(System.Compiler.IDataFlowInfo,System.Compiler.IDataFlowInfo)">
            <summary>
            Join with mutation, for efficiency reasons.  In a dataflow solver, we often
            accumulate dataflow information in some points: e.g., we can compute the info
            attached to the program point right before a block "on the fly": each time we
            process a prdecessor block, we merge (join with mutation) the resulting info
            to the info for the beginning of the successors.
            
            </summary>
            <param name="accum">Accumulator <c>IDataFlowInfo</c>.</param>
            <param name="delta">Delta <c>IDataFlowInfo</c> to be merged into the accumulator.
            NOTE: overriders should not mutate delta.</param>
            <returns><c>true</c> if the accumulator was modified, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:System.Compiler.StackDepthVisitor">
            <summary>
            This class is meant to be used only by the StackDepthAnalysis and the
            StackRemovalTransformation: given a stack depth right before a statement,
            it walks over the statement, update the depth and calls some code transformers
            to modfify the code (by default, they don't do anything, StackRemoval overrides
            them.
            </summary>
        </member>
        <member name="T:System.Compiler.ProperOrderVisitor">
            <summary>
            Subclass of the CCI <c>StandardVisitor</c> that visits the fields of statements in
            the same order that is used by the Reader.  This is important if you want to (abstractly)
            interpret some code.  Sub-expressions have side effects, hence, the order they are
            visited IS important.  Unfortunately, this cannot be part of the CCI because many projects
            rely on the semantics (if any) of the current visitor.
            </summary>
        </member>
        <member name="M:System.Compiler.StackDepthVisitor.PopTransformer(System.Compiler.Expression,System.Int32)">
            <summary>
            Override this if you want to replace a Pop expression with some other expression.
            </summary>
            <param name="expression">Expression to replace; must have type NodeType.Pop.</param>
            <param name="depth">Stack Depth right before evaluating the pop.</param>
            <returns>Any valid expression; by default, it returns the argument, unchanged.</returns>
        </member>
        <member name="M:System.Compiler.StackDepthVisitor.DupTransformer(System.Compiler.ExpressionStatement,System.Int32)">
            <summary>
            Override this if you want to replace a Dup statement with some other expression.
            </summary>
            <param name="statement">Statement to replace; must be an ExpressionStatement with the type
            of the expression equal to NodeType.Dup.</param>
            <param name="depth">Stack depth right before executing the dup.</param>
            <returns>Any valid statement; by default, it returns the argument, unchanged.</returns>
        </member>
        <member name="M:System.Compiler.StackDepthVisitor.PopExprTransformer(System.Compiler.ExpressionStatement,System.Int32)">
            <summary>
            Override this if you want to replace a Call(...); Pop sequence (which is modeled
            by CCi as a unary expression with operator Pop and a MethodCall as its only operand).
            </summary>
            <param name="expr_stat">ExpressionStatement to replace.</param>
            <param name="depth">Stack depth right before the push;</param>
            <returns>Any valid statement; by default, it returns the argument, unchanged.</returns>
        </member>
        <member name="M:System.Compiler.StackDepthVisitor.PushExprTransformer(System.Compiler.ExpressionStatement,System.Int32)">
            <summary>
            Override this if you want to replace an [implicit] Push expression expression statement
            with something else.
            </summary>
            <param name="expr_stat">Expression to replace.</param>
            <param name="depth">Stack depth right before the expression statement.</param>
            <returns>Any valid expression; by default, it returns the argument, unchanged.</returns>
        </member>
        <member name="M:System.Compiler.StackDepthVisitor.PopStatTransformer(System.Compiler.ExpressionStatement,System.Int32)">
            <summary>
            Override this if you want to replace a Pop statement with something else.
            </summary>
            <param name="expr_stat">Expression to replace.</param>
            <param name="depth">Stack depth right before the Pop statement.</param>
            <returns>Any valid expression; by default, it returns the argument, unchanged.</returns>
        </member>
        <member name="M:System.Compiler.StackRemovalTransformation.Process(System.Compiler.LowLevelControlFlowGraph)">
            <summary>
            Examines a CFG and removes the stack manipulating instructions by introducing
            some explicit variables for stack locations.  After this transformation, no more
            Pop, Dup etc.
            </summary>
            <param name="cfg">Control Flow Graph that is modified by the transformation.
            This argument WILL be mutated.</param>
            <returns>A map that assigns to each block from <c>cfg</c> the stack depth at its
            beginning.  Useful as a pseudo-liveness information.</returns>
        </member>
        <member name="M:System.Compiler.StackRemovalTransformation.StackRemovalVisitor.PopTransformer(System.Compiler.Expression,System.Int32)">
            <summary>
            Replace a pop expression with the appropriate stack variable.
            </summary>
        </member>
        <member name="M:System.Compiler.StackRemovalTransformation.StackRemovalVisitor.DupTransformer(System.Compiler.ExpressionStatement,System.Int32)">
            <summary>
            Replace a dup expression with the appropriate stack variable.
            </summary>
        </member>
        <member name="M:System.Compiler.StackRemovalTransformation.StackRemovalVisitor.PopExprTransformer(System.Compiler.ExpressionStatement,System.Int32)">
            <summary>
            Remove the Pop from a CciHelper statement "sequence" of the form "Pop expr".
            </summary>
        </member>
        <member name="M:System.Compiler.StackRemovalTransformation.StackRemovalVisitor.PushExprTransformer(System.Compiler.ExpressionStatement,System.Int32)">
            <summary>
            Replace an implicit Push with an assignment to the appropriate stack variable.
            </summary>
        </member>
        <member name="M:System.Compiler.StackRemovalTransformation.StackRemovalVisitor.PopStatTransformer(System.Compiler.ExpressionStatement,System.Int32)">
            <summary>
            Replace an explicit Pop statement with a nop: stack is modeled by stack vars now.
            </summary>
        </member>
        <member name="T:System.Compiler.MethodNotPureException">
            <summary>
            Auxilary classes for purity analysis
            </summary>
        </member>
        <member name="T:System.Compiler.PurityAnalyzer">
            <summary>
            Walks an IR,  doing purity analysis for each method.
            </summary>
        </member>
        <member name="M:System.Compiler.PurityAnalyzer.VisitMethod(System.Compiler.Method)">
            <summary>
            It will maintain a list of restricted variables that should not be modified.
            If fields of any of these variables are modified, an MethodNotPureException will be thrown out.
            </summary>
            <param name="method"></param>
            <returns></returns>
            <exception name="MethodNotPureException"> If any fields following a 
            restricted variables are modified. </exception>
        </member>
        <member name="T:System.Compiler.Restriction">
            <summary>
            State implementation for MethodPurityChecker.
            </summary>
        </member>
        <member name="T:System.Compiler.HashSet">
             <summary>
             Full implementation of the <c>ISet</c> interface, backed by a <c>Hashtable</c>.
             </summary>
             <remarks>
             As each <c>HashSet</c> is backed by a
             <see cref="T:System.Collections.Hashtable">Hashtable</see>, all requirements that
             apply for the <c>Hashtable</c> keys apply for the elements of a <c>HashSet</c>
             as well.
            
             <p>The <c>HashSet</c> class overrides the methods
             <see cref="M:System.Compiler.HashSet.GetHashCode">GetHashCode</see> and <see cref="M:System.Object.Equals(System.Object)">Equals</see>
             (inherited from <see cref="T:System.Object">Object</see>) in order to provide
             structural equality:
             two sets are equal iff they contain the same elements (where the semantics of "same"
             is defined by the <c>Equals</c> method of those objects).  You can put HashSets into
             HashSets; however, to avoid infinite loops, you should never insert a <c>HashSet</c>
             into itself.
             The hashcode of a <c>HashSet</c> is defined as the "xor" of the hashcodes of the set
             elements. 
             </p>
             
             <p>
             The <c>GetHashCode</c> function of a <c>HashSet</c> executes in <c>O(1)</c> time:
             the hashcode is dynamically updated after each operation that modifies the set.
             If the hashcode functions used for all the other involved objects is good and
             is computed in <c>O(1)</c> time, one element addition and removal execute in
             <c>O(1)</c> time; <c>Equals</c> works in time linear to the number of elements of
             <c>this</c> set.
             </p> 
             </remarks>
        </member>
        <member name="T:System.Compiler.IMutableSet">
            <summary>
            Interface for the set abstraction: collection of distinct elements.
            </summary>
        </member>
        <member name="T:System.Compiler.ICopyable">
            <summary>
            Represents an object that can be copied deeply, as opposed to the shallow ICloneable.
            </summary>
        </member>
        <member name="M:System.Compiler.ISet.Contains(System.Object)">
            <summary>
            Checks whether a given element is part of <c>this</c> set.
            </summary>
            <param name="elem">element searched into the set</param>
            <returns><c>true</c> if <c>elem</c> is in the set, <c>false</c> otherwise</returns>
        </member>
        <member name="M:System.Compiler.IMutableSet.Add(System.Object)">
            <summary>
            Adds an element to <c>this</c> set.
            </summary>
            <param name="elem">element to add</param>
            <returns><c>true</c> if <c>this</c> set was modified as a result of this operation</returns>
            
        </member>
        <member name="M:System.Compiler.IMutableSet.Remove(System.Object)">
            <summary>
            Removes an element from <c>this</c> set. 
            </summary>
            <param name="elem"></param>
            <returns><c>true</c> if <c>this</c> set was modified as a result of this operation</returns>
        </member>
        <member name="M:System.Compiler.IMutableSet.AddAll(System.Collections.IEnumerable)">
            <summary>
            Adds several elements from <c>this</c> set.
            </summary>
            <param name="eable"><c>IEnumerable</c> that contains the elements to be added</param>
            <returns><c>true</c> if <c>this</c> set was modified as a result of this operation</returns>
        </member>
        <member name="M:System.Compiler.IMutableSet.RemoveAll(System.Collections.IEnumerable)">
            <summary>
            Removes several elements from <c>this</c> set.
            </summary>
            <param name="eable"><c>IEnumerable</c> containing the elements to be removed</param>
            <returns><c>true</c> if <c>this</c> set was modified as a result of this operation</returns>
        </member>
        <member name="M:System.Compiler.IMutableSet.Clear">
            <summary>
            Deletes all the elements of <c>this</c> set. As a result the <c>Count</c> property will be <c>0</c>.
            </summary>
            <returns><c>true</c> if <c>this</c> set was modified as a result of this operation</returns>
        </member>
        <member name="M:System.Compiler.HashSet.#ctor">
            <summary>
            Constructs an empty <c>HashSet</c>.
            </summary>
        </member>
        <member name="M:System.Compiler.HashSet.#ctor(System.Collections.IEnumerable)">
            <summary>
            Constructs a <c>HashSet</c> initialized to contain all
            elements from an <c>IEnumerable</c>.
            </summary>
        </member>
        <member name="T:System.Compiler.MethodPurityChecker">
            <summary>
            For a given method, using its CFG to found out all alias for fields, and 
            modified.
            </summary>
        </member>
        <member name="T:System.Compiler.ForwardDataFlowAnalysis">
            <summary>
            Implements a pretty standard data flow analysis with merging of data flow states at join
            points. 
            
            Details:
            
            At each block, we maintain two data flow states, pending, and done. Done represents the 
            dataflow state under which the block has already been analyzed, whereas Pending represent
            the state under which the block still needs to be analyzed.
            
            When a block is reached with a state, it is merged into the pending state. This merge can
            either be precise, or with weakening (includes now more possibilities than the two states
            that were merged).
            
            Once a block is dequeued for analysis, we compute the new done state, which is the merge
            of the pending state with the	old done state. There are 3 possible outcomes:
            1. The old done state completely supersedes the new pending state: no reanalysis is necessary
            2. The merge is precise, then the block needs to be analyzed only with the pending state 
               (no need to redo all cases in the done state). 
            3. The merge is imprecise (contains more possibilities than in either the pending or the old 
               done state), then we need to analyze the block using this merged state in order to account
               for these new possibilities.
              
            Another imprecision arises from the merge of pending states. This merge could be imprecise, and
            therefore at the next analysis, we could be analyzing the block under extra cases. Buckets could
            be used to avoid this. Buckets just increase the language of formulas for expressing fixpoints to
            a finite disjunction.
            
            Each block can be in one of 3 states:
            a) unenabled (block needs to be reached by more edges before we run it)
            b) enabled and in work queue (needs to be rescheduled)
            c) enabled but has been processed with latest incoming states.
            </summary>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.PopPendingState(System.Compiler.CfgBlock)">
            <summary>
            Like PendingState returns the pending state for the given block, but
            it also sets the pending state for this block to null.
            </summary>
            <returns>old pending state</returns>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.JoinWithPendingState(System.Compiler.CfgBlock,System.Compiler.CfgBlock,System.Compiler.IDataFlowState)">
            <summary>
            Merge the new pending state with the old pending states.
            </summary>
            <returns>merged pending state</returns>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.StateToReanalyzeBlock(System.Compiler.CfgBlock,System.Compiler.CfgBlock,System.Compiler.IDataFlowState,System.Boolean@)">
            <summary>
            Checks if a block needs to be reanalyzed and under what state.
            
            Updates the doneState of this block to reflect the pending state
            </summary>
            <returns>null if no reanalysis necessary, the dfs state if the merge is precise,
            the merged state if the merge is imprecise
            </returns>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.Run(System.Compiler.ControlFlowGraph,System.Compiler.IDataFlowState)">
            <summary>
            Starts the analysis from the entry block of the CFG
            </summary>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.Run(System.Compiler.ControlFlowGraph,System.Compiler.CfgBlock,System.Compiler.IDataFlowState)">
            <summary>
            Starts the analysis at the first instruction of the given block
            </summary>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.PushExceptionState(System.Compiler.CfgBlock,System.Compiler.IDataFlowState)">
            <summary>
            Push the given state onto the handler of the block.
            This causes call-backs to SplitException in order to correctly distribute
            the exception state among different nested handlers.
            </summary>
            <param name="currentBlock">Block from which exception escapes</param>
            <param name="state">state on exception flow</param>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.PushState(System.Compiler.CfgBlock,System.Compiler.CfgBlock,System.Compiler.IDataFlowState)">
            <summary>
            Add the given state to the pending states of the target block. If 
            the block is enabled (by the pending edge count optimization), add the
            block to the worklist.
            
            Inv: DoneState => PendingState /\ PendingState != null => InQueue
            
            Cases:
              1. Done => new, nothing to do
              2. Done |_| new is precise.  Pend' = Pend |_| new,  Done' = Done |_| new
              3. Done |_| new is imprecise.  Pend' = Done |_| new,  Done' = Done |_| new
            </summary>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.VisitBlock(System.Compiler.CfgBlock,System.Compiler.IDataFlowState)">
            <summary>
            Default per block visitor. Called from Run.
            
            It calls VisitStatement on each statement in a block. 
            
            The result of this method is used as the state for all normal control flow successors.
            To push state onto an exception handler, use the PushExceptionState method. Furthermore, for
            conditional branches, different states can be pushed onto the true and false branches directly
            by calling PushPending. In that case, null should be returned from the method in order to avoid pushing
            the returned state onto both true and false targets again.
            </summary>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.VisitStatement(System.Compiler.CfgBlock,System.Compiler.Statement,System.Compiler.IDataFlowState)">
            <summary>
            Default per statement visitor called from the default VisitBlock.
            Does identity transformation. Subclasses either override this method
            if the default block handling is sufficient, or they override the Visit method for blocks.
            
            The result of this method is used as the state for all normal control flow successors.
            To push state onto an exception handler, use the PushExceptionState method. Furthermore, for
            conditional branches, different states can be pushed onto the true and false branches directly
            by calling PushPending. In that case, null should be returned from the method in order to avoid pushing
            the returned state onto both true and false targets again.
            </summary>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.Merge(System.Compiler.CfgBlock,System.Compiler.CfgBlock,System.Compiler.IDataFlowState,System.Compiler.IDataFlowState,System.Boolean@,System.Boolean@)">
            <summary>
            Compute the join of two data flow states at the given block.
            </summary>
            <param name="previous">Predecessor block for this new state</param>
            <param name="joinPoint">Block at which join is computed</param>
            <param name="atMerge">Old state at this block. Can be null, in which case the incoming state
            is the first non-bottom state. In this case, the method must set changed
             <c>resultDiffersFromPreviousMerge</c> to true.</param>
            <param name="incoming">New data flow state flowing to this block.</param>
            <param name="resultDiffersFromPreviousMerge">Boolean for fix point. If the state after
            the merge is equal to the old <c>atMerge</c> state, set to false, otherwise set to true.</param>
            <param name="mergeIsPrecise">can be set to true if the merged result state strictly contains only
            information representing either the atMerge or the incoming state, but no extra approximation. If
            this information cannot be determined by the merge, it must return false. True can only be returned
            if result is truly precise.</param>
            <returns>The new merged state.</returns>
        </member>
        <member name="M:System.Compiler.ForwardDataFlowAnalysis.SplitExceptions(System.Compiler.CfgBlock,System.Compiler.IDataFlowState@,System.Compiler.IDataFlowState@)">
            <summary>
            Splits the exceptions into the ones that this handler will handle and the ones that should
            <code>currentHandlerState</code> and <code>nextHandlerState</code> cannot both be null.
            On exit, if <code>currentHandlerState</code> is null, <code>handler</code> handles no exceptions,
            and if <code>nextHandlerState</code> is null, <code>handler</code> handles all the exceptions in
            the initial exception set of <code>currentHandlerState</code>.
            </summary>
        </member>
        <member name="T:System.Compiler.ForwardDataFlowAnalysis.WorkQueue">
            <summary>
            Elements can only be once on this queue. Duplicates are removed.
            </summary>
        </member>
        <member name="T:System.Compiler.PriorityQueue">
            <summary>
            Implements a work list as a priority queue
            </summary>
        </member>
        <member name="T:System.Compiler.PurityInstructionVisitor">
            <summary>
            Visit each instruction, check whether the modification is autorized.
            </summary>
        </member>
        <member name="T:System.Compiler.InstructionVisitor">
            <summary>
            Decoder for CCI statements after normalization and code flattening. Provides a view of
            instructions close to CIL (.NET CLR Partition 3 document).
            The Visit method recognizes the CCI encodings for each instruction and calls
            the appropriate Visit* method.  Subclassing <c>InstructionVisitor</c> allows writing
            visitors that deal directly with only a small set of distinct instructions and without
            recursive expressions, since arguments to all instructions are variables.
            <p/>
            To make decoding simple, some MSIL instructions are split, such as ldtoken, which was
            split into three cases: LDTYPETOKEN, LDFIELDTOKEN, LDMETHODTOKEN.
            <p/>
            On the other hand, some instructions are distinguished by <c>null</c> tests; the MSIL instructions
            "ldfld" (load object field) and "ldsfld" (load static field) are modeled by the same visitor
            LDFIELD "dest := source.field" with source being <c>null</c> for a static field. Similarly, an unconditional
            branch instruction is modelled as an BRANCH with a <c>null</c> condition.
            <p/>
            The envisioned use of this class is as follows:  subclass <c>InstructionVisitor</c> and override
            each Visit* method
            (VisitCopy, VisitLoadConstant etc.) to specify the processing that you want for each instruction.
            Given a Cci statement (normalized and flattened) stat, do the appropriate processing for it by calling 
            Visit(stat, some_arg).
            <p/>
            Visit acts as a dispatcher: it recognizes the instruction encoded by stat and calls the
            appropriate Visit* method with the right arguments.  Visit stands for a top-level transfer function:
            its second argument is the argument passed to the appropriate transfer function; its result is the
            result of that transfer function.
            <p/>
            NOTE: With generics, we would have defined InstructionVisitor as Visitor&lt;A,B&gt;, where A and B
            are the argument type, respectively the result type of each transfer function.  If your transfer
            functions don't take any argument, you can pass <c>null</c>.
            Similarly, if they don't return anything, you can return <c>null</c>.
            <p/>
            See the documentation of each of the Visit* methods for more info on the format of each instruction.
            Also see the <c>SampleInstructionVisitor</c> for a full example.
            <p>
            The following conventions apply for each Visit* method:</p>
            
            <ol>
            <li>The last two arguments are the original Cci statement and the argument passed to
            Visit(Statement stat, object arg) 
            </li>
            Having the original statements allows you to attach information to it (in some hashtable) or, in rare
            cases, to look for features that are not exposed.
            <li>Each method returns an object. This is conceptually the result of the transfer function associated with
            that instruction.</li>
            <li>Each such method is called by the dispatcher Visit(Statement stat, object arg) with all arguments
            non-null, unless specified otherwise in the documentation for Visit*.</li>
            </ol>
            
            <p>
            By default, each Visit* method calls the abstract method <c>DefaultVisit</c>.</p>
            
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.Visit(System.Compiler.Statement,System.Object)">
            <summary>
            Decodes the statement and dispatches to one of the Visit methods below.
            </summary>
            <param name="stat">Visited statement.</param>
            <param name="arg">Argument for the transfer function.</param>
            <returns>Result of the appropriate transfer function.</returns>
            
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitNop(System.Compiler.Statement,System.Object)">
            <summary>
            nop -- no operation
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitMethodEntry(System.Compiler.Method,System.Collections.IEnumerable,System.Compiler.Statement,System.Object)">
            <summary>
            method entry -- a pseudo instruction that marks the beginning of a method.
            </summary>
            <param name="method">Method that starts with this instrution.</param>
            <param name="parameters">All parameters of this method, including <c>this</c> (order is important).</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitUnwind(System.Compiler.Statement,System.Object)">
            <summary>
            unwind -- a pseudo instruction that marks the exceptional exit of a method. 
            <p>
            Description:
            <br/>
            This is the point where the currently thrown exception leaves the method.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitBranch(System.Compiler.Variable,System.Compiler.Block,System.Compiler.Statement,System.Object)">
            <summary>
            branch cond,target -- branch on condition.
            <p>
            Description:
            <br/>
            Branch to target block if condition is true.
            </p>
            </summary>
            <param name="cond">Condition of the branch statement; <c>null</c> for an unconditional jump.</param>
            <param name="target">Target of the branching instruction.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitSwitch(System.Compiler.Variable,System.Compiler.BlockList,System.Compiler.Statement,System.Object)">
            <summary>
            switch selector,targets -- branch to target block indexed by selector
            <p>
            Description:
            <br/>
            if <c>selector</c> is between <c>0</c> and <c>targets.Length-1</c>c>
            then branch to targets[selector]. Othwerise, fall though.
            </p>
            </summary>
            <param name="selector">Selector variable.</param>
            <param name="targets">List of targets.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitSwitchCaseBottom(System.Compiler.Statement,System.Object)">
            <summary>
            switchcasebottom -- a pseudo instruction equal to nop. Marks the end of a switch case when introduced by
            the language parser. Allows checking for fall through from one case to another.
            </summary>
            <param name="stat">The source context should point at the case.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitReturn(System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            return -- return from the method
            <p>
            Description:
            <br/>
            Return the value in var from the method.
            </p>
            </summary>
            <param name="var">Variable that holds the returned value. <c>null</c> if the method return type
            is <c>void</c>.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitThrow(System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            throw -- throw the exception
            </summary>
            <param name="var">Variable that holds the thrown value (never <c>null</c>).</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitRethrow(System.Compiler.Statement,System.Object)">
            <summary>
            rethrow -- rethrow the currently handled exception
            <p>
            Description:
            <br/>
            Only appears within handlers. Its semantics is to rethrow the exception that the handler
            is currently processing.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitCatch(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            var = catch(type) -- catch exception matching type and store in var
            <p>
            Description:
            <br/>
            Starts an exception handler and acts as the test whether the handler applies to the caught 
            exception given the type. If the exception does not apply, then control goes to the handler
            of the current block. Otherwise, control goes to the next instruction.
            </p>
            
            </summary>
            <param name="var">Variable that holds the caught exception.</param>
            <param name="type">Type of the exceptions that are caught here.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitFilter(System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := filter -- pseudo instruction marking the beginning of a filter handler.
            <p>
            Description:
            <br/>
            Semantics: assigns the exception being filtered to the <c>dest</c> variable.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitEndFilter(System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            endfilter code -- marks the end of the filter section of a filter handler. 
            <p>
            Description:
            <br/>
            tests the code at the end of the filter section of a filter handler. If code is 0, handler
            does not apply, and the next handler should be tried. If 1, hander applies and the next instruction
            is executed.
            
            In our encoding, if the instruction falls through, it must push the implicit exception being 
            handled onto the stack, since the next instruction is a catch of the actual handler.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadNull(System.Compiler.Variable,System.Compiler.Literal,System.Compiler.Statement,System.Object)">
            <summary>
            dest := null -- ldnull instruction, assigns null to destination.
            </summary>
            <param name="source">The <c>null</c> literal. Passed here for source context.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadConstant(System.Compiler.Variable,System.Compiler.Literal,System.Compiler.Statement,System.Object)">
            <summary>
            dest := ldc c -- store the constant c in dest
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitArgumentList(System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := arglist -- (corresponds to the MSIL instruction OxFE00 arglist).
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitSizeOf(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := sizeof(T) -- store the runtime size of type T in dest
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitConstrainedCall(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Method,System.Compiler.ExpressionList,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := Constraint(T).receiver.callee(arguments) -- invoke virtual method with Constrain prefix.
            </summary>
            <param name="dest">Variable that stores the result of the call. <c>null</c> if the called method
            return type is <c>void</c> or ignored.</param>
            <param name="receiver">Receiver of the virtual call. Note that the behavior of this instruction depends on the
            type of the receiver in the generic instance:
            The receiver must have a reference type ref P. If the instance of P is a struct type, then the code becomes
              st0 = box(receiver, T);
              st0.callee(arguments);
              
            If the instance of P is a reference type (class or interface), then we simply load the indirect pointer contents:
              st0 = *receiver;
              st0.callee(arguments);
            <br/>
            </param>
            <param name="callee">Compile-time called method; the method that is actually invoked might be different
            in the case of a dynamically dispatched call.</param>
            <param name="arguments">Call arguments; does not include the value for the "this" argument; that value is
            the given by the receiver (if any). All elements of this list are Variables.</param>
            <param name="constraint">The type constraint of the receiver</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitCopy(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := source -- variable to variable assignment
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitNewObject(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := new T -- allocate a new object of type T. DOES NOT INCLUDE .CTOR CALL, see below.
            
            Called for a new expression. Note that MSIL newobj instructions are broken into 3 steps:
            1. A separate allocation (this method)
            2. A separate constructor call (normal call)
            3. A separate assignment of the newly allocated object to the intended target variable.
            
            </summary>
            <param name="dest">Temporary to hold raw allocation result</param>
            <param name="type">Object type to be allocated</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitNewArray(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := new T[size] -- allocate a new array of the given size and type
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitCall(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Method,System.Compiler.ExpressionList,System.Boolean,System.Compiler.Statement,System.Object)">
            <summary>
            dest := receiver.callee(arguments) -- invoke method 
            </summary>
            <param name="dest">Variable that stores the result of the call. <c>null</c> if the called method
            return type is <c>void</c>.</param>
            <param name="receiver">Receiver for virtual calls. <c>null</c> in the case of a static call
            (warning: static call and call to a static method different things: you can call a virtual method
            without using dynamic dyspatch).
            <br/>
            If the <c>callee</c> is a member of a value type T, <c>receiver</c> is of type T;amp; (reference to T).
            </param>
            <param name="callee">Compile-time called method; the method that is actually invoked might be different
            in the case of a dynamically dispatched call.</param>
            <param name="arguments">Call arguments; does not include the value for the "this" argument; that value is
            the given by the receiver (if any). All elements of this list are Variables.</param>
            <param name="virtcall">Indicates whether this is a dynamically dispatched call or not.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitCallIndirect(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable[],System.Compiler.FunctionPointer,System.Compiler.Statement,System.Object)">
            <summary>
            dest := (*callee)([receiver], arguments) -- call indirect function pointer.
            </summary>
            <param name="dest">Variable that stores the result of the call. <c>null</c> if the called method
            return type is <c>void</c>.</param>
            <param name="callee">Function pointer value.</param>
            <param name="receiver">Receiver for virtual calls. <c>null</c> in the case of a static call
            (warning: static call and call to a static method are different things: you can call a virtual method
            without using dynamic dispatch).</param>
            <param name="arguments">Call arguments; does not include the value for the "this" argument; that value is
            the given by the receiver (if any). All elements of this list are Variables.</param>
            <param name="fp">Function pointer signature.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitBinaryOperator(System.Compiler.NodeType,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := operand1 op operand2 -- assign result of binary operation to dest
            </summary>
            <param name="op">Binary operator (e.g. NodeType.Add).</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitUnaryOperator(System.Compiler.NodeType,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := op operand -- assign result of unary operation to dest.
            </summary>
            <param name="op">Unary operator.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitCastClass(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := (T)source -- cast object source to type T and assign result to dest.
            <p>
            Description:
            <br/>
            if type of source is a subtype of <c>type</c>, then assign source to dest;
            otherwise throw a <c>System.InvalidCastException</c>.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitIsInstance(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := source as T -- istest instruction.
            <p>
            Description:
            <br/>
            If type of source is a subtype of T, assign source to dest; otherwise assign <c>null</c> to dest.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitBox(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := box(T) source -- box source object of type T.
            <p>
            Description:
            <br/>
            If boxable (T is a value type or type parameter), boxes the source value int a fresh object and assigns
            result to dest. If T is an object type, it acts as a noop.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitUnbox(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := unbox(T) source -- convert boxed value type to its raw (value) form
            <p>
            Description:
            <br/>
            The instruction first checks that source is not null, otherwise throws NullReferenceException. Then it checks
            that the boxed value actually contains a value of type T, otherwise InvalidCastException is thrown.
            Finally, it copies a pointer of type T&amp; (reference to value type) into dest that points at the box 
            contents.
            </p>
            </summary>
            <param name="type">Value type of the contents expected in the boxed value.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitUnboxAny(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := unbox.any(T) source -- convert object to type T.
            <p>
            Description:
            <br/>
            <ul>
            <li>
            If <c>T</c> is a value type, extracts the value from the boxed object <c>source</c> and assigns it to <c>dest</c>. 
            In this case, the instruction acts like <c>unbox</c> followed by <c>ldobj</c>.
            </li>
            <li>
            If <c>T</c> is an object type, the instruction acts like castclass.
            </li>
            <li>
            If <c>T</c> is a type parameter, the instruction behaves dependent on the actual runtime type bound to T. 
            </li>
            </ul>
            </p>
            </summary>
            <param name="source">Object to unbox</param>
            <param name="type">Target type of the unbox.any.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadField(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Field,System.Compiler.Statement,System.Object)">
            <summary>
            dest := source.field -- load field and assign to destination.
            <p>
            Description
            <br/>
            This instruction covers the cases of instance AND static field read instructions. If source is null, the field
            is static, otherwise it is an instance field.
            
            In the case where the field is a member of a value type T, then source is of type T&amp; (reference to T).
            </p>
            </summary>
            <param name="source">Variable that points to the object whose field we read.
            <c>null</c> if <c>field</c> is static.</param>
            <param name="field">Loaded field (can be a static one).</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitStoreField(System.Compiler.Variable,System.Compiler.Field,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest.field := source -- store source into field.
            <p>
            Description:
            <br/>
            This instruction covers the cases of instance AND static field store instructions. If dest is null, the field
            is static, otherwise it is an instance field.
            
            In the case where the field is a member of a value type T, then dest is of type T&amp; (reference to T).
            </p>
            </summary>
            <param name="dest">Variable that points to the object whose field we write. <c>null</c> if
            <c>field</c> is static.</param>
            <param name="field">Written field.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadElement(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := source[index] -- load element from array
            </summary>
            <param name="source">Variable that points to the array whose element we read.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitStoreElement(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest[index] := source -- store array element
            </summary>
            <param name="dest">Variable that points to the array whose element we write.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadAddress(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := &amp; source -- load address of local variable and store into dest.
            </summary>
            <param name="source">Variable whose address is taken.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadFieldAddress(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Field,System.Compiler.Statement,System.Object)">
            <summary>
            dest := &amp; source.field -- load address of field and store into dest.
            <p>
            Description:
            <br/>
            The instruction covers both instance and static fields. For static fields, source is null.
            
            For fields of reference type T, source is of type T&amp; (reference to T).
            </p>
            </summary>
            <param name="source">Variable pointing to the object that contains <c>field</c>; may be
            <c>null</c> is <c>field</c> is static.</param>
            <param name="field">Field whose address we load (may be static).</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadElementAddress(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := &amp; array[index] -- load address of array element and store into dest.
            <p>
            Description:
            <br/>
            Takes the address of the array element indexed and stores it into dest.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadIndirect(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := *((type *) pointer) -- load value stored at pointer and assign to dest
            <p>
            MSIL instructions: ldind.T, ldobj
            <br/>
            </p>
            </summary>
            <param name="type">Type of the loaded value.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitStoreIndirect(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            *((type *) pointer) := source -- store value at pointer
            <p>
            MSIL instructions: stind.T, stobj
            </p>
            </summary>
            <param name="type">Type of the stored value.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadFunction(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Method,System.Compiler.Statement,System.Object)">
            <summary>
            dest := &amp;source.method -- load method pointer and store into dest.
            <p>
            Description:
            <br/>
            loads the address where a method code starts. This instruction covers both
            ldftn and ldvirtftn: for ldvirtftn, the dynamic dispatch algorithm is used to find
            the appropriate method.
            
            For static functions, source is null.
            </p>
            </summary>
            <param name="source">Address of the object whose dynamically-dispatched method we are
            interested in.</param>
            <param name="method">If <c>source</c> is <c>null</c>, then the address of this method is loaded,
            otherwise, we load the address of the method that is invoked by a call to source.method.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitLoadToken(System.Compiler.Variable,System.Object,System.Compiler.Statement,System.Object)">
            <summary>
            dest := ldtoken token -- load meta data token (type, method, or field) and store into dest.
            </summary>
            <param name="token">TypeNode / Field / Method whose metadata token is assigned to <c>dest</c>.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitCopyBlock(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            memcpy(destaddr, srcaddr, size) -- cpblk instruction, copies data from memory to memory
            </summary>
            <param name="destaddr">Variable that stores the start address of the destination memory area.</param>
            <param name="srcaddrs">Variable that stores the start address of the source memory area.</param>
            <param name="size">Variable that stores the number of bytes to copy.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitInitializeBlock(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            initblk addr, value, size -- initblk instruction, initializes memory to a value
            </summary>
            <param name="addr">Variable that stores the start address of the memory area to be initialized.</param>
            <param name="val">Variable that stores the "unsigned int8" value that will be stored in each
            memory byte.</param>
            <param name="size">Variable that stores the number of bytes to initialize.</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitInitObj(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            *dest := initobj T -- initobj instruction, assigns a default value to dest.
            <p>
            Description:
            <br/>
            dest is managed or unmanaged pointer to T. If T is a value type, this instruction initializes each field of T
            to its default value or zero for primitive types.
            If T is an object type, this instruction has the same effect as <c>ldnull</c> followed by <c>stind</c>.
            </p>
            </summary>
            <param name="addr">The pointer to the value type to be initialized. Is either Struct or EnumNode</param>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitBreak(System.Compiler.Statement,System.Object)">
            <summary>
            break -- debugger break instruction, causes the execution to transfer control to a debugger.
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitMakeRefAny(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := mkrefany source,type -- assign typed reference to dest 
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitRefAnyValue(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            dest := refanyval source,type -- load the address out of a typed reference
            <p>
            Description:
            <br/>
            Throws <c>InvalidCastException</c> if typed reference isn't of type <c>type</c>. If it is
            extracts the object reference and stores it in dest.
            </p>
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.VisitRefAnyType(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            dest := refanytype source --- extracts the type from a typed reference and assigns it to dest.
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.DefaultVisit(System.Compiler.Statement,System.Object)">
            <summary>
            Default visitor called by each non-overridden visitor above.
            </summary>
        </member>
        <member name="M:System.Compiler.InstructionVisitor.GetReceiverAndCallee(System.Compiler.MethodCall,System.Compiler.Variable@,System.Compiler.Method@,System.Compiler.FunctionPointer@)">
            <summary>
            Unscrambles a method target. 
            </summary>
            <param name="call">The method call node to unscramble</param>
            <param name="receiver">Returns the receiver expression. Maybe null.</param>
            <param name="callee">Returns the method, if target is a method, otherwise null.</param>
            <param name="fpointer">Returns the function pointer if target is a function pointer, otherwise null.</param>
        </member>
        <member name="M:System.Compiler.PurityInstructionVisitor.VisitStoreField(System.Compiler.Variable,System.Compiler.Field,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            If the dest is not restricted, the action is allowed.
            Needs to update RV set.
            </summary>
            <param name="dest"></param>
            <param name="field"></param>
            <param name="source"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PurityInstructionVisitor.VisitLoadField(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Field,System.Compiler.Statement,System.Object)">
            <summary>
            Maintaining rv
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="field"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PurityInstructionVisitor.VisitStoreElement(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            If the dest is not restricted, the action is allowed.
            Need to maintain rv.
            </summary>
            <param name="dest"></param>
            <param name="index"></param>
            <param name="source"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PurityInstructionVisitor.VisitCastClass(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            Treated like a regular assignment to variables.
            </summary>
            <param name="dest"></param>
            <param name="type"></param>
            <param name="source"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PurityInstructionVisitor.VisitBox(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            If the source is restricted, the box is too.
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="type"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PurityInstructionVisitor.VisitUnbox(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            If the box is restricted, the dest is too.
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="type"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PurityInstructionVisitor.VisitCall(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Method,System.Compiler.ExpressionList,System.Boolean,System.Compiler.Statement,System.Object)">
            <summary>
            Method being called must be pure in the first place.
            If the reference is restricted, then the return is also restricted.
            </summary>
            <param name="dest"></param>
            <param name="receiver"></param>
            <param name="callee"></param>
            <param name="arguments"></param>
            <param name="virtcall"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PurityInstructionVisitor.VisitCopy(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            Simple value copy.
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PurityInstructionVisitor.VisitLoadAddress(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            If the source is restricted, then the dest is secret too.
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PurityInstructionVisitor.VisitThrow(System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            So far we can retrieve the type of the exception being thrown. So
            every catch handler will be tinted if current variable is restricted.
            </summary>
            <param name="var"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PurityInstructionVisitor.VisitCatch(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            
            </summary>
            <param name="var"></param>
            <param name="type"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PurityInstructionVisitor.VisitBinaryOperator(System.Compiler.NodeType,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            Binary operation does not return references. 
            </summary>
            <param name="op"></param>
            <param name="dest"></param>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PurityInstructionVisitor.VisitSwitchCaseBottom(System.Compiler.Statement,System.Object)">
            <summary>
            Treated as assume(false)
            </summary>
        </member>
        <member name="M:System.Compiler.PurityInstructionVisitor.VisitRefAnyValue(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            Value restrictions need to be preserved.
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="type"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.PurityInstructionVisitor.VisitRefAnyType(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            Type token is fine.
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="T:System.Compiler.ArrayEnumerator">
            <summary>
            Enumerator over a prefix of an array (System.Array.GetEnumerator returns
            an enumerator over ALL the elements of the array).
            </summary>
        </member>
        <member name="M:System.Compiler.ArrayEnumerator.#ctor(System.Object[],System.Int32)">
            <summary>
            Constructs an enumerator  over the first <c>size</c> elements of <c>array</c>.
            NOTE: I couldn't find any way of detecting comodification errors ...
            </summary>
        </member>
        <member name="T:System.Compiler.DataStructUtil">
            <summary>
            Summary description for DataStructsUtil.
            </summary>
        </member>
        <member name="M:System.Compiler.DataStructUtil.IEnum2String(System.Collections.IEnumerable,System.Compiler.DObj2String)">
            <summary>
            Produces a string representation of an <c>IEnumerable</c> object,
            using <c>o2s</c> to produce the string representation of each
            element.
            </summary>
            <param name="eable"></param>
            <param name="o2s"></param>
            <returns></returns>
            
        </member>
        <member name="T:System.Compiler.DObj2String">
            <summary>
            Conversion object -> string. Useful for classes for which we cannot
            modify / override the <c>ToString</c> method. A <c>null</c> value
            should be interpreted as the classic <c>ToString</c> method.
            </summary>
        </member>
        <member name="T:System.Compiler.Datatype">
            <summary>
            An attempt to make coding with datatypes more pleasant in C#
            </summary>
            <remarks>
            Use <c>Datatype</c> as a base class on each of your abstract data type base classes. When doing
            case analysis on such a value, use the method <c>Tag</c> to get a String representation of the 
            dynamic class name. This can be matched in the <c>case</c> branches of a switch. 
            <p>
            For pairwise matching, use <c>x.Tag + y.Tag</c> and <c>case "Foo"+"Bar"</c>.
            </p>
            Can be extended to compute the set of tags of each abstract datatype instance and utility methods.
            </remarks>
        </member>
        <member name="T:System.Compiler.FList">
            <summary>
            Functional lists. null represents the empty list.
            </summary>
        </member>
        <member name="M:System.Compiler.FList.Intersect(System.Compiler.FList,System.Compiler.FList)">
            <summary>
            Given two sorted lists, compute their intersection
            </summary>
            <param name="l1">sorted list</param>
            <param name="l2">sorted list</param>
            <returns>sorted intersection</returns>
        </member>
        <member name="T:System.Compiler.IMap">
            <summary>
            An abstraction for maps
            </summary>
        </member>
        <member name="T:System.Compiler.HashedMap">
            <summary>
            A Map based on a hashtable.
            </summary>
        </member>
        <member name="M:System.Compiler.HashedMap.Copy">
            <summary>
            Deep copy. Checks if values implement ICopyable. If so, copies them too.
            </summary>
        </member>
        <member name="T:System.Compiler.ListMap">
            <summary>
            A Map based on a ListDictionary
            </summary>
        </member>
        <member name="M:System.Compiler.ListMap.Copy">
            <summary>
            Deep copy. Checks if values implement ICopyable. If so, copies them too.
            </summary>
        </member>
        <member name="M:System.Compiler.Set.NonSubsetWitness(System.Compiler.ISet,System.Compiler.ISet)">
            <summary>
            Returns null if A included in B. Otherwise, returns an element in
            A that is not in B.
            </summary>
        </member>
        <member name="T:System.Compiler.NodeSet">
            <summary>
            uses trivial hashtable as its set implementation
            </summary>
        </member>
        <member name="M:System.Compiler.NodeSet.GetEnumerator">
            <summary>
            Has to clean out the ArrayList, since it may contain stale keys.
            </summary>
        </member>
        <member name="M:System.Compiler.IMutableRelation.AddRelation(System.Compiler.IRelation)">
            <summary>
            Adds an entire relation to <d>this</d> relation.
            </summary>
            <param name="relation">Relation that is unioned with this relation.</param>
            <returns><c>true</c> iff <c>this</c> relation changed.</returns>
        </member>
        <member name="T:System.Compiler.Relation">
            <summary>
            Full <c>IMutableRelation</c> implementation.
            </summary>
        </member>
        <member name="M:System.Compiler.Relation.#ctor(System.Compiler.DDictionaryFactory,System.Compiler.DSetFactory)">
            <summary>
            Full power relation constructor that allows you to finely tune the memory consumption.
            Internally, a relation is a dictionary that assigns to each key the set of values that are
            in relation with it.  This constructor allows you to specify the dictionary and the set
            factory.
            </summary>
            <param name="dict_fact">Dictionary factory used to construct the underlying dictionary.</param>
            <param name="set_fact">Set factory used to construct the set that will store the values
            assoctiated with each key.</param>
        </member>
        <member name="M:System.Compiler.Relation.#ctor">
            <summary>
            Default constructor.  Uses the default factory for dictionaries (i.e., equiv. to new Hashtable())
            and sets (i.e., equiv. to new HashSet()).
            </summary>
        </member>
        <member name="M:System.Compiler.Relation.Clone">
            <summary>
            "Shallow" copy of a relation.  Produces an independent copy of <c>this</c> <c>Relation</c>.
            The keys and values are not duplicated.  Operations on the
            resulting <c>Relation</c> and on <c>this</c> <c>Relation</c> don't interact.
            </summary>
            <returns>An independent copy of <c>this</c> Relation.</returns>
        </member>
        <member name="M:System.Compiler.Relation.Copy">
            <summary>
            Deep copy of a relation.  Produces an independent copy of <c>this</c> <c>Relation</c>,
            in which even the keys and values are duplicated (using deep copy) if they implement
            the ICopyable interface.  Operations on the resulting <c>Relation</c> and on <c>this</c>
            <c>Relation</c> don't interact.
            </summary>
            <returns>A really deep copy of <c>this</c> <c>Relation</c>.</returns>
        </member>
        <member name="T:System.Compiler.EnumeratorFilter">
            <summary>
            Returns null if object should not be returned, otherwise, returns object.
            Can thus change objects.
            </summary>
        </member>
        <member name="T:System.Compiler.CompoundEnumerable">
            <summary>
            "Glues" together two <c>IEnumerable</c> objects in a single view.
            </summary>
        </member>
        <member name="M:System.Compiler.CompoundEnumerable.#ctor(System.Collections.IEnumerable,System.Collections.IEnumerable,System.Compiler.EnumeratorFilter,System.Object)">
            <summary>
            Construct an enumerable that enumerators over ieable1, then ieable2. Each element
            is passed to the filter which can decide if the element should be returned by
            the enumerator or not. The filter can also change the element (map).
            </summary>
            <param name="filter">can be null</param>
            <param name="context">passed to filter</param>
        </member>
        <member name="T:System.Compiler.MultiEnumerator">
            <summary>
            Serial composition of two enumerators.  Enumerating with a
            multi-enumerator is equivalent to enumerating with the first enumerator,
            and next with the second one.  Implements the full <c>IEnumerable</c>
            interface.  Aliases to the enumerators are sequentially composed are
            internally stored and used by the encapsulating multi-enumerator.
            </summary>
        </member>
        <member name="M:System.Compiler.MultiEnumerator.#ctor(System.Collections.IEnumerator,System.Collections.IEnumerator,System.Compiler.EnumeratorFilter,System.Object)">
            <summary>
            Creates a <c>MultiEnumerator</c> that serially chains the two
            enumerators passed as arguments.
            </summary>
        </member>
        <member name="T:System.Compiler.UnionEnumerable">
            <summary>
            Union enumerator over two <c>IEnumerable</c> objects. Each key is visited only once
            </summary>
        </member>
        <member name="T:System.Compiler.UnionEnumerator">
            <summary>
            Union composition of two enumerators.  Enumerating with a
            multi-enumerator is equivalent to enumerating over the union of the elements in
            the first and second enumerator.
            </summary>
        </member>
        <member name="M:System.Compiler.UnionEnumerator.#ctor(System.Collections.IEnumerable)">
            <summary>
            Creates a <c>UnionEnumerator</c> over both given enumerators.
            </summary>
        </member>
        <member name="T:System.Compiler.WorkStack">
            <summary>
            Stack-based implementation of IWorkList.
            </summary>
        </member>
        <member name="T:System.Compiler.WorkList">
            <summary>
            Queue-based implementation of IWorkList.
            </summary>
        </member>
        <member name="T:System.Compiler.Compare">
            <summary>
            Returns 0 if x and y are equal, less than 0 if x is less than y and greater than 0 if x is greater than y
            </summary>
        </member>
        <member name="T:System.Compiler.IGraphNavigator">
            <summary>
            Interface for navigating into a graph.
            </summary>
        </member>
        <member name="M:System.Compiler.IGraphNavigator.NextNodes(System.Object)">
            <summary>
            Returns the nodes that can be reached from <c>node</c> by
            navigating one level along the graph edges.
            </summary>
        </member>
        <member name="M:System.Compiler.IGraphNavigator.PreviousNodes(System.Object)">
            <summary>
            Returns the nodes that can be reached from <c>node</c> by
            navigating one level AGAINST the graph edges (i.e., from edge
            target to the edge source).
            </summary>
        </member>
        <member name="T:System.Compiler.UnionGraphNavigator">
            <summary>
            Navigator for the graph obtained by unioning two graphs.
            </summary>
        </member>
        <member name="M:System.Compiler.UnionGraphNavigator.#ctor(System.Compiler.IGraphNavigator,System.Compiler.IGraphNavigator)">
            <summary>
            Constructs a navigator into a graph which is the union of two graphs
            (where the graphs are seen as edge sets).
            </summary>
            <param name="nav1">Navigator for the first graph.</param>
            <param name="nav2">Navigator for the second graph.</param>
        </member>
        <member name="M:System.Compiler.UnionGraphNavigator.NextNodes(System.Object)">
            <summary>
            In a union graph, the list of successors of a node includes its successors in
            the first graph followed by its successors in the second graph.
            </summary>
        </member>
        <member name="M:System.Compiler.UnionGraphNavigator.PreviousNodes(System.Object)">
            <summary>
            In a union graph, the list of predecessors of a node includes the its predecessors in
            the first graph followed by its predecessors in the second graph.
            </summary>
        </member>
        <member name="T:System.Compiler.BackwardGraphNavigator">
            <summary>
            Navigator for an inversed graph.  The successors (i.e., <c>NextNodes</c>)
            of a node are the predecessors of the node in the original graph.  Analogously
            for the predecessors.
            </summary>
        </member>
        <member name="M:System.Compiler.BackwardGraphNavigator.#ctor(System.Compiler.IGraphNavigator)">
            <summary>
            Constructs a <c>BackwardGraphNavigator</c> that reverses an
            <c>IGraphNavigator</c>.
            </summary>
            <param name="navigator">The navigator that is reversed.</param>
        </member>
        <member name="M:System.Compiler.FilteredGraphNavigator.#ctor(System.Compiler.ISet,System.Compiler.IGraphNavigator)">
            <summary>
            Only nodes in given set are considered part of the graph.
            </summary>
        </member>
        <member name="T:System.Compiler.SccNavigator">
            <summary>
            Navigator in a component graph (an acyclic graph of ISCCs).
            </summary>
        </member>
        <member name="M:System.Compiler.GraphUtil.TopologicallySortGraph(System.Compiler.DSetFactory,System.Collections.IEnumerable,System.Compiler.IGraphNavigator)">
            <summary>
            Topologically sorts the graph rooted in <c>roots</c> and described by
            <c>nav</c>. Throws a <c>CyclicGraphException</c> if the graph contains
            a cycle. Otherwise, returns a topologically sorted list of the graph nodes. 
            The returned list is in ascending order: it starts with the nodes that don't
            have any out-arc (i.e., arcs going out of them) and ends with the nodes
            that don't have any in-arcs (i.e., arcs going into them).  If the navigator
            works in constant time, the topological sort works in time linear with the
            number of nodes plus the number of edges. 
            
            </summary>
        </member>
        <member name="M:System.Compiler.GraphUtil.TopologicallySortComponentGraph(System.Compiler.DSetFactory,System.Collections.IEnumerable)">
            <summary>
            Topologically sorts a component graph: a graph whose nodes are the
            strongly connected components of the original graph (such a graph is
            clearly acyclic). Calls the full-fledged TopSortComponentGraph with
            the standard <c>ISCCNavigator</c>.
            
            </summary>
            <param name="roots">The set of the root SCCs, only the SCCs reacheable
            from these roots will be considered by the topological sort.</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.GraphUtil.SearchDepthFirst(System.Collections.IEnumerable,System.Compiler.IGraphNavigator,System.Compiler.DNodePredicate,System.Compiler.DNodeVisitor,System.Compiler.DNodeVisitor,System.Compiler.DNodeVisitor)">
            <summary>
            DFS traversal of the (sub)graph rooted in a set of nodes.
            </summary>
            <param name="roots">Roots of the traversed subgraph. The subgraph
            rooted in the first root will be traversed in dfs order; next, if
            the second root wasn't reached yet, the subgraph rooted in it will
            be traversed in dfs order and so on. The order of
            the roots is given by the corresponding <c>IEnumerator</c>.</param>
            <param name="navigator">Navigator that describes the graph structure.</param>
            <param name="avoid">Encountered nodes that satisfy this predicate will be
            ignored by the DFS traversal (together with their attached arcs). <c>null</c>
            corresponds to the predicate that is always false (i.e., no encountered node
            will be ignored).</param>
            <param name="new_subgraph_visitor">Visitor for the root node of each
            new subgraph: the roots (see the roots parameter)
            are explored in order; if a root node has not been already reached
            by the dfs traversal of the previous roots, <c>new_subgraph_visitor</c>
            will be called on it, and next the subgraph rooted in it will be dfs
            traversed.</param>
            <param name="begin_visitor">Node visitor to be called when a node is reached
            for the first time by the DFS traversal. <c>null</c> corresponds to no
            visitor.</param>
            <param name="end_visitor">Node visitor to be called when the exploration of
            a node has finished. <c>null</c> corresponds to no visitor.</param>
        </member>
        <member name="M:System.Compiler.GraphUtil.dfs(System.Collections.IEnumerable,System.Compiler.IGraphNavigator,System.Compiler.DNodePredicate,System.Compiler.DNodeVisitor,System.Compiler.DNodeVisitor)">
            <summary>
            Convenient <c>dfs</c> function.  Call the full <c>dfs</c> function
            with new_subgraph_visitor set to <c>null</c>.
            </summary>
        </member>
        <member name="M:System.Compiler.GraphUtil.bfs(System.Collections.IEnumerable,System.Compiler.IGraphNavigator,System.Compiler.DNodePredicate,System.Compiler.DNodeVisitor,System.Compiler.DEdgeVisitor)">
            <summary>
            Does a breadth first traversal of the given graph
            </summary>
            <param name="roots">The roots of the traversal.</param>
            <param name="avoid">If not null, is a predicate to avoid certain nodes</param>
            <param name="visitRoot">If not null, called for each root that is not avoided.</param>
            <param name="visitEdge">Called for each edges in the bf traversal, i.e., only for edges going to unvisited nodes.</param>
        </member>
        <member name="T:System.Compiler.GraphUtil.ReversePostOrder">
            <summary>
            Compute ordering on graph 
            </summary>
        </member>
        <member name="T:System.Compiler.ContractSerializer">
            <summary>
            ContractSerializer is used to write a serialized form of method and type contracts
            into custom attributes. Currently, it just creates the serialized form as a string
            which must be retrieved externally and stored in a custom attribute.
            Note that the serialization should happen before the contracts are normalized.
            Evenutally, I suppose this should be called in a separate pass before Normalizer
            is called. Currently, Checker serializes each contract (and stores it in a custom
            attribute).
            </summary>
        </member>
        <member name="M:System.Compiler.ContractSerializer.VisitField(System.Compiler.Field)">
            <summary>
            Used to print the field name from a member binding, nothing more
            </summary>
        </member>
        <member name="M:System.Compiler.ContractSerializer.VisitMethod(System.Compiler.Method)">
            <summary>
            Used to print the method name, nothing more
            </summary>
        </member>
        <member name="M:System.Compiler.CciHelper.IsVirtual(System.Compiler.MethodCall)">
            <summary>
            Predicate determines if a particular call is virtual or non virtual
            </summary>
            <param name="call">The call to test</param>
            <returns>true if virtual.</returns>
        </member>
        <member name="M:System.Compiler.CciHelper.IsOut(System.Compiler.Parameter)">
            <summary>
            Checks whether a specific parameter is an "out" parameter.
            </summary>
            <param name="parameter">Parameter to test.</param>
            <returns>True if "out" parameter.</returns>
        </member>
        <member name="M:System.Compiler.CciHelper.IsPopStatement(System.Compiler.Statement)">
            <summary>
            Checks whether a given CciHelper statement encodes an MSIL Pop instruction.
            The correctness of this method depends heavily on what Herman does in the CciHelper reader ...
            </summary>
            <param name="stat">Statement to check.</param>
            <returns><c>true</c> iff <c>stat</c> encodes an MSIL Pop instruction.</returns>
        </member>
        <member name="M:System.Compiler.CciHelper.GetThis(System.Compiler.Method)">
            <summary>
            Find the This node in the method body if method is an instance method.
            </summary>
            <param name="method">Method for which we find the This node</param>
            <returns>The This node or null if method is not instance.</returns>
        </member>
        <member name="T:System.Compiler.Declarer">
            <summary>
            Walks the statement list of a Block gathering information from declarations for use by forward references. Does not recurse into nested blocks.
            This visitor is instantiated and called by Looker.
            </summary>
        </member>
        <member name="F:System.Compiler.Declarer.scope">
            <summary>Maps identifiers to Metadata nodes (eg. varDecl.Name -> field).</summary>
        </member>
        <member name="F:System.Compiler.Declarer.targetFor">
            <summary>Maps labels (Identifiers) to the corresponding labeled blocks (single statements are promoted to blocks for this purpose).
            Needed to keep local variable and labels in separate namespaces.</summary>
        </member>
        <member name="F:System.Compiler.Declarer.localLabels">
            <summary>A subset of targetFor that maps only labels (Identifiers) declared in the current block. Needed to check for duplicates.</summary>
        </member>
        <member name="F:System.Compiler.Declarer.labelList">
            <summary>A list of all the labels encountered by Declarer.</summary>
        </member>
        <member name="M:System.Compiler.Declarer.VisitBlock(System.Compiler.Block,System.Compiler.Class,System.Compiler.TrivialHashtable,System.Compiler.IdentifierList)">
            <summary>
            Walks the statement list of the given block gathering information from declarations for use by forward references. Does not recurse into nested blocks.
            </summary>
            <param name="block">The block whose declarations are to be processed</param>
            <param name="scope">Maps identifiers to Metadata nodes (eg. Fields).</param>
            <param name="targetFor">Maps labels (Identifiers) to the corresponding labeled blocks (single statements are promoted to blocks for this purpose).</param>
            <param name="labelList">A list of all the labels encountered by Declarer.</param>
        </member>
        <member name="T:System.Compiler.Scanner">
            <summary>
            Scans individual source lines and provides coloring and trigger information about tokens.
            </summary>
        </member>
        <member name="T:System.Compiler.IScanner">
            <summary>
            Scans individual source lines and provides coloring and trigger information about tokens.
            </summary>
        </member>
        <member name="M:System.Compiler.IScanner.SetSource(System.String,System.Int32)">
            <summary>
            Used to cheaply (re)initialize the scanner before scanning a small portion of text, such as single source line for syntax coloring purposes
            </summary>
            <param name="source">The source text portion to be scanned. May not be null.</param>
            <param name="offset">The index of the first character to be scanned. Must be a valid index into source.</param>
        </member>
        <member name="M:System.Compiler.IScanner.ScanTokenAndProvideInfoAboutIt(System.Compiler.TokenInfo,System.Int32@)">
            <summary>
            Scan the next token and fill in syntax coloring details about it in tokenInfo.
            </summary>
            <param name="tokenInfo">Keeps information about token.</param>
            <param name="state">Keeps track of scanner state. In: state after last token. Out: state after current token.</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.Scanner.SetSource(System.String,System.Int32)">
            <summary>
            Used to cheaply (re)initialize the scanner before scanning a small portion of text, such as single source line for syntax coloring purposes
            </summary>
            <param name="source">The source text portion to be scanned. May not be null.</param>
            <param name="offset">The index of the first character to be scanned. Must be a valid index into source.</param>
        </member>
        <member name="M:System.Compiler.Scanner.ScanTokenAndProvideInfoAboutIt(System.Compiler.TokenInfo,System.Int32@)">
            <summary>
            Scan the next token and fill in syntax coloring details about it in tokenInfo.
            </summary>
            <param name="tokenInfo">Keeps information about token.</param>
            <param name="state">Keeps track of scanner state. In: state after last token. Out: state after current token.</param>
            <returns></returns>
        </member>
        <member name="T:System.Compiler.TokenInfo">
            <summary>
            Records the source position of a token, along with information about the syntactic significance of the token.
            </summary>
        </member>
        <member name="T:System.Compiler.TokenTrigger">
            <summary>
              If token has one or more triggers associated with it, it may  fire one of the following actions when it is typed in a smart editor:
                MemberSelect - a member selection tip window
                TriggerMatchBraces - highlight matching braces
                TriggerMethodTip - a method tip window
            
              The triggers exist for speed reasons: the fast scanner determines when the slow parser might be needed. 
              The MethodTip trigger is subdivided in four other triggers. It is the best to be as specific as possible;
              it is better to return ParamStart than just Param (or just MethodTip) 
              </summary>*
        </member>
        <member name="F:System.Compiler.TokenTrigger.None">
            <summary>No editor action when this token is encountered.</summary>
        </member>
        <member name="F:System.Compiler.TokenTrigger.MemberSelect">
            <summary>Display a member selection list</summary>
        </member>
        <member name="F:System.Compiler.TokenTrigger.MatchBraces">
            <summary>Hightlight a matching pair of braces or similar delimiter pairs</summary>
        </member>
        <member name="F:System.Compiler.TokenTrigger.MethodTip">
            <summary>Display semantic information when the pointer hovers over this token</summary>
        </member>
        <member name="F:System.Compiler.TokenTrigger.ParamNext">
            <summary>Display information about the method parameter corresponding to the call argument following this token</summary>
        </member>
        <member name="M:System.Compiler.TypeSystem.IsBetterMatch(System.Compiler.TypeNode,System.Compiler.TypeNode,System.Compiler.TypeNode)">
            <summary>
            Returns true if conversion from t3 to t1 exists and is better (closer) than the conversion from t3 to t2
            Call this only if both conversions exist.
            </summary>
        </member>
        <member name="T:System.Compiler.Partitioner">
            <summary>
            Partitions IR into separate composition regions
            Composers are compiler extensions that are given responsibility for individual regions
            </summary>
        </member>
        <member name="T:System.Compiler.AnalysisException">
            <summary>
            This is for general errors happend in the control flow graph analysis.
            </summary>
        </member>
        <member name="F:System.Compiler.Analyzer.compilation">
            <summary>
            Current compilation being analyzed.
            </summary>
        </member>
        <member name="F:System.Compiler.Analyzer.typeSystem">
            <summary>
            Type system for the compilation unit.
            </summary>
        </member>
        <member name="F:System.Compiler.Analyzer.debug">
            <summary>
            Turn the debug information on?
            </summary>
        </member>
        <member name="F:System.Compiler.Analyzer.analyzerDebugSymbol">
            <summary>
            Debugging switch.
            </summary>
        </member>
        <member name="F:System.Compiler.Analyzer.PreprocessorDefinedSymbols">
            <summary>
            Commandline switches.
            </summary>
        </member>
        <member name="F:System.Compiler.Analyzer.NonNullChecking">
            <summary>
            Implications from command line switches (with defaults)
            </summary>
        </member>
        <member name="F:System.Compiler.Analyzer.cfgRepository">
            <summary>
            Repository that stores the cfgs that has been built.
            
            Since building Control Flow Graph is destructive, we need to keep it for later use.
            </summary>
        </member>
        <member name="M:System.Compiler.Analyzer.GetCFG(System.Compiler.Method)">
            <summary>
            Get the correct CFG for the method.
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.Analyzer.errorSeverity(System.Compiler.ErrorNodeList)">
            <summary>
            return the level of the most severe error. 
            </summary>
            <param name="errors"></param>
            <returns></returns>
        </member>
        <member name="F:System.Compiler.Analyzer.CodeIsWellFormed">
            <summary>
            True if compilation had no errors so far, meaning the trees are well formed and we 
            can build CFGs.
            </summary>
        </member>
        <member name="M:System.Compiler.Analyzer.#ctor(System.Compiler.TypeSystem,System.Compiler.Compilation)">
            <summary>
            Constructor.
            </summary>
            <param name="t">The type system for the compilation.</param>
            <param name="c">The complication being analyzed.</param>
        </member>
        <member name="M:System.Compiler.Analyzer.Analyze(System.Compiler.Method)">
            <summary>
            Analyze the given method.
            </summary>
            <param name="method"></param>
        </member>
        <member name="M:System.Compiler.Analyzer.languageSpecificAnalysis(System.Compiler.Method)">
            <summary>
            Language specific flow analysis.
            </summary>
            <param name="method"></param>
        </member>
        <member name="M:System.Compiler.Analyzer.generalAnalysis(System.Compiler.Method)">
            <summary>
            Put general analysis targeting to general IL properties.
            </summary>
            <param name="method"></param>
        </member>
        <member name="M:System.Compiler.Analyzer.VisitMethod(System.Compiler.Method)">
            <summary>
            Visit each method, start the analysis.
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="T:System.Compiler.ObservationalPurityVerifier">
            <summary>
            For a given method, using its CFG to found out all alias for fields, and 
            modified.
            </summary>
        </member>
        <member name="T:System.Compiler.ObservationalPurityInstructionVisitor">
            <summary>
            Visit each instruction, check whether the modification is autorized.
            </summary>
        </member>
        <member name="T:System.Compiler.PathWrapper">
            <summary>
            A version of System.IO.Path that does not throw exceptions.
            </summary>
        </member>
        <member name="M:System.Compiler.MathematicalLattice.AtMost(System.Compiler.MathematicalLattice.Element,System.Compiler.MathematicalLattice.Element)">
            <summary>
            Returns true if a &lt;= this.
            </summary>
        </member>
        <member name="T:System.Compiler.MathematicalLattice.Element">
            <summary>
             An element of the lattice.  This class should be derived from in any
             implementation of MathematicalLattice.
            </summary>
        </member>
        <member name="M:System.Compiler.IEGraph.AssumeEqual(System.Compiler.ISymValue,System.Compiler.ISymValue)">
            <summary>
            Assumes v1 == v2
            </summary>
        </member>
        <member name="M:System.Compiler.IEGraph.IsEqual(System.Compiler.ISymValue,System.Compiler.ISymValue)">
            <summary>
            Returns true if v1 == v2
            </summary>
        </member>
        <member name="M:System.Compiler.IEGraph.Eliminate(System.Compiler.IUniqueKey,System.Compiler.ISymValue[])">
            <summary>
            Removes the mapping from the egraph. Semantically equivalent to setting 
            the corresponding term to a Fresh symbolic value.
            </summary>
        </member>
        <member name="M:System.Compiler.IEGraph.Join(System.Compiler.IEGraph)">
            <summary>
            Merge two EGraphs. Result is null if result is no different than this.
            </summary>
        </member>
        <member name="M:System.Compiler.IEGraph.Functions(System.Compiler.ISymValue)">
            <summary>
            return the set of unary function symbols f, such that f(symval) = sv' exists in
            the egraph.
            </summary>
            <param name="symval"></param>
        </member>
        <member name="M:System.Compiler.IEGraph.EqTerms(System.Compiler.ISymValue)">
            <summary>
            Return set of equivalent terms to this symbolic value
            </summary>
        </member>
        <member name="P:System.Compiler.IEGraph.Item(System.Compiler.IUniqueKey,System.Compiler.ISymValue[])">
            <summary>
            getter returns sv, such that sv == function(args)
            
            setter sets function(args) == value, is equivalent to Eliminate(f, args), followed by
            assume (f(args) == value)
            </summary>
            <param name="function"></param>
            <param name="args"></param>
        </member>
        <member name="P:System.Compiler.IEGraph.Item(System.Compiler.ISymValue)">
            <summary>
            Associates symval with an abstract value.
            
            getter returns current association or Top
            setter sets current association (forgetting old association)
            </summary>
        </member>
        <member name="P:System.Compiler.IEGraph.Constants">
            <summary>
            return the set of constant function symbols in this egraph
            </summary>
        </member>
        <member name="F:System.Compiler.EGraph.forwMap">
            <summary>
            Used to represent equalities among symbolic values
            </summary>
        </member>
        <member name="M:System.Compiler.EGraph.#ctor(System.Compiler.EGraph)">
            <summary>
            Copy constructor
            </summary>
            <param name="from"></param>
        </member>
        <member name="T:System.Compiler.EGraph.DoubleTable">
            <summary>
            Used to represent the mapping of pairs of symbolic values to the merged symvalue
            </summary>
        </member>
        <member name="T:System.Compiler.CodeFlattener">
            <summary>
            Transforms the nested CCI representation into a flat one.
            
            More precisely it does 2 things
            - It turns nested block structures into a 2 level structure, the method body is a block consisting of blocks. These
              2nd level blocks only contain statements, not nested blocks. All branch targets are to a block in the 2nd level.
              
            - All statements are simplified to three address codes, by splitting complicated expressions so that they push their
              result onto the stack, whereas the continuation pops it off the stack.
              
            In order to correctly deal with nested dup expressions which appear when the input is not read in
            from an external dll, but is the output of the compiler, we need to use an explicit stack model.
            Consider the following problem:
            
               Construct(Delegate, [ local0, BinaryExpr(ldvirtfn, dup, Test.M) ]
               
            The dup instruction acts on the local0, which is the first argument to the constructor. Previously,
            we would try to use this local0 directly, without stacking it. Now we have to stack everything.
            
            Stacking everything has the undesirable side effect that data flow analyses that do branch refinement have
            a hard time updating information about tests, since the tests always involve stack variables.
            </summary>
        </member>
        <member name="T:System.Compiler.EmptyVisitor">
            <summary>
            Visitor that doesn't implement any Visit method
            (throws new ApplicationException("unimplemented") instead.)
            Good if all you want to do is dispatch some specific processing for each node type,
            without going deep into the recursive data structure.  Throwing an exception for
            unimplemented things is also useful for catching the untreated cases.
            </summary>
        </member>
        <member name="F:System.Compiler.CodeFlattener.expandAllocations">
            <summary>
            When true, an allocation is split into a separate memory alloc, followed by an explicit constructor call.
            </summary>
        </member>
        <member name="M:System.Compiler.CodeFlattener.MakeFlat(System.Compiler.Method,System.Boolean)">
            <summary>
            Flatens the code of the method <c>method</c>.  Leaves the CCI representation of <c>method</c> intact.
            
            Returns a mutated copy.
            
            if <c>expandAllocations</c> is true, then Construct expressions are expanded into a separate allocation and separate
            constructor call.
            
            Important! don't forget to adjust handler block boundaries as well
            </summary>
        </member>
        <member name="F:System.Compiler.CodeFlattener.orig2newBlocks">
            <summary>
            Maintains the mapping from original blocks to new blocks so we can adjust branch targets
            </summary>
        </member>
        <member name="F:System.Compiler.CodeFlattener.branchInstructions">
            <summary>
            Used to build up a list of all branch statements, so that in a post pass we can adjust their targets
            using the orig2newBlocks mapping
            </summary>
        </member>
        <member name="F:System.Compiler.CodeFlattener.switchInstructions">
            <summary>
            Used to build up a list of all switch statements, so that in a post pass we can adjust their targets
            using the orig2newBlocks mapping
            </summary>
        </member>
        <member name="F:System.Compiler.CodeFlattener.new_stats">
            <summary>
            To accumulate statements from a block. The transformed statements
            go onto this list.
            </summary>
        </member>
        <member name="F:System.Compiler.CodeFlattener.new_blocks">
            <summary>
            Accumulates the newly created blocks.
            
            </summary>
        </member>
        <member name="F:System.Compiler.CodeFlattener.current_oldBlock">
            <summary>
            Holds either null, or the current old block that must be mapped to the
            next dynamically created new block in the map.
            
            Note: Because a nested block can appear as the first statement of
            a block, we have to be careful. There can be multiple outstanding oldBlocks
            that need to be mapped to the first generated block.
            
            We do this by the following invariant:
            Every block expansion starts with a call to FlattenBlock
             The FlattenBlock stack activation frame keeps track of the prior current_oldBlock 
             and stores the new current oldBlock.
             At the end of FlattenBlock, the prior_oldBlock is mapped to the same new block
             as the oldBlock on which FlattenBlock was called.
            </summary>
        </member>
        <member name="M:System.Compiler.CodeFlattener.EndStatementList">
            <summary>
            Invariant: whenever during the traversal, we find that we need to start a new block
            (because we reach a block that could be the target of a branch),
            we have to take the new_stats StatementList and if non-empty, create a new block from it
            and put it onto the new_blocks list. new_stats is then initialized with a new emtpy list.
            
            We also have to update the orig2newblock map, using the current_oldBlock as the key and the
            newly created block as the target. If we update the map, we null out the current_oldBlock.
            </summary>
        </member>
        <member name="M:System.Compiler.CodeFlattener.UpdateBlockMap(System.Compiler.Block@,System.Compiler.Block)">
            <summary>
            if oldBlock != null, then we need to update the blockMap to map oldBlock to newBlock
            and set oldBlock to null.
            
            POST: oldBlock == null
            </summary>
        </member>
        <member name="M:System.Compiler.CodeFlattener.FlattenBlock(System.Compiler.Block)">
            <summary>
            Can be called to recursively flatten a block from the following places:
            1. From within a block on a nested block
            2. From within a BlockExpression
            3. From the toplevel method body block
            
            Because of 2 and 3, we may have a pending list of statements in new_stats that belong
            to the previous block. Thus we first need to end that block, then start the new one.
            
            Furthermore, since the old block could be a branch target, we also must update the 
            orig2newBlock map once we generated the first block within this flattening.
            
            Every block expansion starts with a call to FlattenBlock
             The FlattenBlock stack activation frame keeps track of the prior current_oldBlock 
             and stores the new current oldBlock.
             At the end of FlattenBlock, the prior_oldBlock is mapped to the same new block
             as the oldBlock on which FlattenBlock was called.
             
             POST: this.current_oldBlock == null.
            </summary>
            <param name="block"></param>
        </member>
        <member name="M:System.Compiler.CodeFlattener.AdjustBranches">
            <summary>
            Called once after we handled all blocks (by MakeFlat)
            </summary>
        </member>
        <member name="M:System.Compiler.CodeFlattener.simplify_addressof_operand(System.Compiler.Expression)">
            <summary>
            
            </summary>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitThis(System.Compiler.This)">
            <summary>
            Unify all occurrences of This
            </summary>
            <param name="This"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitBase(System.Compiler.Base)">
            <summary>
            BIG FIXME for CCI. Base should not occur here, since it just means "this" after
            normalization.
            </summary>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitConstruct(System.Compiler.Construct)">
            <summary>
            </summary>
            <param name="cons">Cloned</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitConstructArray(System.Compiler.ConstructArray)">
            <summary>
            </summary>
            <param name="consArr">Cloned</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitExpressionStatement(System.Compiler.ExpressionStatement)">
            <summary>
            </summary>
            <param name="expr_stat">Cloned</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitExpressionList(System.Compiler.ExpressionList)">
            <summary>
            </summary>
            <param name="expressions">Cloned</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitIndexer(System.Compiler.Indexer)">
            <summary>
            </summary>
            <param name="indexer">Cloned</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitMemberBinding(System.Compiler.MemberBinding)">
            <summary>
            </summary>
            <param name="memberBinding">Cloned</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitMethodCall(System.Compiler.MethodCall)">
            <summary>
            
            </summary>
            <param name="call">Cloned</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitReturn(System.Compiler.Return)">
            <summary>
            
            </summary>
            <param name="Return">Cloned</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitSwitchInstruction(System.Compiler.SwitchInstruction)">
            <summary>
            
            </summary>
            <param name="switchInstruction">Cloned</param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitThrow(System.Compiler.Throw)">
            <param name="Throw">Cloned</param>
        </member>
        <member name="M:System.Compiler.CodeFlattener.VisitUnaryExpression(System.Compiler.UnaryExpression)">
            <summary>
            </summary>
            <param name="expression">Cloned</param>
        </member>
        <member name="T:System.Compiler.StackVariable">
            <summary>
            Class for the stack variables introduced by the stack removal transformation.
            </summary>
        </member>
        <member name="M:System.Compiler.StackVariable.#ctor(System.Int32,System.Compiler.TypeNode)">
            <summary>
            Create a stack variable for a given stack depth and a specific type.
            </summary>
            <param name="depth"></param>
            <param name="type"></param>
        </member>
        <member name="M:System.Compiler.StackVariable.NEWTemp(System.Compiler.TypeNode)">
            <summary>
            Bogus stack variable useful for desugaring of NEWwithCONSTRUCT.
            We hope we'll never go beyond 50000 stack vars.  Actually, it would be great if we could analyze
            method with >50000 stack variables !
            </summary>
        </member>
        <member name="M:System.Compiler.StackVariable.NEWValueTemp(System.Compiler.TypeNode)">
            <summary>
            Bogus stack variable useful for desugaring of NEWwithCONSTRUCT for Value types.
            This variable represents the contents of the newly created value object, which does not
            get allocated in the heap.
            </summary>
        </member>
        <member name="T:System.Compiler.FlattenerTest">
            <summary>
            To test the code flattener, this visitor takes a method and expands the body expressions to 
            add a nested BlockExpression around every sub expression it encounters.
            
            It also adds a nested block for the first statement in each block.
            
            The idea is that we can then undo this expansion with the CodeFlattener.
            </summary>
        </member>
        <member name="T:System.Compiler.CfgCachingFactory">
            <summary>
            <c>ICFGFactory</c> with caching.
            </summary>
        </member>
        <member name="M:System.Compiler.CfgCachingFactory.ComputeControlFlowGraph(System.Compiler.Method)">
            <summary>
            Get the CFG for a method.  Results are cached, so getting the CFG for the same
            method twice will return the same CFG object.
            </summary>
            <param name="method">Method whose CFG we want to get.</param>
            <returns>CFG for <c>method</c>; cached.</returns>
        </member>
        <member name="M:System.Compiler.CfgCachingFactory.Flush(System.Compiler.Method)">
            <summary>
            Flushes the CFG for <c>method</c> from the internal cache.
            </summary>
            <param name="method">Method whose CFG we want to flush from the cache.</param>
        </member>
        <member name="T:System.Compiler.LowLevelControlFlowGraph">
            <summary>
            	/// Control Flow Graph (CFG) for a method.  The CFG is an extra layer on top of
            the CCI representation; all the CFG related information (flow edges) is maintained into
            the CFG object.  Both the normal and the exceptional flows are modeled by the CFG.
            
            <p>THE UNDERLYING CCI REPRESENTATION IS MUTATED *A LOT* BY THE "FINALLY" BLOCK DUPLICATION
            AND THE STACK REMOVAL TRANSFORMATION.  YOU SHOULD MANUALLY CLONE IT BEFORE CONSTRUCTING
            THE CFG IF YOU NEED IT; E.G, IF YOU NEED TO WRITE THE CODE BACK TO DISK.  CFG IS USED FOR
            PROGRAM ANALYSIS ONLY, NOT FOR CODE GENERATION.</p>
            
            <p>A Control Flow Graph is basically an oriented graph whose nodes are the
            basic blocks from the method body; the edges reflect the normal and the exceptional flow
            of control (the exceptional flow is the flow that occurs when an exception is raised).
            In addition to the basic blocks of the original method, three more blocks are added:</p>
            
            <ul>
            <li>a special <c>CFG.NormalExitBlock</c> that is a successor for all the basic block
            terminated in a return instruction; it is a merge point for all the
            paths on the normal (intra-procedural) control flow.</li>
            <li>a special <c>CFG.ExcpExitBlock</c> that is the default handler for all the uncaught
            exceptions; it is a merge point for all the paths on the intra-procedural execution
            paths that may terminate with an uncaught exception.</li>
            <li>a special <c>CFG.ExitBlock</c> that is the only successor of the aforementioned
            normal and the exception exit.  Its only normal flow predecessor is the special block
            for the normal exit and its only exceptional flow predecessor is the special block
            for the exceptional exit. </li>
            </ul>
            
            <p>
            If you are given a block and want to know if it's the [normal/excp] exit of its
            method, all you have to do is use the appropriate "is" test
            (e.g. "block is CFG.NormalExitBlock"). If you have the CFG, and want to know its
            [normal/excp] exit, you just have to query the appropriate method.</p>
            
            <p>
            NOTE:
            If an analysis is interested in the result for the normal flow, then it can retrieve
            the result of the dataflow equations for the normal exit point. Similarly, if an analysis
            is interested in the result for the exceptional flow, then it can retrieve the result
            of the dataflow equations for the exceptional exit point.  Finally, if the distinction between
            normal/exceptional flow is not important, the "unified" exit point can be used instead.</p>
            
            </summary>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.#ctor(System.Compiler.Method,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Constructs the Control Flow Graph for <c>method</c>.
            If the code for <c>method</c> is unavailable, throw an <c>UnavailableCodeException</c>
            (a constructor cannot return an error code).  If the code for <c>method</c> is empty
            (abstract method), thrown a <c>NoCodeException</c>.  Otherwise, examine the CciHelper
            representation of the method code and construct the CFG.
            </summary>
            <param name="method">Method whose CFG will be constructed.</param>
            <param name="duplicateFinallyBlocks">If <c>true</c>, the finally blocks will be duplicated and you'll obtain a real
            CFG.  Otherwise, you'll have to manually deal with the finally blocks that are traversed by each
            "leave" instruction.  HIGHLY RECOMMENDED!</param>
            <param name="eliminateEvaluationStack">If <c>true</c>, <c>StackRemovalTransf.Process</c> will be called
            to remove the stack manipulating operations. See more commends in the class
            <c>StackRemovalTransf</c>. RECOMMENDED!</param>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.#ctor(System.Compiler.Method)">
            <summary>
            Convenient CFG constructor: by default, the finally blocks are duplicated to obtain
            a real CFG and the stack removal transformation is applied.
            </summary>
            <param name="method">Method whose CFG is produced.</param>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.AddCatchStatements(System.Collections.IEnumerable,System.Collections.IList)">
            <summary>
            Add explicit Catch statements at beginning of each catch handler.
            If a Catch handler has a next handler that differs from the ExceptionHandler enclosing the handler block, then we split 
            the Catch statement into a separate block.
            
            Special case for Finally handlers that have been turned into catch handlers by the finally-elimination:
            - Move the special instruction FINALLYVARPREFIX&lt;n&gt; = pop() to the header.
            </summary>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.BuildContinuationMap(System.Compiler.Block[])">
            <summary>
            Construct a continuation description for each block
            </summary>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.examine_real_excp_flow(System.Compiler.Method,System.Compiler.ExceptionHandlerList,System.Compiler.StatementList,System.Collections.IList@)">
            <summary>
            Computes the ExceptionHandler for each block and the chaining of exception handlers.
            Note: 
              Filter handlers are currently treated as starting at the filter expression
              and the endfilter is like a fall through into the actual handler.
            </summary>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.Entry">
            <summary>
            Return the entry point of this CFG.  This is the point where the execution
            of the underlying method starts.
            </summary>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.Exit">
            <summary>
            Return the special block for the exit point of this CFG.
            </summary>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.NormalExit">
            <summary>
            Return the special block for the normal exit of this CFG.
            </summary>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.ExcpExit">
            <summary>
            Return the special block for the exceptional exit of this CFG.
            </summary>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.Blocks">
            <summary>
            Returns an array containing all the blocks from this CFG.
            You should never mutate this array.
            </summary>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.ContainingBlock(System.Compiler.Statement)">
            <summary>
            If statement is part of this cfg, returns the containing block, otherwise null
            </summary>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.SortedSCCs">
            <summary>
            Returns the topologically sorted list of the strongly connected components of blocks
            (according to the control flow).  The first SCC in the returned list is the one that
            contains the method entry block.
            </summary>
            <returns>Top-sort list of SCCs of blocks from <c>this</c> CFG (method entry first).</returns>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.Succ(System.Compiler.Block)">
            <summary>
            Returns the successors of <c>block</c> on both normal and exceptional flow.
            Iterating over the returned <c>IEnumerable</c> is equivalent to iterating first
            over the normal successors and next over the exception flow successors.
            </summary>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.NormalSucc(System.Compiler.Block)">
            <summary>
            Returns the normal successors of <c>block</c>.
            You should never mutate this array.
            </summary>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.ExceptionHandler(System.Compiler.Block)">
            <summary>
            Returns the closest enclosing handler of a particular block
            where control goes if an exception is raised inside <c>block</c>.  
            </summary>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.Pred(System.Compiler.Block)">
            <summary>
            Returns the predecessors of <c>block</c> on both normal and exceptional flow.
            Iterating over the returned <c>IEnumerable</c> is equivalent to iterating first
            over the normal predecessors and next over the exception flow predecessors.
            </summary>
            <param name="block"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.NormalPred(System.Compiler.Block)">
            <summary>
            Returns the normal predecessors of <c>block</c>.
            You should never mutate the returned array.
            </summary>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.ExcpPred(System.Compiler.Block)">
            <summary>
            Returns the predecessors of <c>block</c> on the exceptional flow of control.
            In C# terms, if <c>block</c> is the beginning of an exception handler, these are
            the blocks protected by that exception handler.  Otherwise, this array has
            length 0.
            You should never mutate the returned array.
            </summary>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.ExcpSucc(System.Compiler.Block)">
            <summary>
            Returns the successor of <c>block</c> on the exceptional flow of control.
            You should never mutate the returned array.
            </summary>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.HandlerThatStartsAtBlock(System.Compiler.Block)">
            <summary>
            Returns the ExceptionHandler that starts at <c>block</c>, if any; null otherwise.
            This is useful when trying to see what kind of exceptions can arrive in <c>block</c>
            </summary>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.HandlerContainingBlock(System.Compiler.Block)">
            <summary>
            Useful for finding which handler a block belongs to. This may be needed for
            determining rethrow information.
            </summary>
            <remarks>This is NOT the handler protecting the block!</remarks>
            <param name="block"></param>
            <returns>Start block of handler containing the given block. Otherwise null,
            if given block is not part of any handler.</returns>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.FinallyCloningChain(System.Compiler.Block)">
             <summary>
             FOR DEBUG ONLY:
             <p>
             Returns the list of "leave" instructions whose processing created a specific block.
             Returns an empty <c>IEnumerable</c> if an original block (not a clone) is sent as
             argument.  In the enumeration, the innermost leave instructions come first.</p>
            
             Returns <c>null</c> if block is not a clone.
             
             NOTE: as we don't have source context info for branching instructions, we manipulate
             the blocks of the leave's instead of the leave instructions themselves.
             </summary>
             <param name="block"></param>
             <returns></returns>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.OrigBlock(System.Compiler.Block)">
            <summary>
            FOR DEBUG ONLY:
            <p/>
            Returns the original block that, possibly through some cloning, produced a specific block.
            Transitively walks over the copy2orig map until the original block is found.  Acts as an
            identity function for an original block.
            </summary>
            <param name="block"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.IsDead(System.Compiler.Block)">
            <summary>
            Block is unreachable from entry
            </summary>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.StackDepth(System.Compiler.Block)">
            <summary>
            Returns the stack depth at the beginning of block <c>block</c>.
            </summary>
            <param name="block">Block that we are interested in.</param>
            <returns>Stack depth at the beginning of <c>block</c>.</returns>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.Display(System.IO.TextWriter)">
            <summary>
            Simplified CFG pretty printer: all the info printers are set to null.
            </summary>
            <param name="tw"></param>
        </member>
        <member name="M:System.Compiler.LowLevelControlFlowGraph.Display(System.IO.TextWriter,System.Compiler.Block[],System.Compiler.DGetBlockInfo,System.Compiler.DGetBlockInfo,System.Compiler.DGetStatInfo)">
            <summary>
            CFG pretty-printer.  For each block, this menthod
            calls <c>pre_printer</c>c(if non-null),
            prints the normal/excp. successors,
            the code of the block, the normal/excp. predecessors and finally calls
            <c>post_printer</c>.  A useful use of the pre and post printers is the
            debugging of a flow-sensitive analysis.
            </summary>
            <param name="tw">Where to print.</param>
        </member>
        <member name="T:System.Compiler.LowLevelControlFlowGraph.UnavailableCodeException">
            <summary>
            Exception thrown when trying to construct the CFG
            of a method whose code is unavailable.
            </summary>
        </member>
        <member name="T:System.Compiler.LowLevelControlFlowGraph.UnsupportedCodeException">
            <summary>
            Exception thrown when trying to construct the CFG
            of a method whose code contains some unsuppored features,
            e.g. Filter exception handlers.
            </summary>
        </member>
        <member name="T:System.Compiler.LowLevelControlFlowGraph.NoCodeException">
            <summary>
            Exception thrown when trying to construct the CFG
            of a method without code (e.g., abstract methods).
            </summary>
        </member>
        <member name="T:System.Compiler.LowLevelControlFlowGraph.FinallyBlockDuplicator.SpecialBranch">
            <summary>
            When we duplicate a finally body and graft it into the normal path,
            the jump that goes to this new code must remain a 'leave' rather
            than a 'branch', because we must retain the semantics that 'leave'
            clears the evaluation stack before jumping. However, to correctly
            do recursive copies (i.e. try/finally inside a finally), we need
            to remember that these leaves are not actual leaves. To mark them,
            we derive a new class from Branch and use an 'is' test to look for 
            this class.
            </summary>
        </member>
        <member name="T:System.Compiler.LowLevelControlFlowGraph.ISpecialBlock">
            <summary>
            "Marker" interface: only the three artificial blocks introduced by the CFG implement it.
            You should not try to implement it in any of your classes.
            </summary>
        </member>
        <member name="T:System.Compiler.LowLevelControlFlowGraph.Continuation">
            <summary>
            Captures how a block continues. Currently only for normal control flow.
            </summary>
        </member>
        <member name="T:System.Compiler.MethodHeader">
            <summary>
            Special statement to identify the starting point of a method.
            This is the definition point for all the method parameters. (this way, each variable is
            defined by one or more statements).
            </summary>
        </member>
        <member name="M:System.Compiler.MethodHeader.#ctor(System.Compiler.Method)">
            <summary>
            Creates the MethodHeader statement for <c>method</c>.
            </summary>
        </member>
        <member name="F:System.Compiler.MethodHeader.parameters">
            <summary>
            List of method parameters, including This if the method is non-static.
            This is grabbed from the method code, if it's not find there but the method is non static,
            we create one to enforce the invariant that each non-static method has a This paremeter.
            </summary>
        </member>
        <member name="F:System.Compiler.MethodHeader.method">
            <summary>
            Method that <c>this</c> MethodHeader belongs to; useful in case you want to garb more information.
            </summary>
        </member>
        <member name="T:System.Compiler.Unwind">
            <summary>
            Special statement to identify the exception exit point of a method.
            </summary>
        </member>
        <member name="T:System.Compiler.CodeDomTranslator">
            <summary>
            Walks a System.CodeDom.CodeCompileUnit and produces a corresponding CompilationUnit.
            </summary>
        </member>
        <member name="M:System.Compiler.CodeDomTranslator.Translate(System.Compiler.Compiler,System.CodeDom.CodeCompileUnit,System.Compiler.Module,System.Compiler.ErrorNodeList)">
            <summary>
            Walks the supplied System.CodeDom.CodeCompileUnit and produces a corresponding CompilationUnit.
            Enters declarations into the supplied Module and errors into the supplied ErrorNodeList. 
            Calls back to the supplied compiler to resolve assembly references and to create appropriate documents for code snippets.
            </summary>
            <param name="compiler">Called upon to resolve assembly references and to create Documents for snippets.</param>
            <param name="compilationUnit">The root of the CodeDOM tree to be translated into an IR CompileUnit.</param>
            <param name="targetModule">The module or assembly to which the compilation unit will be compiled.</param>
            <param name="errorNodes">Errors in the CodeDOM tree that are found during translation are added to this list.</param>
            <returns></returns>
        </member>
        <member name="T:System.Compiler.Compiler">
            <summary>
            This class provides compilation services for various clients such as command line compilers,
            in memory compilers hosted by some application such as Visual Studio, and CodeDom clients such
            as ASP .NET. 
            </summary>
        </member>
        <member name="M:System.Compiler.Compiler.ConstructSymbolTable(System.Compiler.Compilation,System.Compiler.ErrorNodeList)">
            <summary>
            Parses all of the CompilationUnitSnippets in the given compilation, ignoring method bodies. Then resolves all type expressions.
            The resulting types can be retrieved from the module in compilation.TargetModule. The base types, interfaces and 
            member signatures will all be resolved and on an equal footing with imported, already compiled modules and assemblies.
            </summary>
        </member>
        <member name="M:System.Compiler.Compiler.ResolveSymbolTable(System.Compiler.Compilation,System.Compiler.ErrorNodeList)">
            <summary>
            Resolves all type expressions in the given (already parsed) compilation.
            The base types, interfaces and member signatures will all be on an equal footing with signatures from imported, 
            already compiled modules and assemblies.
            </summary>
        </member>
        <member name="M:System.Compiler.Compiler.UpdateSymbolTable(System.Compiler.Compilation,System.Compiler.Document,System.Compiler.Document,System.Compiler.SourceChangeList,System.Compiler.ErrorNodeList)">
            <summary>
            Updates the specified symbol table, substituting changedDocument for originalDocument.
            Fires the OnSymbolTableUpdate event before returning (provided that changes occurred to member signatures).
            </summary>
            <param name="symbolTable">The symbol table to update or replace.</param>
            <param name="originalDocument">The document of a CompilationUnit instance in compilation.</param>
            <param name="changedDocument">A new version of originalDocument.</param>
            <param name="changes">A list of the changes made to orignalDocument in order to derive changedDocument.</param>
            <param name="errors">A list to which errors detected during the update must be added.</param>
            <returns>The given symbol table instance, suitably updated, or a new symbol table that replaces the given table.</returns>
        </member>
        <member name="M:System.Compiler.Compiler.UpdateSymbolTable(System.Compiler.Compilation,System.Compiler.Compilation,System.Compiler.Compilation,System.Compiler.MemberList,System.Compiler.ErrorNodeList)">
            <summary>
            Updates the specified symbol table, given a list of changed members from another Compilation instance
            on which it has a dependency. Does nothing if the symbol table does not refer to any of the changed members.
            Fires the OnSymbolTableUpdate event before returning (provided that changes occurred to member signatures).
            </summary>
            <param name="symbolTable">The symbol table to update or replace.</param>
            <param name="originalReference">The compilation instance to which the given symbol table currently refers.</param>
            <param name="changedReference">The compilation instance to which the updated symbol table must refer to instead of to originalReference.</param>
            <param name="changedMembers">A list of the members defined in originalReference that have changed.</param>
            <param name="errors">A list to which errors detected during the update must be added.</param>
            <returns>The given symbol table instance, suitably updated, or a new symbol table that replaces the given table.</returns>
        </member>
        <member name="M:System.Compiler.Compiler.ApplyDefaultContractAssemblies(System.Compiler.Module)">
            <summary>
            For each referenced assembly Xyz, looks for a contract assembly named Xyz.Contracts.dll in our installation directory.
            </summary>
        </member>
        <member name="M:System.Compiler.Compiler.CompileParseTree(System.Compiler.Compilation,System.Compiler.ErrorNodeList)">
            <summary>
            Translates the given parse tree into a normalized form that is suitable for writing out as CLI IL.
            This translation process is normally accomplished
            by a series of visitors that are language specific derivations of base class visitors provided by
            the Cci code generation framework. The base Compiler class does not call the visitors directly, in
            order to provide language implementations with the opportunity to add or replace visitors.
            </summary>
            <param name="compilation">An IR tree that represents the parse tree for the entire compilation.</param>
            <param name="errorNodes">Errors encountered during the compilation are appended to this list.</param>
        </member>
        <member name="M:System.Compiler.Compiler.CompileParseTree(System.Compiler.Node,System.Compiler.Scope,System.Compiler.Module,System.Compiler.ErrorNodeList)">
            <summary>
            Translates the given parse tree node into a corresponding normalized node.
            If the node is a type node or contains type nodes, the normalized versions of the type nodes
            are added to the target module. Expected to be mainly useful for compiling expressions. 
            </summary>
            <param name="node">An IR tree that represents a parse tree</param>
            <param name="scope">A symbol table for resolving free variables in the parse tree</param>
            <param name="targetModule">A module to which types found in the IR tree are added</param>
            <param name="errorNodes">Errors encountered during the compilation should be appended to this list</param>
        </member>
        <member name="E:System.Compiler.Compiler.OnSymbolTableUpdate">
            <summary>
            This event happens just before UpdateSymbolTable returns, provided that UpdateSymbolTable made any changes.
            </summary>
        </member>
        <member name="T:System.Compiler.Compiler.SymbolTableUpdateEventHandler">
            <summary>
            Called when a symbol table has been updated. The updateSpecification argument specifies how
            the original Compilation instance (symbol table) differs from the updated symbol table. The changedMembers argument
            provides a list of all member signatures that have changed as a result of the recompilation.
            </summary>
        </member>
        <member name="T:System.Compiler.IStronglyConnectedComponent">
            <summary>
            Interface for Strongly Connected Methods.
            </summary>
        </member>
        <member name="M:System.Compiler.IStronglyConnectedComponent.FullToString">
            <summary>
            Detailed text representation of <c>this</c> StronglyConnectedComponent.
            <c>ToString</c> will return just a unique text id of the StronglyConnectedComponent,
            while the detailed text representation will be produced by
            <c>FullToString</c>
            </summary>
            <returns></returns>
        </member>
        <member name="P:System.Compiler.IStronglyConnectedComponent.Nodes">
            <summary>
            Returns the nodes contained into <c>this</c> StronglyConnectedComponent.
            </summary>
        </member>
        <member name="P:System.Compiler.IStronglyConnectedComponent.Size">
            <summary>
            Returns the number of nodes in <c>this</c> StronglyConnectedComponent.
            </summary>
            <returns></returns>
        </member>
        <member name="P:System.Compiler.IStronglyConnectedComponent.NextComponents">
            <summary>
            Returns the SCCs that are end points of the arcs that starts in
            <c>this</c> StronglyConnectedComponent, i.e., the successors of <c>this</c> StronglyConnectedComponent in the
            component graph. Does not contain <c>this</c> StronglyConnectedComponent.
            </summary>
        </member>
        <member name="P:System.Compiler.IStronglyConnectedComponent.PreviousComponents">
            <summary>
            Returns the SCCs that are starting points for arcs that end
            in <c>this</c> StronglyConnectedComponent, i.e., the predecessors of <c>this</c> StronglyConnectedComponent
            in the component graph. Does not contain <c>this</c> StronglyConnectedComponent.
            </summary>
        </member>
        <member name="P:System.Compiler.IStronglyConnectedComponent.ContainsCycle">
            <summary>
            Checks whether <c>this</c> StronglyConnectedComponent is a cycle, i.e., if it has more than
            one node or it has a single node which points to itself.  The only
            StronglyConnectedComponent that does not contain a cycle is a StronglyConnectedComponent composed of a single node
            which doesn't point to itself.
            </summary>
            <returns></returns>
        </member>
        <member name="T:System.Compiler.StronglyConnectedComponent">
            <summary>
            StronglyConnectedComponent is a full implementation of the interface <c>ISCC</c>.
            It comes with a producer static method that constructs the
            component graph for a given graph. 
            </summary>
        </member>
        <member name="M:System.Compiler.StronglyConnectedComponent.FullToString">
            <summary>
            Detailed text representation of <c>this</c> StronglyConnectedComponent.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.StronglyConnectedComponent.ToString">
            <summary>
            Simplified text representation for debug purposes: "StronglyConnectedComponent" + numeric id.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.StronglyConnectedComponent.ConstructSCCs(System.Collections.IEnumerable,System.Compiler.IGraphNavigator)">
            <summary>
            Use the <c>nav</c> navigator to explore the graph rooted in the
            objects from the <c>roots</c> set, decomposes it into strongly
            connected components. Returns the set of strongly connected components.
            </summary>
        </member>
        <member name="T:System.Compiler.Passer">
            <summary>
            A passer is used to pass through nodes without acting on them.  All callback will
            be called for each child node of the passed-through node.
            </summary>
        </member>
        <member name="T:System.Compiler.Evaluator">
            <summary>
            Executes an IR, typically an expression tree, resulting in a literal node representing the computed value of the IR.
            This class is intended for use by a debugger expression evaluator, as well as partial evaluation (constant folding) during compilation.
            </summary>
        </member>
        <member name="T:System.Compiler.Environment">
            <summary>
            
            </summary>
        </member>
        <member name="T:System.Compiler.PureEvaluator">
            <summary>
            Has no side effects on any Cci structures, just evaluates a single node if possible.
            </summary>
        </member>
        <member name="M:System.Compiler.PureEvaluator.EvalBinaryExpression(System.Compiler.Literal,System.Compiler.Literal,System.Compiler.BinaryExpression)">
            <summary>
            Tries to return the literal obtained from constant folding the binary expression whose literal arguments are given
            by opnd1 and opnd2. If any of these are null, the result is null. If the binary expression cannot be constant folded
            the result is also null.
            </summary>
            <param name="opnd1">null or literal corresponding to binary expression's 1st constant folded argument</param>
            <param name="opnd2">null or literal corresponding to binary expression's 2nd constant foleded argument</param>
            <param name="binaryExpression">the original binary expression</param>
            <returns>null, or constant folded literal</returns>
        </member>
        <member name="T:System.Compiler.Scoper">
            <summary>
            Walks a CompilationUnit and creates a scope for each namespace and each type.
            The scopes are attached to the corresponding instances via the ScopeFor hash table.
            </summary>
        </member>
        <member name="T:System.Compiler.Resolver">
            <summary>
            Walks an IR, mutuating it by resolving overloads and inferring expression result types
            Following this, all Indexers, NameBindings, QualifiedIdentifiers and non builtin operators have been replaced by MemberBindings or MethodCalls 
            and every expression has its Type field filled in.
            (Exception 1: Indexers whose objects are tuples or single dimensional zero based arrays are not replaced.)
            (Exception 2: When resolution fails the NameBindings and QualifiedIdentifiers are not replaced. Checker uses them to generate appropriate errors.)
            </summary>
        </member>
        <member name="F:System.Compiler.Resolver.insideAssertion">
            <summary>
            Are we inside an assert statement, assume statement, loop invariant, requires clause, or ensures clause, but not in an object invariant?
            </summary>
        </member>
        <member name="M:System.Compiler.Resolver.GetBestMatch(System.Compiler.MemberList,System.Compiler.ExpressionList,System.Compiler.TypeNode[],System.Compiler.TypeNodeList,System.Compiler.Member,System.Compiler.TypeNode@)">
            <summary>
            Go through eligible members (+ bestSoFar) returning the one with the best match to argTypes.
            Returns null if there is no single best match. Sets bestParamTypes to a signature
            that any other member (from a base class) has to equal or better to best overall.
            </summary>
        </member>
        <member name="T:System.Compiler.TransferFunctionResult">
            <summary>
            Result of a transfer function: pair of two IDataFlowInfo's - one for the
            normal control flow and one for the exceptional control flow.  I wish
            C# had tuple types: why should we name a simple tuple?
            </summary>
        </member>
        <member name="T:System.Compiler.ICoreDataFlowSolver">
            <summary>
            Core DataFlow solver interface.  A core solver is one that provides results only
            for the beginning of each block: this is what is needed for the actual fixed point algorithm.
            Once the fixed point is solved, an additional layer
            can always apply the transfer functions inside the blocks to retrieve the info
            for each program point. However, some analyses might not need this: e.g., an analysis
            that is interested only in the result at the end of the method, or a checker that fails
            fast by throwing an exceptions or validates some code by finishing normally.  Those
            analysis won't use any extra layer and waste memory for storing data that is never required.
            
            <p>NOTE: the reason we prefer the beginning and not the end of a block is that once we know
            a block, the info for its beginning and the transfer functions, we can easily retrieve the info
            for any point inside the block.  Doing this with the info attached to the end of a block would
            also require the CFG (in order to get the predecessors, take their info, and merge it).  Moreover,
            further complications would arise due to the fact that we can have successors both on the
            normal and the exceptional flow of control (e.g., consider a finally block).</p>
            </summary>
        </member>
        <member name="T:System.Compiler.CreateAndRunSolver">
            <summary>
            Factory for a core dataflow solver; the usual factory pattern, this time implemented with a delegate.
            The motivation for its existence is presented in the comments attached to the <c>DataFlowSolver</c>
            constructor.
            </summary>
        </member>
        <member name="T:System.Compiler.SccCoreDataFlowSolver">
            <summary>
            Core dataflow solver based on the "iterating on the CFG strongly connected components" algorithm.
            (see Principles of Program Analysis, Nielsen &amp; Nielsen).
            </summary>
        </member>
        <member name="F:System.Compiler.SccCoreDataFlowSolver.Factory">
            <summary>
            Producer of SCC data flow solvers.
            </summary>
        </member>
        <member name="M:System.Compiler.SccCoreDataFlowSolver.#ctor(System.Compiler.LowLevelControlFlowGraph,System.Compiler.AnalysisSpec,System.Compiler.IDataFlowInfo)">
            <summary>
            Constructor.
            </summary>
            <param name="cfg">Control Flow Graph of the analyzed method.</param>
            <param name="an">Specification of the analysis specification.</param>
            <param name="initialInfo"><c>DataFlowInfo</c> for the CFG entry point
            (method start).</param>
        </member>
        <member name="T:System.Compiler.IDataFlowSolver">
            <summary>
            Interface for a complete data flow Solver.  A complete dataflow Solver is
            one that given a dataflow analysis specification and a CFG, can answer queries
            about the dataflow info in any point inside the CFG.
            </summary>
        </member>
        <member name="M:System.Compiler.IDataFlowSolver.GetPreInfoStat(System.Compiler.Statement)">
            <summary>
            Returns the IDataFlowInfo attached to the program point right before a statement.
            </summary>
        </member>
        <member name="M:System.Compiler.IDataFlowSolver.GetPostInfoStat(System.Compiler.Statement)">
            <summary>
            Returns the IDataFlowInfo attached to the program point right after a statement,
            on the normal control flow.
            </summary>
        </member>
        <member name="M:System.Compiler.IDataFlowSolver.GetExcpPostInfoStat(System.Compiler.Statement)">
            <summary>
            Returns the IDataFlowInfo attached to the program point right after a statement,
            on the exceptional control flow.
            </summary>
        </member>
        <member name="M:System.Compiler.IDataFlowSolver.GetPostInfo(System.Compiler.Block)">
            <summary>
            Returns the IDataFlowInfo attached to the program point right after a block,
            on the normal control flow.  Equivalent to GetPostInfo(last_statement(block)).
            </summary>
        </member>
        <member name="M:System.Compiler.IDataFlowSolver.GetExcpPostInfo(System.Compiler.Block)">
            <summary>
            Returns the IDataFlowInfo attached to the program point right after a block,
            on the exceptional control flow.  NOT equivalent to GetExcpPostInfo(last_statement(block)).
            This is the merging of GetExcpPostInfo(stat), forall statement stat in block, because
            the exceptional control flow edges going out of a block are the factorization of the
            exceptional control flow coming from each of the block statements.
            </summary>
        </member>
        <member name="T:System.Compiler.DataFlowSolver">
            <summary>
            Generic implementation of the IDataFlowSolver interface: given a factory for core dataflow Solvers,
            and an instance of the monotonic dataflow framework, it constructs a complete dataflow Solver, backed
            by a core Solver produced by that factory. 
            
            <p>The implementation of this class makes few assumptions about the core dataflow Solver.
            It requires the following:</p>
            
            <ul>
            <li>the core Solver produces a fixed point for the analysis equations (least fixed point
            if possible, but any fixed point should be fine for correctness)
            </li>
            <li>the core Solver caches the result of the GetPreInfo method; this way, the complete flower avoids caching it again.
            </li>
            </ul>
            
            Once this requirements are satisfied, for each block, this class does an intra-block analysis: it starts with the
            dataflow info before the block and "chains" the transfer functions for the block statements.  "Chaining" means
            composition on the normal flow and accumulation on the exceptional flow: the dataflow info for the exceptional termination
            of the block is the accumulation of all the exceptional dataflow info along the way.
            </summary>
        </member>
        <member name="M:System.Compiler.DataFlowSolver.#ctor(System.Compiler.CreateAndRunSolver,System.Compiler.LowLevelControlFlowGraph,System.Compiler.AnalysisSpec,System.Compiler.IDataFlowInfo)">
            <summary>
            Constructs a complete dataflow Solver based on a core dataflow Solver provided by a specific
            core Solver factory. The reason for requiring a core Solver factory instead of a core Solver
            is that we want to make sure that the underlying core Solver uses the same analysis specification
            as this complete Solver
            </summary>
            <param name="Solver_fact">Factory for the underlying core Solvers.</param>
            <param name="cfg">Control Flow Graph of the analyzed method.</param>
            <param name="an">DataFlow Analysis Specification: transfer functions and merge operation.</param>
            <param name="initial_info">DataFlow information for the CFG entry point.</param>
        </member>
        <member name="T:System.Compiler.Looker">
            <summary>
            Walks an IR, mutuating it by replacing identifier nodes with NameBinding/Block nodes representing the
            members/labels the identifiers resolve to, and replacing type expressions with the types they refer to.
            Most of the logic here deals with maintaining and querying the scope chain.
            </summary>
        </member>
        <member name="F:System.Compiler.Looker.scopeFor">
            <summary>
            Used to track the appropriate scope for each type
            </summary>
        </member>
        <member name="M:System.Compiler.Looker.VisitBaseClassReference(System.Compiler.Class,System.Boolean)">
            <summary>
            Turns ClassExpression Class.BaseClass into a real class, with substitution of template parameters.
            Returns false if the ClassExpression does not bind to a class. 
            Passing false for interfaceIsError will suppress the generation of an error message.
            This can be used to check if the first expression in an interface list is a base class.
            </summary>
        </member>
        <member name="T:System.Compiler.DGetStatInfo">
            <summary>
            Prints some information attached to a statement.
            </summary>
        </member>
        <member name="T:System.Compiler.DGetBlockInfo">
            <summary>
            Prints some information attached to a block.
            </summary>
        </member>
        <member name="T:System.Compiler.CodePrinter">
            <summary>
            Helper class for printing an ASCII representation of the representation
            produced by CciHelper.
            </summary>
        </member>
        <member name="M:System.Compiler.CodePrinter.b2s(System.Compiler.Block)">
            <summary>
            Convenient version of <c>b2s</c>: <c>b2id</c> is null.
            </summary>
        </member>
        <member name="F:System.Compiler.CodePrinter.BlockShortPrinter">
            <summary>
            Convenient wrapping of <c>CodePrinter.b2s</c>; used in conjunction with
            <c>DataStructUtil.IEnum2String</c> for printing collections of blocks.
            It would have been some much easier to have a nice Block.ToString() method ...
            </summary>
        </member>
        <member name="M:System.Compiler.CodePrinter.b2s(System.Compiler.Block,System.Collections.Hashtable)">
            <summary>
            Returns a string id for "block" based on the integer identified b2id[block].
            If <c>b2id</c> is null, then the block hashcode is used as the block identifier.
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.CodePrinter.PrintMethod(System.IO.TextWriter,System.Compiler.Method)">
            <summary>
            Method pretty-printer.  Note: the method blocks are identified by their 0-based index in the
            method list of blocks.
            </summary>
            <param name="tw">Where to print.</param>
            <param name="method">The method to be printed</param>
        </member>
        <member name="M:System.Compiler.CodePrinter.MethodSignature(System.Compiler.Method)">
            <summary>
            Returns a string describing the signature of <c>method</c>: return type, method name, 
            argument types and names (param names are not really part of the method signature, but
            it's nice to know them anyway). 
            </summary>
        </member>
        <member name="M:System.Compiler.CodePrinter.FullName(System.Compiler.Method)">
            <summary>
            Fully qualified name of <c>method</c>: fullname(declaring_class).method_name
            </summary>
        </member>
        <member name="M:System.Compiler.CodePrinter.PrintBlock(System.IO.TextWriter,System.Compiler.Block,System.Compiler.DGetStatInfo,System.Collections.Hashtable)">
            <summary>
            Block pretty-printer.
            </summary>
            <param name="tw">Where to print.</param>
            <param name="block">What to print</param>
            <param name="get_stat_info">Provider of statement specific information;
            if non-null, it will be called after printing each statement, and its result
            printed too.</param>
            <param name="b2id">Map block -&gt; int identifier; if <c>null</c>, then the block
            UniqueKey is used as block id.</param>
        </member>
        <member name="M:System.Compiler.CodePrinter.PrintBlock(System.IO.TextWriter,System.Compiler.Block)">
            <summary>
            Convenient version of the block pretty-printer, with no statement
            specific information and block.UniqueKey used as block id.
            </summary>
            <param name="tw">Where to print.</param>
            <param name="block">What to print.</param>
        </member>
        <member name="M:System.Compiler.CodePrinter.StatementToString(System.Compiler.Statement)">
            <summary>
            Convenient statement pretty-printer; the <c>b2id</c> map is <c>null</c>.
            </summary>
        </member>
        <member name="M:System.Compiler.CodePrinter.SourceContextToString(System.Compiler.Statement)">
            <summary>
            Returns a textual representation of the source context info attached to statement <c>stat</c>.
            </summary>
            <param name="stat">Statement whose source we're interested in.</param>
            <returns>Textual representation of the source context info for <c>stat</c>.</returns>
        </member>
        <member name="M:System.Compiler.CodePrinter.StatementToString(System.Compiler.Statement,System.Collections.Hashtable)">
            <summary>
            Statement pretty-printer.
            </summary>
            <param name="stat">Statement to print</param>
            <param name="b2id">Map block -> integer id; if <c>null</c>, the block UniqueKey will be used instead.</param>
            <returns>String representation of the statement argument.</returns>
        </member>
        <member name="M:System.Compiler.CodePrinter.ExpressionToString(System.Compiler.Expression)">
            <summary>
            Expression pretty-printer.
            </summary>
            <param name="expr">Expression to print.</param>
            <returns>String representation of the expression argument.</returns>
        </member>
        <member name="T:System.Compiler.NonNullState">
            <summary>
            NonNull states for variables and Objects.
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullState.AssignAVal(System.Compiler.Variable,System.Compiler.NonNullState.Lattice.AVal)">
            <summary>
            Set v to a new value that is abstracted by av
            </summary>
            <param name="v"></param>
            <param name="av"></param>
        </member>
        <member name="M:System.Compiler.NonNullState.AssumeNull(System.Compiler.ISymValue)">
            <summary>
            Adds assumption that sv == null
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullState.AssumeNull(System.Compiler.Variable)">
            <summary>
            Adds assumption that v == null
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullState.AssumeNonNull(System.Compiler.Variable)">
            <summary>
            Adds assumption that v != null
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullState.IsNonNullType(System.Compiler.TypeNode)">
            <summary>
            Check whether a given object is of nonnull type. It will check:
            Variable, Field, return type of Method.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.NonNullState.HavocHeap">
            <summary>
            Assume all accessible locations in the heap are modified.
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullState.Join(System.Compiler.NonNullState,System.Compiler.NonNullState)">
            <summary>
            Returns null, if result of Join is the same as atMerge.
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullState.AssumeFalse(System.Compiler.ISymValue,System.Compiler.NonNullState@)">
            <summary>
            Refines the given state according to the knowledge stored in the egraph about sv
            
            In addition, the state can be null when the knowledge is inconsistent.
            </summary>
            <param name="cv">symbolic value we assume to be null (false)</param>
        </member>
        <member name="M:System.Compiler.NonNullState.AssumeTrue(System.Compiler.ISymValue,System.Compiler.NonNullState@)">
            <summary>
            Refines the given state according to the knowledge stored in the egraph about sv
            
            In addition, the state can be null when the knowledge is inconsistent.
            </summary>
            <param name="cv">symbolic value we assume to be non-null (true)</param>
            <param name="state">state if sv is non-null (true)</param>
        </member>
        <member name="T:System.Compiler.NonNullState.Lattice.AVal">
            <summary>
            Ordering:
            
              A lt B   iff
              
              !A.NonNullimplies !B.NonNull
              
            </summary>
        </member>
        <member name="T:System.Compiler.NonNullChecker">
            <summary>
            The main class for NonNull checking.
            </summary>
        </member>
        <member name="F:System.Compiler.NonNullChecker.iVisitor">
            <summary>
            Current NonNullchecking visitor
            </summary>
        </member>
        <member name="F:System.Compiler.NonNullChecker.currBlock">
            <summary>
            Current block being analyzed.
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullChecker.Check(System.Compiler.TypeSystem,System.Compiler.Method,System.Compiler.Analyzer)">
            <summary>
            Entry point to check a method.
            </summary>
            <param name="t"></param>
            <param name="method"></param>
        </member>
        <member name="M:System.Compiler.NonNullChecker.#ctor(System.Compiler.TypeSystem,System.Compiler.Method)">
            <summary>
            Constructor
            </summary>
            <param name="t"></param>
            <param name="method"></param>
        </member>
        <member name="M:System.Compiler.NonNullChecker.Merge(System.Compiler.CfgBlock,System.Compiler.CfgBlock,System.Compiler.IDataFlowState,System.Compiler.IDataFlowState,System.Boolean@,System.Boolean@)">
            <summary>
            Merge the two states for current block.
            </summary>
            <param name="previous"></param>
            <param name="joinPoint"></param>
            <param name="atMerge"></param>
            <param name="incoming"></param>
            <param name="resultDiffersFromPreviousMerge"></param>
            <param name="mergeIsPrecise"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.NonNullChecker.VisitBlock(System.Compiler.CfgBlock,System.Compiler.IDataFlowState)">
            <summary>
            Implementation of visit Block. It is called from run.
            
            It calls VisitStatement.
            </summary>
            <param name="block"></param>
            <param name="stateOnEntry"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.NonNullChecker.VisitStatement(System.Compiler.CfgBlock,System.Compiler.Statement,System.Compiler.IDataFlowState)">
            <summary>
            It visit individual statement. It is called from VisitBlock.
            
            It will call NonNullInstructionVisitor
            </summary>
            <param name="block"></param>
            <param name="statement"></param>
            <param name="dfstate"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.NonNullChecker.SplitExceptions(System.Compiler.CfgBlock,System.Compiler.IDataFlowState@,System.Compiler.IDataFlowState@)">
            <summary>
            It split exceptions for current handler and the next chained handler.
            
            It will:
            
              If the exception is completely intercepted by current handler, the
              exception will be consumed.
              
              If the exception caught but not completely, both current handler and 
              the next handler will take the states.
              
              If the exception is irrelevant to current caught, the next handler 
              will take over the state. Current handler is then bypassed.
            </summary>
            <param name="handler"></param>
            <param name="currentHandlerState"></param>
            <param name="nextHandlerState"></param>
        </member>
        <member name="T:System.Compiler.NonNullInstructionVisitor">
            <summary>
            Visit each instruction, check whether the modification is autorized.
            </summary>
        </member>
        <member name="F:System.Compiler.NonNullInstructionVisitor.NNChecker">
            <summary>
            Current NonNullChecker
            </summary>
        </member>
        <member name="F:System.Compiler.NonNullInstructionVisitor.reportedErrors">
            <summary>
            Used to avoid repeated error/warning report for the same Node.
            
            Important: This is absolutely necessary, since we are doing fix-point
            Analysis. Bypass this sometimes means hundred's of the same error messages.
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.HandleError(System.Compiler.Statement,System.Compiler.Node,System.Compiler.Error,System.String[])">
            <summary>
            Error handler. Only file a error if it has not been filed yet. 
            
            Requires: the node has proper source context. Otherwise, it does not help.
            </summary>
            <param name="stat"></param>
            <param name="node"></param>
            <param name="error"></param>
            <param name="m"></param>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.CheckReceiver(System.Compiler.Statement,System.Compiler.Variable,System.Compiler.NonNullState)">
            <summary>
            For the possible receiver v, check if it is nonnull. if no, file an proper
            error/warning.
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.#ctor(System.Compiler.NonNullChecker)">
            <summary>
            Constructor.
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.DefaultVisit(System.Compiler.Statement,System.Object)">
            <summary>
            A lot of the pointers are not supported.
            </summary>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.VisitMethodEntry(System.Compiler.Method,System.Collections.IEnumerable,System.Compiler.Statement,System.Object)">
            <summary>
            Method entry. Need to add This pointer. 
            
            Does not have to deal with parameters.
            </summary>
            <param name="method"></param>
            <param name="parameters"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.VisitCopy(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            Copy the source to dest.
            
            If source is nonnull, no problem.
            If source is null and dest is nonnulltype, Error
            If source is possible null and dest is nonnulltype, warning.
            Else, nothing.
            
            Need to maintain proper heap transformation.
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <param name="stat"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.VisitCastClass(System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Variable,System.Compiler.Statement,System.Object)">
            <summary>
            Note: casts don't require a non-null argument. null value casts always succeed.
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.VisitStoreElement(System.Compiler.Variable,System.Compiler.Variable,System.Compiler.Variable,System.Compiler.TypeNode,System.Compiler.Statement,System.Object)">
            <summary>
            Perform 2 checks
            1) array is non-null
            2) if array element type is non-null type, then the new value written must be too.
            </summary>
        </member>
        <member name="M:System.Compiler.NonNullInstructionVisitor.VisitSwitchCaseBottom(System.Compiler.Statement,System.Object)">
            <summary>
            Shouldn't reach this point. The error is handled by the definite assignment analysis. So
            here we treat it as assume(false)
            </summary>
        </member>
        <member name="T:System.Compiler.UnknownInstructionException">
            <summary>
            Exception thrown when an unknown quad is encountered.
            </summary>
        </member>
        <member name="T:System.Compiler.SampleInstructionVisitor">
            <summary>
             Example use of <c>QuadVisitor</c>.  Generates an appropriate string representation
             for each quad.
            </summary>
        </member>
        <member name="M:System.Compiler.SampleInstructionVisitor.GetStringDesc(System.Compiler.Statement)">
            <summary>
            Returns a string representation for each quad.  Throws an exception when encountering
            an unknown quad or an unknown CciHelper pattern.
            </summary>
            <param name="stat"></param>
            <returns></returns>
        </member>
        <member name="T:System.Compiler.InitializedVariables">
            <summary>
            Enapsulation for the variables initilization states.
            The state is an equality graph between locations (for tracking refs) and
            each location is mapped to a two point lattice (top unassigned) (bot assigned).
              
            For References, we keep track of the assignment status of the contents of the location
            by mapping terms of the form
            
               ValueOf(s) to assignment lattice elements as well.
               
            For structs, we additionally keep track of field individual assignment status by tracking
            
               Field(Value(s))
               
            In addition, we keep a single set (not program point specific) of
            variables that were assigned, and one set of variables that were 
            referenced. If we find variables at the end that were assigned, but not
            referenced, we issue the C# warning.
            </summary>
        </member>
        <member name="M:System.Compiler.InitializedVariables.#ctor(System.Compiler.InitializedVariables)">
            <summary>
            Copy Constructor
            </summary>
            <param name="old"></param>
        </member>
        <member name="M:System.Compiler.InitializedVariables.IsAssigned(System.Compiler.ISymValue)">
            <summary>
            Use only for non-struct values.
            </summary>
        </member>
        <member name="M:System.Compiler.InitializedVariables.IsAssigned(System.Compiler.ISymValue,System.Compiler.Struct)">
            <summary>
            Returns null if all fields of the struct are fully assigned, otherwise the field that is not.
            </summary>
        </member>
        <member name="M:System.Compiler.InitializedVariables.IsAssignedRef(System.Compiler.Variable,System.Compiler.Struct)">
            <summary>
            </summary>
            <param name="structType">null if no struct type</param>
        </member>
        <member name="M:System.Compiler.InitializedVariables.NonAssignedRefField(System.Compiler.Variable,System.Compiler.Struct)">
            <summary>
            Like IsAssignedRef, but returns null if true, and a witness field if false.
            </summary>
            <param name="structType">Non-null struct type of variable</param>
        </member>
        <member name="M:System.Compiler.InitializedVariables.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:System.Compiler.InitializedVariables.Dump">
            <summary>
            Required by IDataFlowAnalysis interface.
            </summary>
        </member>
        <member name="P:System.Compiler.InitializedVariables.Variables">
            <summary>
            Returns a canonically sorted list of non-temp variables.
            </summary>
        </member>
        <member name="T:System.Compiler.DefAssignLattice">
            <summary>
            Definite assignment and usage analysis.
            
            Definite assignment is about locations, not values. Thus, we we use egraph as follows:
            
            Variables represent locations, thus the symbolic values in the egraph represent location addresses.
            
            We track the status of these locations (assigned, referenced)
            
            To track pointers to locations, we also keep track of terms of the form Value(loc), representing
            the value stored in the location loc.
            
            Thus, an assignment x = y is represented as Value(sym(x)) := Value(sym(y))
            
            
            
            </summary>
        </member>
        <member name="T:System.Compiler.DefAssignLattice.AVal">
            <summary>
            Ordering:
            
              A lt B   iff
              
              !A.Assigned implies !B.Assigned
              
            </summary>
        </member>
        <member name="T:System.Compiler.MethodDefiniteAssignmentChecker">
            <summary>
            Definite assignment checker.
            </summary>
        </member>
        <member name="F:System.Compiler.MethodDefiniteAssignmentChecker.iVisitor">
            <summary>
            Current instruction visitor.
            </summary>
        </member>
        <member name="F:System.Compiler.MethodDefiniteAssignmentChecker.currBlock">
            <summary>
            Current Block under analysis.
            </summary>
        </member>
        <member name="F:System.Compiler.MethodDefiniteAssignmentChecker.typeSystem">
            <summary>
            typeSystem. Only used to file errors and warnings.
            </summary>
        </member>
        <member name="F:System.Compiler.MethodDefiniteAssignmentChecker.currentMethod">
            <summary>
            Current method being analyzed.
            </summary>
        </member>
        <member name="F:System.Compiler.MethodDefiniteAssignmentChecker.reportedErrors">
            <summary>
            This is a repository that stores errors that has been reported.
            
            It is used basicly as a set. Only used in DefiniteAssignmentInstructorVisitor.check. 
            If the invariant that all variables have their source context holds, then the key in this set 
            could be individual variables. 
            Not I use stat instead. 
            </summary>
        </member>
        <member name="F:System.Compiler.MethodDefiniteAssignmentChecker.exitState">
            <summary>
            The exit state. Used to check assigned but not refereneced variables.
            </summary>
        </member>
        <member name="M:System.Compiler.MethodDefiniteAssignmentChecker.Check(System.Compiler.TypeSystem,System.Compiler.Method,System.Compiler.Analyzer)">
            <summary>
            Entry point of the check. 
            
            It create a new instance of the checker, and run the checker on the given method.
            </summary>
            <param name="t"></param>
            <param name="method"></param>
        </member>
        <member name="M:System.Compiler.MethodDefiniteAssignmentChecker.SplitExceptions(System.Compiler.CfgBlock,System.Compiler.IDataFlowState@,System.Compiler.IDataFlowState@)">
            <summary>
            Since we push the state from each block to the exception handler, we don't need to chain them here.
            </summary>
        </member>
        <member name="T:System.Compiler.ControlFlowGraph">
            <summary>
            CFG wrapper around CCI/Alex Cfgs
            </summary>
        </member>
        <member name="M:System.Compiler.CfgBlock.HandlersMatching(System.Compiler.TypeNode)">
            <summary>
            Returns a list of CfgBlock that are handlers of the current block, handling an exception
            of the given type, or a subtype thereof.
            </summary>
            <param name="exception">Type of exception thrown. It is assumed that any actual subtype could be thrown</param>
            <returns>All handlers that could apply directly to this exception.
             In addition, if the method might not handle it, then the ExceptionExit block is
            part of this list.</returns>
        </member>
        <member name="M:System.Compiler.CfgBlock.GetValue(System.Int32)">
            <summary>
            Method so we can take a delegate, since property getters cannot be used.
            </summary>
        </member>
        <member name="M:System.Compiler.CfgBlock.GetEnumerator">
            <summary>
            Returns all statements in block.
            </summary>
            <returns></returns>
        </member>
        <member name="P:System.Compiler.CfgBlock.Item(System.Int32)">
            <summary>
            Return statement in block.
            </summary>
        </member>
        <member name="P:System.Compiler.CfgBlock.Length">
            <summary>
            Returns number of statements in block
            </summary>
        </member>
        <member name="T:System.Compiler.Checker">
            <summary>
            Walk IR checking for semantic errors and repairing it so that subsequent walks need not do error checking
            </summary>
        </member>
        <member name="M:System.Compiler.Checker.CheckContractInheritance(System.Compiler.TypeNode)">
            <summary>
            This method checks all of the methods in a class or structure to make sure that
            if the method implements an interface method (either explicitly or implicitly),
            then the contract inheritance rules are not violated.
            
            It also introduces the default expose block around the body of whichever methods
            should get the default.
            </summary>
            <param name="type">The type that will have all of its methods checked.</param>
        </member>
        <member name="M:System.Compiler.Checker.MakeMethodVirtualIfThatWouldMakeItImplementAnInterfaceMethod(System.Compiler.Method)">
             <summary>
            The hidden base method may still end up implementing an interface explicitly implemented by this.currentType.
            Prevent that by marking meth as virtual (and newslot) if that means it gets to implement a local interface method
            </summary>
        </member>
        <member name="M:System.Compiler.Checker.IsLessAccessible(System.Compiler.TypeNode,System.Compiler.TypeNode)">
            <summary>
            returns true if t1 is less accessible than t2
            </summary>
        </member>
    </members>
</doc>
