`/debug+ /d:DEFASSIGN
using System;
class M{
  public static void foo(ref int x)
    requires 0 < x;
    ensures old(x) < x;
  {
    x++;
  }
  public static int Main(){
    var y = 1;
    foo(ref y);
    return y-2;
  }
}
`
`
`/debug+ /d:DEFASSIGN
// class invariant: trivial satisfaction
using System;
namespace N {
  class C {
    invariant true;
  }
  class M { 
    public static int Main(){
      try { new C(); Console.WriteLine("No contract violation"); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }
}
`
No contract violation
`
`/debug+ /d:DEFASSIGN 
// class invariant: trivial violation
using System;
namespace N {
  class C {
    invariant false;
  }
  class M { 
    public static void Main(){
      try {
        new C();
        Console.WriteLine("No contract violation");
      } catch (Microsoft.Contracts.GuardException) {
        Console.WriteLine("Contract violation.");
      }
    }
  }
}
`
Contract violation.
`
`/debug+ /d:DEFASSIGN 
// class invariant: explicit instance field initialization satisfies inv
using System;
using Microsoft.Contracts;
namespace N {

  public class C {
    [SpecPublic] protected int j = 0; // explicit initialization satisfies inv
    invariant j >= 0;
  }
  class M { 
    public static void Main(){
      try { new C(); Console.WriteLine("No contract violation"); }
      catch (Microsoft.Contracts.ContractException) { Console.WriteLine("Contract violation."); }
    }
  }
}
`
No contract violation
`
`/debug+ /d:DEFASSIGN 
// class invariant: explicit instance field initialization violates inv
using System;
using Microsoft.Contracts;
namespace N {
  public class C {
    [SpecPublic] protected int j = -3; // explicit initialization violates inv
    invariant j >= 0;
  }
  class M { 
    public static void Main(){
      try { new C(); Console.WriteLine("No contract violation"); }
      catch (Microsoft.Contracts.GuardException) { Console.WriteLine("Contract violation."); }
    }
  }
}
`
Contract violation.
`
`/debug+ /d:DEFASSIGN 
// class invariant: default instance field initialization satisfies inv
using System;
using Microsoft.Contracts;
namespace N {
  public class C {
    [SpecPublic] protected int j; // default initialization satisfies inv
    invariant j >= 0;
  }
  class M { 
    public static void Main(){
      try { new C(); Console.WriteLine("No contract violation"); }
      catch (Microsoft.Contracts.ContractException) { Console.WriteLine("Contract violation."); }
    }
  }
}
`
No contract violation
`
`/debug+ /d:DEFASSIGN 
// class invariant: default instance field initialization violates inv
using System;
using Microsoft.Contracts;
namespace N {
  public class C {
    [SpecPublic] protected int j; // default initialization violates inv
    invariant j > 0;
  }
  class M { 
    public static void Main(){
      try { new C(); Console.WriteLine("No contract violation"); }
      catch (Microsoft.Contracts.GuardException) { Console.WriteLine("Contract violation."); }
    }
  }
}
`
Contract violation.
`
`/debug+ /d:DEFASSIGN 
// class invariant: default .ctor satisfies inv
using System;
using Microsoft.Contracts;
namespace N {
  public class C {
    [SpecPublic] protected int j;
    invariant j >= 0;
  }
  class M { 
    public static void Main(){
      try { new C(); Console.WriteLine("No contract violation"); }
      catch (Microsoft.Contracts.ContractException) { Console.WriteLine("Contract violation."); }
    }
  }
}
`
No contract violation
`
`/debug+ /d:DEFASSIGN 
// class invariant: default .ctor violates inv
using System;
using Microsoft.Contracts;
namespace N {
  public class C {
    [SpecPublic] protected int j;
    invariant j > 0;
  }
  class M { 
    public static void Main(){
      try { new C(); Console.WriteLine("No contract violation"); }
      catch (Microsoft.Contracts.GuardException) { Console.WriteLine("Contract violation."); }
    }
  }
}
`
Contract violation.
`
`/debug+ /d:DEFASSIGN 
// class invariant: explicit .ctor satisfies inv
using System;
using Microsoft.Contracts;
namespace N {
  public class C {
    [SpecPublic] protected int j;
    invariant j > 0;
    public C() { j = 3; } // explicit .ctor satisfies inv
  }
  class M { 
    public static void Main(){
      try { new C(); Console.WriteLine("No contract violation"); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
    }
  }
}
`
No contract violation
`
`/debug+ /d:DEFASSIGN 
// class invariant: explicit .ctor violates inv
using System;
using Microsoft.Contracts;
namespace N {
  public class C {
    [SpecPublic] protected int j;
    invariant j > 0;
    public C() { j = -3; } // explicit .ctor violates inv
  }
  class M { 
    public static void Main(){
      try { new C(); Console.WriteLine("No contract violation"); }
      catch (Microsoft.Contracts.GuardException) { Console.WriteLine("Contract violation."); }
    }
  }
}
`
Contract violation.
`
`/debug+ /d:DEFASSIGN 
:=3
// class invariant: expose
using System;
using Microsoft.Contracts;
namespace N {

  public class A0 {
    [SpecPublic] protected int j = 0;
    invariant j >= 0;
    // possibly violates inv, but default expose catches it
    public void f(int i) { j = i; }
  }
  public class A1 {
    [SpecPublic] protected int j = 0;
    invariant j >= 0;
    // possibly violates inv, is caught
    [NoDefaultContract]
    public virtual void f(int i) { additive expose (this) { j = i; } }
  }
  public class A2 : A1 {
    // possibly violates inv, is caught
    invariant true;
    [NoDefaultContract]
    public override void f(int i) { additive expose (this) { j = i; } }
  }
  public class A3 : A1 {
    // possibly violates inv, is caught
    invariant true;
    [NoDefaultContract]
    public override void f(int i) { additive expose ((A1) this) { j = i; } }
  }
  class M { 
    public static void Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      try { new A0().f(x); } catch (Microsoft.Contracts.ContractException) { Console.WriteLine("Contract violation."); }
      try { new A1().f(x); } catch (Microsoft.Contracts.ContractException) { Console.WriteLine("Contract violation."); }
      try { new A2().f(x); } catch (Microsoft.Contracts.ContractException) { Console.WriteLine("Contract violation."); }
      try { new A3().f(x); } catch (Microsoft.Contracts.ContractException) { Console.WriteLine("Contract violation."); }
    }
  }
}
`
`
`/debug+ /d:DEFASSIGN 
:=0
// class invariant: expose
using System;
using Microsoft.Contracts;
namespace N {

  public class A0 {
    [SpecPublic] protected int j = 0;
    invariant j >= 0;
    // possibly violates inv, but default expose catches it
    public void f(int i) { j = i; }
  }
  public class A1 {
    [SpecPublic] protected int j = 0;
    invariant j >= 0;
    // possibly violates inv, is caught
    [NoDefaultContract]
    public virtual void f(int i) { additive expose (this) { j = i; } }
  }
  public class A2 : A1 {
    // possibly violates inv, is caught
    invariant true;
    [NoDefaultContract]
    public override void f(int i) { additive expose (this) { j = i; } }
  }
  public class A3 : A1 {
    // possibly violates inv, is caught
    invariant true;
    [NoDefaultContract]
    public override void f(int i) { additive expose ((A1) this) { j = i; } }
  }
  class M { 
    public static void Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      try { new A0().f(x); } catch (Microsoft.Contracts.ContractException) { Console.WriteLine("Contract violation."); }
      try { new A1().f(x); } catch (Microsoft.Contracts.ContractException) { Console.WriteLine("Contract violation."); }
      try { new A2().f(x); } catch (Microsoft.Contracts.ContractException) { Console.WriteLine("Contract violation."); }
      try { new A3().f(x); } catch (Microsoft.Contracts.ContractException) { Console.WriteLine("Contract violation."); }
    }
  }
}
`
`
`/debug+ /d:DEFASSIGN 
:=-3
// class invariant: expose
using System;
using Microsoft.Contracts;
namespace N {

  public class A0 {
    [SpecPublic] protected int j = 0;
    invariant j >= 0;
    // possibly violates inv, but default expose catches it
    // MB: 01/04/2005 -- no more default expose
    public void f(int i) { additive expose (this) { j = i; } }
  }
  public class A1 {
    [SpecPublic] protected int j = 0;
    invariant j >= 0;
    // possibly violates inv, is caught
    [NoDefaultContract]
    public virtual void f(int i) { additive expose (this) { j = i; } }
  }
  public class A2 : A1 {
    // possibly violates inv, is caught
    invariant true;
    [NoDefaultContract]
    public override void f(int i) { additive expose (this) { j = i; } }
  }
  public class A3 : A1 {
    // possibly violates inv, is caught
    invariant true;
    [NoDefaultContract]
    public override void f(int i) { additive expose ((A1) this) { j = i; } }
  }
  class M { 
    public static void Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      Console.WriteLine(1);
      try { new A0().f(x); } catch (Microsoft.Contracts.GuardException) { Console.WriteLine("Contract violation."); }
      Console.WriteLine(2);
      try { new A1().f(x); } catch (Microsoft.Contracts.GuardException) { Console.WriteLine("Contract violation."); }
      Console.WriteLine(3);
      try { new A2().f(x); } catch (Microsoft.Contracts.GuardException) { Console.WriteLine("Contract violation."); }
      Console.WriteLine(4);
      try { new A3().f(x); } catch (Microsoft.Contracts.GuardException) { Console.WriteLine("Contract violation."); }
      Console.WriteLine(5);
    }
  }
}
`
1
Contract violation.
2
Contract violation.
3
4
Contract violation.
5
`
`/debug+ /d:DEFASSIGN
:=3
// method contracts: lots of variations
using System;
using Microsoft.Contracts;

namespace N {

  class C  {
    [SpecPublic]
    protected int j = 0;

    invariant
      j >= 0;

    public virtual int f(int x)
      requires (1/x) > 0;
      requires x >= 0;
      requires j >= 0 otherwise InvalidOperationException;
      requires x > j otherwise new InvalidOperationException("foo");
      ensures j == x;
      ensures old(j + 1) < j * 3;
      throws (InvalidOperationException e) ensures j == 0;
      ensures x > 0; // BUG! Because I'm duplicating post-conditions, it crashes if it encounters a parameter
      ensures result >= 0;
    {
       if ( x == 3 ) { j = x; throw new InvalidOperationException("foo"); }
       if ( x == 5 ) { throw new InvalidOperationException("foo"); }
       return x * x;
    }
  }
  class M { 
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      try { C c = new C(); Console.WriteLine(c.f(x)); Console.WriteLine("No contract violation"); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }
}
`
(21,7): error CS2627: 'N.C.f' : Cannot specify an unchecked exception in a throws clause.
`
`/debug+ /d:DEFASSIGN 
// interface contracts
using System;
using System.Collections;
using Microsoft.Contracts;

namespace N {

  interface IEnumerator {

    [Model] Hashtable /* object -> int */ b {   [Pure] get; }
    [Model] object current {   [Pure] get; }
    [Model] bool isCurrentDefined {   [Pure] get; }

    object Current { get; }

    bool MoveNext()
// BUGBUG: As soon as the repository comes online, the next line should be uncommented.
//      ensures !result || old(b.ContainsKey(current));
      ensures !result || isCurrentDefined;

    void Reset();
 
  }
  class M { 
    public static int Main(){
      return 0;
    }
  }
 
}
`
`
`/debug+ /d:DEFASSIGN 
:=3
// interface contract: explicit implementation of interface method
using System;

namespace N {

  interface I {
    int f(int x)
      requires x > 0;
  }

  class C : I {
    int I.f(int x) { return x; }
  }

  class M { 
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      I o = new C();
      try { Console.WriteLine(o.f(x)); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }

}
`
3
`
`/debug+ /d:DEFASSIGN 
:=3
// interface contract: implicit implementation of interface method
using System;

namespace N {

  interface I {
    int f(int x)
      requires x > 0;
  }

  class C : I {
    public int f(int x) { return x; }
  }

  class M { 
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      I o = new C();
      try { Console.WriteLine(o.f(x)); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }

}
`
3
`
`/debug+ /d:DEFASSIGN 
:=3
// property contract: setter only
using System;

namespace N {

  class C {
    public int f {
      set
        requires value > 0; 
      {
      }
    }
  }

  class M { 
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      C c = new C();
      try { c.f = x; }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }

}
`
`
`/debug+ /d:DEFASSIGN 
:=-3
// property contract: setter only
using System;

namespace N {

  class C {
    public int f {
      set
        requires value > 0; 
      {
      }
    }
  }

  class M { 
    public static void Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      C c = new C();
      try { c.f = x; }
      catch (Microsoft.Contracts.ContractException) { Console.WriteLine("Contract violation."); }
    }
  }

}
`
Contract violation.
`
`/debug+ /d:DEFASSIGN 
:=3
// property contract: setter and getter
using System;

namespace N {

  class C {
    private int i;
    public int f {
      set
        requires value >= 0; 
      { i = value; }
      get
        ensures result > 0;
      { return i; }
    }
  }

  class M { 
    public static void Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      C c = new C();
      try { c.f = x; Console.WriteLine(c.f); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
    }
  }

}
`
3
`
`/debug+ /d:DEFASSIGN 
:=0
// property contract: setter and getter
using System;

namespace N {

  class C {
    private int i;
    public int f {
      set
        requires value >= 0; 
      { i = value; }
      get
        ensures result > 0;
      { return i; }
    }
  }

  class M { 
    public static void Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      C c = new C();
      try { Console.WriteLine(1); c.f = x; Console.WriteLine(2); Console.WriteLine(c.f); Console.WriteLine(3); }
      catch (Microsoft.Contracts.ContractException) { Console.WriteLine("Contract violation."); }
    }
  }

}
`
1
2
Contract violation.
`
`/debug+ /d:DEFASSIGN 
:=-3
// property contract: setter and getter
using System;

namespace N {

  class C {
    private int i;
    public int f {
      set
        requires value >= 0; 
      { i = value; }
      get
        ensures result > 0;
      { return i; }
    }
  }

  class M { 
    public static void Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      C c = new C();
      try { Console.WriteLine(1); c.f = x; Console.WriteLine(2); Console.WriteLine(c.f); Console.WriteLine(3); }
      catch (Microsoft.Contracts.ContractException) { Console.WriteLine("Contract violation."); }
    }
  }

}
`
1
Contract violation.
`
`/debug+ /d:DEFASSIGN 
:=-3
// interface contract: explicit implementation of interface method
using System;

namespace N {

  interface I {
    int f(int x)
      requires x > 0;
  }

  class C : I {
    int I.f(int x) { return x; }
  }

  class M { 
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      I o = new C();
      try { Console.WriteLine(o.f(x)); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }

}
`
Microsoft.Contracts.RequiresException: Precondition 'x > 0' violated from method 'N.C.f(System.Int32)'
   at N.C.N.I.f(Int32 x)
   at N.M.Main(String[] args)
`
`/debug+ /d:DEFASSIGN 
:=-3
// interface contract: implicit implementation of interface method
using System;

namespace N {

  interface I {
    int f(int x)
      requires x > 0;
  }

  class C : I {
    public int f(int x) { return x; }
  }

  class M { 
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      I o = new C();
      try { Console.WriteLine(o.f(x)); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }

}
`
Microsoft.Contracts.RequiresException: Precondition 'x > 0' violated from method 'N.C.f(System.Int32)'
   at N.C.f(Int32 x)
   at N.M.Main(String[] args)
`
`/debug+ /d:NODEFASSIGN 
:=3
// method contract: using IsExposable in a contract
using System;
namespace N {

  public class C  {
    invariant true;
    public int f(int x)
      requires IsExposable;
    { return x; }
  }
  class M { 
    public static void Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      try { Console.WriteLine(new C().f(x)); Console.WriteLine("No contract violation"); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
    }
  }
}
`
3
No contract violation
`
using System;

public class Test{
  static void Foo<T>(T t){
    Console.WriteLine(typeof(T));
  }
  public static void Main(string[]! args){
    Test.Foo("bar");
    Test.Foo(1);
  }    
}
`
System.String
System.Int32
`
using System;

public class Test{
  static void Foo<T>(T[]! t){
    Console.WriteLine(typeof(T));
  }
  public static int Main(string[]! args){
    Test.Foo(args);
    return 0;
  }    
}
`
System.String
`
using System;

class Gen<U>{
}

public class Test{
  static void Foo<T>(T t){
    Console.WriteLine(typeof(T) == typeof(Gen<int>));
  }
  public static void Main(string[]! args){
    Test.Foo(new Gen<int>());
  }    
}
`
True
`
`/debug+ /d:DEFASSIGN 
:=3
// explicit implementation of an interface property
using System;

namespace N {

  interface I {
    int p {
      set
        requires value >= 0;
      get
        ensures result > 0;
    }
  }

  class C : I {
    private int x = 3;
    int I.p {
      set { x = value; }
      get { return x; }
    }
  }

  class M { 
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      I o = new C();
      try {
        Console.WriteLine("o.p = " + o.p);
        o.p = x;
        Console.WriteLine("o.p = " + o.p);
      }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }

}
`
o.p = 3
o.p = 3
`
`/debug+ /d:DEFASSIGN 
:=0
// explicit implementation of an interface property
using System;

namespace N {

  interface I {
    int p {
      set
        requires value >= 0;
      get
        ensures result > 0;
    }
  }

  class C : I {
    private int x = 3;
    int I.p {
      set { x = value; }
      get { return x; }
    }
  }

  class M { 
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      I o = new C();
      try {
        Console.WriteLine("o.p = " + o.p);
        o.p = x;
        Console.WriteLine("o.p = " + o.p);
      }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }

}
`
o.p = 3
Microsoft.Contracts.EnsuresException: Postcondition 'result > 0' violated from method 'N.C.get_p'
   at N.C.N.I.get_p()
   at N.M.Main(String[] args)
`
`/debug+ /d:DEFASSIGN 
:=-3
// explicit implementation of an interface property
using System;

namespace N {

  interface I {
    int p {
      set
        requires value >= 0;
      get
        ensures result > 0;
    }
  }

  class C : I {
    private int x = 3;
    int I.p {
      set { x = value; }
      get { return x; }
    }
  }

  class M { 
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      I o = new C();
      try {
        Console.WriteLine("o.p = " + o.p);
        o.p = x;
        Console.WriteLine("o.p = " + o.p);
      }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }

}
`
o.p = 3
Microsoft.Contracts.RequiresException: Precondition 'value >= 0' violated from method 'N.C.set_p(System.Int32)'
   at N.C.N.I.set_p(Int32 value)
   at N.M.Main(String[] args)
`
`/debug+ /d:DEFASSIGN 
:=3
// implicit implementation of an interface property // REVIEW: Is this too strict?
using System;

namespace N {

  interface I {
    int p {
      set
        requires value >= 0;
      get
        ensures result > 0;
    }
  }

  class C : I {
    private int x = 3;
    public int p {
      set { x = value; }
      get { return x; }
    }
  }

  class M { 
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      I o = new C();
      try {
        Console.WriteLine("o.p = " + o.p);
        o.p = x;
        Console.WriteLine("o.p = " + o.p);
      }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }

}
`
o.p = 3
o.p = 3
`
`/debug+ /d:DEFASSIGN 
:=0
// implicit implementation of an interface property // REVIEW: Is this too strict?
using System;

namespace N {

  interface I {
    int p {
      set
        requires value >= 0;
      get
        ensures result > 0;
    }
  }

  class C : I {
    private int x = 3;
    public int p {
      set { x = value; }
      get { return x; }
    }
  }

  class M { 
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      I o = new C();
      try {
        Console.WriteLine("o.p = " + o.p);
        o.p = x;
        Console.WriteLine("o.p = " + o.p);
      }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }

}
`
o.p = 3
Microsoft.Contracts.EnsuresException: Postcondition 'result > 0' violated from method 'N.C.get_p'
   at N.C.get_p()
   at N.M.Main(String[] args)
`
`/debug+ /d:DEFASSIGN 
:=-3
// implicit implementation of an interface property REVIEW: Is this too strict?
using System;

namespace N {

  interface I {
    int p {
      set
        requires value >= 0;
      get
        ensures result > 0;
    }
  }

  class C : I {
    private int x = 3;
    public int p {
      set { x = value; }
      get { return x; }
    }
  }

  class M { 
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      I o = new C();
      try {
        Console.WriteLine("o.p = " + o.p);
        o.p = x;
        Console.WriteLine("o.p = " + o.p);
      }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }

}
`
o.p = 3
Microsoft.Contracts.RequiresException: Precondition 'value >= 0' violated from method 'N.C.set_p(System.Int32)'
   at N.C.set_p(Int32 value)
   at N.M.Main(String[] args)
`
`/debug+ /d:DEFASSIGN 
:=3
// serialization of simple pre-conditions and post-conditions
using System;
using System.Reflection;
using Microsoft.Contracts;

namespace N {

  class A  {
    public int f(int x)
      requires x >= 0;
      ensures result > 0;
    {
       return x*x;
    }
  }
  class M {
    static void Main(string[]! args)
// BUGBUG: As soon as the repository comes online, the next line should be uncommented.
//      requires args != null && args.Length > 0;
    { 
      A a = new A(); 
      Type t = a.GetType();
      if (t != null){
        MethodInfo mi_a = t.GetMethod("f");
        if (mi_a != null){
          object[] attrs_a = mi_a.GetCustomAttributes(true);
          foreach (object! o in attrs_a)
          {
            Console.WriteLine(o.ToString());
            if ( o is RequiresAttribute )
            {
              RequiresAttribute ra = (RequiresAttribute) o;
              Console.WriteLine(ra.Requires);
            }
            else if ( o is EnsuresAttribute )
            {
              EnsuresAttribute ea = (EnsuresAttribute) o;
              Console.WriteLine(ea.Ensures);
            }
          }
        }
      }
      Console.WriteLine(a.f(Convert.ToInt32(args[0])));
  
      return;
    }
  }
}
`
Microsoft.Contracts.RequiresAttribute
::>=(i32,i32){$1,0}
Microsoft.Contracts.EnsuresAttribute
::>(i32,i32){${i32,"return value"},0}
9
`
`/debug+ /d:DEFASSIGN 
:=3
// precondition weakening, class extension (no violation)
using System;
namespace N {

  class C {
    public virtual int f(int x)
      requires x > 0;
    {
       return x;
    }
  }
  class D : C {
    public override int f(int x)
      requires x >= 0;
    {
       return x;
    }
  }
  class M {
    public static int test_f(C c, int x) { return c.f(x); }
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      try { C c = new C(); Console.WriteLine(test_f(c,x)); Console.WriteLine("No contract violation"); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      try { D d = new D(); Console.WriteLine(test_f(d,x)); Console.WriteLine("No contract violation"); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }
}
`
(13,25): error CS2622: 'N.D.f(int)' : requires clause not allowed in override.
`
`/debug+ /d:DEFASSIGN 
:=0
// precondition weakening, class extension (violation only for C)
using System;
namespace N {

  class C {
    public virtual int f(int x)
      requires x > 0;
    {
       return x;
    }
  }
  class D : C {
    public override int f(int x)
      requires x >= 0;
    {
       return x;
    }
  }
  class M {
    public static int test_f(C c, int x) { return c.f(x); }
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      try { C c = new C(); Console.WriteLine(test_f(c,x)); Console.WriteLine("No contract violation"); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      try { D d = new D(); Console.WriteLine(test_f(d,x)); Console.WriteLine("No contract violation"); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }
}
`
(13,25): error CS2622: 'N.D.f(int)' : requires clause not allowed in override.
`
`/debug+ /d:DEFASSIGN 
:=-3
// precondition weakening, class extension (violation for both C and D)
using System;
namespace N {

  class C {
    public virtual int f(int x)
      requires x > 0;
    {
       return x;
    }
  }
  class D : C {
    public override int f(int x)
      requires x >= 0;
    {
       return x;
    }
  }
  class M {
    public static int test_f(C c, int x) { return c.f(x); }
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      try { C c = new C(); Console.WriteLine(test_f(c,x)); Console.WriteLine("No contract violation"); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      try { D d = new D(); Console.WriteLine(test_f(d,x)); Console.WriteLine("No contract violation"); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }
}
`
(13,25): error CS2622: 'N.D.f(int)' : requires clause not allowed in override.
`
`/debug+ /d:DEFASSIGN 
:=1
// precondition weakening, class extension (bad contract: not weaker)
using System;
namespace N {

  class C {
    public virtual int f(int x)
      requires x > 0;
    {
       return x;
    }
  }
  class D : C {
    public override int f(int x)
      requires x > 1;
    {
       return x;
    }
  }
  class M {
    public static int test_f(C c, int x) { return c.f(x); }
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      try { C c = new C(); Console.WriteLine(test_f(c,x)); Console.WriteLine("No contract violation"); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      try { D d = new D(); Console.WriteLine(test_f(d,x)); Console.WriteLine("No contract violation"); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }
}
`
(13,25): error CS2622: 'N.D.f(int)' : requires clause not allowed in override.
`
`/debug+ /d:DEFASSIGN 
:=3
// precondition weakening, class extension with implicit inheritance (no violations)
using System;
namespace N {

  class C {
    public virtual int f(int x)
      requires x > 0;
    {
       return x;
    }
  }
  class D : C {
    public override int f(int x)
    {
       return x;
    }
  }
  class M {
    public static int test_f(C! c, int x) { return c.f(x); }
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      try { C c = new C(); Console.WriteLine(test_f(c,x)); Console.WriteLine("No contract violation"); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      try { D d = new D(); Console.WriteLine(test_f(d,x)); Console.WriteLine("No contract violation"); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }
}
`
3
No contract violation
3
No contract violation
`
`/debug+ /d:DEFASSIGN 
:=0
// precondition weakening, class extension with implicit inheritance (both violations)
using System;
namespace N {

  class C {
    public virtual int f(int x)
      requires x > 0;
    {
       return x;
    }
  }
  class D : C {
    public override int f(int x)
    {
       return x;
    }
  }
  class M {
    public static int test_f(C! c, int x) { return c.f(x); }
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      try { C c = new C(); Console.WriteLine(test_f(c,x)); Console.WriteLine("No contract violation"); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      try { D d = new D(); Console.WriteLine(test_f(d,x)); Console.WriteLine("No contract violation"); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }
}
`
Microsoft.Contracts.RequiresException: Precondition 'x > 0' violated from method 'N.C.f(System.Int32)'
   at N.C.f(Int32 x)
   at N.M.test_f(C c, Int32 x)
   at N.M.Main(String[] args)
Microsoft.Contracts.RequiresException: Precondition 'x > 0' violated from method 'N.D.f(System.Int32)'
   at N.D.f(Int32 x)
   at N.M.test_f(C c, Int32 x)
   at N.M.Main(String[] args)
`
`/debug+ /d:DEFASSIGN 
:=0
// Checking checked exceptions
// v1: direct throw of a checked exception not listed in the throws clause (no throws clause)
using System;
using Microsoft.Contracts;

namespace N {

  class E1 : CheckedException{}

  class C {

    public static int Main(string[]! args)
    {
      throw new E1();
      return 0;
    }
  }
}
`
(14,7): error CS2609: The checked exception 'N.E1' can be thrown but is not listed in the throws clause for method 'N.C.Main(string[]!)'.
`
`/debug+ /d:DEFASSIGN 
:=0
// Checking checked exceptions
// v2: method call that lists a checked exception in its contract that is not listed in the throws clause (no throws clause)
using System;
using Microsoft.Contracts;

namespace N {

  class E1 : CheckedException{}

  class C {
  
    public static void f()
      throws E1;
    {}

    public static int Main(string[]! args)
    {
      f();
      return 0;
    }
  }
}
`
(18,7): error CS2609: The checked exception 'N.E1' can be thrown but is not listed in the throws clause for method 'N.C.Main(string[]!)'.
`
`/debug+ /d:DEFASSIGN 
:=0
// Checking checked exceptions
// v3: rethrow of a checked exception not listed in the throws clause (no throws clause)
using System;
using Microsoft.Contracts;

namespace N {

  class E1 : CheckedException{}

  class C {

    public static int Main(string[]! args)
    {
      try{}
      catch{throw new E1();}
      return 0;
    }
  }
}
`
(15,13): error CS2609: The checked exception 'N.E1' can be thrown but is not listed in the throws clause for method 'N.C.Main(string[]!)'.
`
`/debug+ /d:DEFASSIGN 
:=0
// Checking checked exceptions
// v4: direct throw of a checked exception listed in the throws clause
using System;
using Microsoft.Contracts;

namespace N {

  class E1 : CheckedException{
    public override string Message{get{return "Exception of type N.E1 was thrown.";}}
  }

  class C {

    public static int Main(string[]! args)
      throws E1;
    {
      throw new E1();
      return 0;
    }
  }
}
`
Exception of type N.E1 was thrown.
`
`/debug+ /d:DEFASSIGN 
:=0
// Checking checked exceptions
// v5: method call that lists a checked exception in its contract that is listed in the throws clause
using System;
using Microsoft.Contracts;

namespace N {

  class E1 : CheckedException{}

  class C {
  
    public static void f()
      throws E1;
    {}

    public static int Main(string[]! args)
      throws E1;
    {
      f();
      return 0;
    }
  }
}
`
`
`/debug+ /d:DEFASSIGN 
:=0
// Checking checked exceptions
// v6: rethrow of a checked exception listed in the throws clause
using System;
using Microsoft.Contracts;

namespace N {

  class E1 : CheckedException{}

  class C {

    public static int Main(string[]! args)
      throws E1;
    {
      try{}
      catch{throw new E1();}
      return 0;
    }
  }
}
`
`
`/debug+ /d:DEFASSIGN 
:=0
// Checking checked exceptions
// v7: a checked exception not listed in the throws clause, but there is a throws clause
using System;
using Microsoft.Contracts;

namespace N {

  class E1 : CheckedException{}
  class E2 : CheckedException{}

  class C {

    public static int Main(string[]! args)
      throws E1;
    {
      try{ throw new E2(); }
      catch (E1 e) {}
      return 0;
    }
  }
}
`
(16,12): error CS2609: The checked exception 'N.E2' can be thrown but is not listed in the throws clause for method 'N.C.Main(string[]!)'.
`
`/debug+ /d:DEFASSIGN 
:=0
// Checking checked exceptions
// v8: a checked exception not listed in the throws clause, but caught by an outer catch block
using System;
using Microsoft.Contracts;

namespace N {

  class E1 : CheckedException{}
  class E2 : CheckedException{}

  class C {

    public static int Main(string[]! args)
    {
      try{ 
        try { throw new E2(); }
        catch (E1 e) {}
      }
      catch (E2 e) {}
      return 0;
    }
  }
}
`
(17,19): warning CS0219: The variable 'e' is assigned but its value is never used
(19,17): warning CS0219: The variable 'e' is assigned but its value is never used
`
`/debug+ /d:DEFASSIGN 
//Checking new operators ==> (implies) and <==> (iff) ..
using System;

class ImpliesTests{
  static void Assert(bool b) {
    if (!b)Console.WriteLine("Fatal Logical Error");
  }
  static void Assert(bool b, string s) {
    if (!b)Console.WriteLine(s);
  }
  
  static void Main() {
    
    bool t;
    t = false ==> 3 == 3; //"==> binds weaker then every C# operator"
    t = 3==3 ==> true;    //"binds weaker then every C# operator"
    
    t = true <==> 3 == 3; // "<==> binds weaker then every other operator"
    t = 3==3 <==> true;   // "<==> binds weaker then every other operator"
              // for <==> see below
        
    
    // a ==> ( b <==> c)   not equal (a ==> b) <==> c
    bool a = false, b = false, c = false;
    
    Assert( a ==> (b <==> c));
    Assert( ! ((a ==> b) <==> c) );
    Assert( ! (a ==> b <==> c), "==> should bind stronger than <==>");

    // l <==> m ==> n   not equal (l <==> m) ==> n
    bool l = false, m = false, n = true;
    
    Assert( (l <==> m) ==> n);
    Assert( !(l <==> (m ==> n)));
    Assert( !(l <==> m ==> n), "==> shound bind stronger than <==>");
    
    int i;
    Assert( false ==> 1/i == 3, "==> is non-strict on the right");
    
    // x ==> ( y ==> z)   not equal (x ==> y) ==> z
    bool x = false, y = true, z = false;

    Assert(!(x ==> y) ==> z);
    Assert(x ==> (y ==> z));
    Assert((x ==> y ==> z),"==> should be right associative");

    Assert(t);
  }
}
`
`
`/debug+ /d:DEFASSIGN 
:=0
// Checking checked exceptions
// v9: a checked exception not listed in the throws clause, but caught and rethrown
// tests a catch-all
using System;
using Microsoft.Contracts;

namespace N {

  class E1 : CheckedException{
    public override string Message{get{return "Exception of type N.E1 was thrown.";}}
  }

  class C {

    public static int Main(string[]! args)
    {
      try{ 
        throw new E1();
      }
      catch { throw; }
      return 0;
    }
  }
}
`
Exception of type 'Microsoft.Contracts.AssertException' was thrown.
`
`/debug+ /d:DEFASSIGN 
:=0
// Checking checked exceptions
// v10: throw of a checked exception not listed in the throws clause (no throws clause)
// but exception is caught and not propogated
using System;
using Microsoft.Contracts;

namespace N {

  class E1 : CheckedException{}

  class C {

    public static int Main(string[]! args)
    {
      try{ throw new E1(); }
      catch{}
      return 0;
    }
  }
}
`
`
`/debug+ /d:DEFASSIGN 
:=0
// Checking checked exceptions
// v11: throw of a checked exception not listed in the throws clause (no throws clause)
// but exception is caught and throws another checked exception
using System;
using Microsoft.Contracts;

namespace N {

  class E1 : CheckedException{}
  class E2 : CheckedException{}

  class C {

    public static int Main(string[]! args)
    {
      try{ throw new E1(); }
      catch{ throw new E2(); }
      return 0;
    }
  }
}
`
(17,14): error CS2609: The checked exception 'N.E2' can be thrown but is not listed in the throws clause for method 'N.C.Main(string[]!)'.
`
`/debug+ /d:DEFASSIGN 
:=0
// Checking checked exceptions
// v12: throw of an unchecked exception from a catch handler that swallows a checked exception
using System;
using Microsoft.Contracts;

namespace N {

  class E1 : CheckedException{}
  class E2 : System.Exception{
    public override string Message{get{return "Exception of type N.E2 was thrown.";}}
  }

  class C {

    public static int Main(string[]! args)
    {
      try{ throw new E1(); }
      catch{ throw new E2(); }
      return 0;
    }
  }
}
`
Exception of type N.E2 was thrown.
`
`/debug+ /d:DEFASSIGN 
:=0
// Checking checked exceptions
// v13: nested catch clauses
using System;
using Microsoft.Contracts;

namespace N {

  class E1 : CheckedException{}
  class E2 : CheckedException{}

  class C {

    public static int Main(string[]! args)
    {
      try{ throw new E1(); }
      catch (E1 e){ 
        try{
          throw new E2();
        }
        catch (E1 e){}
      }
      return 0;
    }
  }
}
`
(18,11): error CS2609: The checked exception 'N.E2' can be thrown but is not listed in the throws clause for method 'N.C.Main(string[]!)'.
`
`/debug+ /d:DEFASSIGN 
:=0
// Checking checked exceptions
// v14: nested catch clauses
using System;
using Microsoft.Contracts;

namespace N {

  class E1 : CheckedException{}
  class E2 : CheckedException{}

  class C {

    public static int Main(string[]! args)
    {
      try{ throw new E1(); }
      catch (E1 e){ 
        try{
          throw new E2();
        }
        catch (E2 e){
          assert(e!=null);
        }
        assert(e!=null);
      }
      return 0;
    }
  }
}
`
`
`/debug+ /d:DEFASSIGN 
:=0
// Checking checked exceptions
// v15: nested catch clauses
using System;
using Microsoft.Contracts;

namespace N {

  class E1 : CheckedException{}
  class E2 : CheckedException{
    public override string Message{get{return "Exception of type N.E2 was thrown.";}}
  }

  class C {

    public static int Main(string[]! args)
      throws E2;
    {
      try{ throw new E1(); }
      catch (E1 e){ 
        assert(e!=null);
        try{
          throw new E2();
        }
        catch (E1 e){
        }
      }
      return 0;
    }
  }
}
`
(24,19): warning CS0219: The variable 'e' is assigned but its value is never used
Exception of type N.E2 was thrown.
`
`/debug+ /d:DEFASSIGN 
:=3
// expose: no violation of invariant
using System;
namespace N {
  public class A0 {
    public int i = 0;
    invariant i >= 0;
  }
  class M { 
    public static int Main(string[]! args){
      try {
        int x = Convert.ToInt32(args[0]);
        A0 a0 = new A0();
        additive expose (a0) { a0.i = x; }
      }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }
}
`
`
`/debug+ /d:DEFASSIGN 
:=-3
// expose: violation of invariant
using System;
namespace N {
  public class A0 {
    public int i = 0;
    invariant i >= 0;
  }
  class M { 
    public static void Main(string[]! args){
      try {
        int x = Convert.ToInt32(args[0]);
        Console.WriteLine(1);
        A0 a0 = new A0();
        Console.WriteLine(2);
        additive expose (a0) {
          Console.WriteLine(3);
          a0.i = x;
          Console.WriteLine(4);
        }
        Console.WriteLine(5);
      }
      catch (Microsoft.Contracts.GuardException) { Console.WriteLine("Contract violated."); }
    }
  }
}
`
1
2
3
4
Contract violated.
`
`/debug+ /d:DEFASSIGN 
:=-3
// expose: violation of supertype invariant (but not caught by runtime checks: not unpacked above A0)
using System;
using Microsoft.Contracts;
namespace N {
  public class A0 {
    [Additive] public int i = 0;
    invariant i >= 0;
  }
  public class A1 : A0 {
    public int j = 0;
    invariant j >= i;
  }
  class M { 
    public static int Main(string[]! args){
      try {
        int x = Convert.ToInt32(args[0]);
        A1 a1 = new A1();
        additive expose (a1) { a1.i = x; }
      }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }
}
`
`
`/debug+ /d:DEFASSIGN 
:=-3
// expose: violation of supertype invariant (caught by runtime checks: unpacked above A0)
using System;
using Microsoft.Contracts;
namespace N {
  public class A0 {
    [Additive] public int i = 0;
    invariant i >= 0;
  }
  public class A1 : A0 {
    public int j = 0;
    invariant j >= i;
  }
  class M { 
    public static void Main(string[]! args){
      try {
        int x = Convert.ToInt32(args[0]);
        Console.WriteLine(1);
        A1 a1 = new A1();
        Console.WriteLine(2);
        additive expose ((A0) a1) {
          Console.WriteLine(3);
          a1.i = x;
          Console.WriteLine(4);
        }
        Console.WriteLine(5);
      }
      catch (Microsoft.Contracts.GuardException) { Console.WriteLine("Contract violated."); }
    }
  }
}
`
1
2
3
4
Contract violated.
`
`/debug+ /d:DEFASSIGN 
interface I {
  void m() requires true;
}
class C  {
  public void m() requires true; {}
}
class D : C,I {}
`
(7,7): error CS2633: Cannot add the contract from 'I.m()' to this type. 
`
`/debug+ /d:DEFASSIGN 
:=3
using System;
namespace N {


  class C  {
    public int x = 3;
    invariant
      x > 0;
  }
  class M {
    public static void Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      try {
        Console.WriteLine(1);
        C c = new C();
        Console.WriteLine(2);
        additive expose (c) {
          Console.WriteLine(3);
          additive expose (c) {
            Console.WriteLine(4);
            c.x = x;
            Console.WriteLine(5);
          }
          Console.WriteLine(6);
        }
        Console.WriteLine("No contract violation");
      }
      catch (Microsoft.Contracts.ContractException) { Console.WriteLine("Contract violation."); }
    }
  }
}
`
1
2
3
Thread is already reading or writing the object.
`
`/debug
using System;
namespace N {
  class C {
    public C()
      throws (Exception) ensures true;
      throws (Exception) ensures true;
      throws Exception ensures true;
    {
    }
  }
}
`
(5,26): error CS2610: 'throws' contracts on constructors are not allowed to have an 'ensures' condition. 
(6,26): error CS2610: 'throws' contracts on constructors are not allowed to have an 'ensures' condition. 
(7,24): error CS2610: 'throws' contracts on constructors are not allowed to have an 'ensures' condition. 
(5,7): error CS2627: 'N.C..ctor' : Cannot specify an unchecked exception in a throws clause.
(6,7): error CS2627: 'N.C..ctor' : Cannot specify an unchecked exception in a throws clause.
(4,5): error CS2626: 'N.C..ctor' : Throws sets cannot have duplicates.
(7,7): error CS2627: 'N.C..ctor' : Cannot specify an unchecked exception in a throws clause.
(4,5): error CS2626: 'N.C..ctor' : Throws sets cannot have duplicates.
`
`/debug
// Check that private fields can be mentioned in invariants
public class Class1{
  int x;
  invariant this.x > 0;
  static void Main(){}
}
`
`
`/debug
// Invariant in class with static method: static method does not get a default expose
// But invariant fails at pack at end of ctor
using System;
namespace ClassLibrary1
{
  public class Class1{
    int x;
    invariant this.x > 0;
    public Class1(){}
    public static void Main(string[]! args){
      new Class1();
    }
  }
}
`
Object invariant does not hold.
`
`/debug
// Invariant in class with static method: static method does not get a default expose
// Invariant does not fail at pack at end of ctor
using System;
namespace ClassLibrary1
{
  public class Class1{
    int x;
    invariant this.x >= 0;
    public Class1(){}
    public static void Main(string[]! args){
      new Class1();
    }
  }
}
`
`
`/debug+ /d:DEFASSIGN
// Quantifiers 
/*
						IList, IDictionary, list, dict, struct, class, interface
Display
	0 elems		
Comprehension
	0 elems
	n elems
	default
	only filter
	order dependant
Accessability
	constr accessible
	add accessible
*/
		
// Display in non-Enumerable context
using System;
using System.Collections;

namespace N{
  struct Pair{
    int Fst, Snd;
    public Pair(int fst, int snd) {
      Fst = fst; Snd = snd;
    }
    public override string ToString() {
      return "("+Fst+","+Snd+")";
    }
  }
  
  class M { 
    static void Print(string s, IEnumerable! xs) {
        Console.Write(s+" ");
            foreach(object o in xs) Console.Write(o+" "); 
        Console.WriteLine();
    }
    public static int Main(){
        int[] int0_2 = new int[]{0,1,2};
        //Ilist
        Print("IlistDisplay", new ArrayList{});
        Print("IlistDisplay", new ArrayList{1,2,3});
        Print("IlistDisplay", new ArrayList{int i in int0_2;  i });
        Print("IlistComprehension", new ArrayList{int i in new int[0]; i });
        Print("IlistComprehension", new ArrayList{int i in int0_2; i });
        Print("IlistComprehension", new ArrayList{int i in int0_2, i%2==0; i });
        Print("IlistComprehension", new ArrayList{int i in int0_2, j in int0_2; new Pair(i,j) });
        Print("IlistComprehension", new ArrayList{int i in int0_2, i%2 == 0, j in int0_2, j %2 == 1; new Pair(i,j) });
        Print("IlistComprehension", new ArrayList{int i in new int[0]; i; default 99 });


        //errors
        //Print("IlistComprehension", new ArrayList{int i});
        // Print("IlistComprehension", new ArrayList{int i in i});
        // Print("IlistComprehension", new ArrayList{int i in i; default -99});
        // Print("IlistComprehension", new ArrayList{int i in i; default 'a'});
        // Print("IlistComprehension", new ArrayList{int i in i; default new M()});       
        return 0;
    }
  }
}
`
IlistDisplay 
IlistDisplay 1 2 3 
IlistDisplay 0 1 2 
IlistComprehension 
IlistComprehension 0 1 2 
IlistComprehension 0 2 
IlistComprehension (0,0) (0,1) (0,2) (1,0) (1,1) (1,2) (2,0) (2,1) (2,2) 
IlistComprehension (0,1) (2,1) 
IlistComprehension 99 
`
`/debug+ /d:DEFASSIGN 
using System;
using System.Collections;
namespace N{
  struct Pair{
    int Fst, Snd;
    public Pair(int fst, int snd) {
        Fst = fst; Snd = snd;
    }
    public override string ToString() {
        return "("+Fst+","+Snd+")";
    }
    public override int GetHashCode() {
      return Fst*1000 ^ Snd;
    }
  }
  
  class M { 
    static void Print(string s, IEnumerable! xs) {
        Console.Write(s+": ");
            foreach(DictionaryEntry d in xs){ Console.Write(d.Key); Console.Write("~>"); Console.Write(d.Value); Console.Write(" "); } 
        Console.WriteLine();
    }
    public static int Main(){
        int[] int0_2 = new int[]{0,1,2};

        Print("IDictionaryDisplay", new Hashtable{});
        Print("IDictionaryDisplay", new Hashtable{1~>'a',2~>'b',3~>'c'});
        Print("IDictionaryDisplay", new Hashtable{int i in int0_2;  i ~> i*i });
        Print("IDictionaryComprehension", new Hashtable{int i in new int[0]; i ~> i*i });
        Print("IDictionaryComprehension", new Hashtable{int i in int0_2; i ~> i*i });
        Print("IDictionaryComprehension", new Hashtable{int i in int0_2, i%2==0; i ~> i*i });
        //Print("IDictionaryComprehension", new Hashtable{int i in int0_2, j in int0_2; new Pair(i,j)~>i*j });
        //Print("IDictionaryComprehension", new Hashtable{int i in int0_2, i%2 == 0, j in int0_2, j %2 == 1; new Pair(i,j)~>i*j });
        Print("IDictionaryComprehension", new Hashtable{int i in new int[0]; i~>i; default 99~>99 });
        return 0;
    }
  }
}
`
IDictionaryDisplay: 
IDictionaryDisplay: 3~>c 2~>b 1~>a 
IDictionaryDisplay: 2~>4 1~>1 0~>0 
IDictionaryComprehension: 
IDictionaryComprehension: 2~>4 1~>1 0~>0 
IDictionaryComprehension: 2~>4 0~>0 
IDictionaryComprehension: 99~>99 
`
`/debug+ /d:DEFASSIGN 
using System;
using System.Collections;
namespace N{
  struct Pair{
    int Fst, Snd;
    public Pair(int fst, int snd) {
        Fst = fst; Snd = snd;
    }
    public override string ToString() {
        return "("+Fst+","+Snd+")";
    }
    public override int GetHashCode() {
      return Fst*1000 ^ Snd;
    }
    
//    public override bool Equals(object value) {
//      if (!value is //) return false;
//      // p = (//) value;
//      return this.Fst == p.Fst && this.Snd == p.Snd;
//    }
  }
  
  struct Map:IEnumerable {
    Hashtable h;
    public void Add(object key, object value){
      if (h==null) h = new Hashtable();
      h.Add(key,value);
    }
    public IEnumerator GetEnumerator() {
      if (h==null) h = new Hashtable();
      return h.GetEnumerator();
    }
  }   
  
  class M { 
    static void Print(string s, IEnumerable! xs) {
        Console.Write(s+": ");
            foreach(DictionaryEntry d in xs){ Console.Write(d.Key); Console.Write("~>"); Console.Write(d.Value); Console.Write(" "); } 
        Console.WriteLine();
    }
    public static int Main(){
        int[] int0_2 = new int[]{0,1,2};

        Print("MapDisplay", new Map{});
        Print("MapDisplay", new Map{1~>'a',2~>'b',3~>'c'});
        Print("MapDisplay", new Map{int i in int0_2;  i ~> i*i });
        Print("MapComprehension", new Map{int i in new int[0]; i ~> i*i });
        Print("MapComprehension", new Map{int i in int0_2; i ~> i*i });
        Print("MapComprehension", new Map{int i in int0_2, i%2==0; i ~> i*i });
        //Print("MapComprehension", new Map{int i in int0_2, j in int0_2; new Pair(i,j)~>i*j });
        //Print("MapComprehension", new Map{int i in int0_2, i%2 == 0, j in int0_2, j %2 == 1; new Pair(i,j)~>i*j });
        Print("MapComprehension", new Map{int i in new int[0]; i~>i; default 99~>99 });
        return 0;
    }
  }
}
`
MapDisplay: 
MapDisplay: 3~>c 2~>b 1~>a 
MapDisplay: 2~>4 1~>1 0~>0 
MapComprehension: 
MapComprehension: 2~>4 1~>1 0~>0 
MapComprehension: 2~>4 0~>0 
MapComprehension: 99~>99 
`
`/debug+ /d:DEFASSIGN /d:NONONNULLTYPECHECK
// BUGBUG!! Should be able to do non-null checking on this one. For some reason, it doesn't work
using System;
using System.Collections;
namespace N{
  struct Pair{
    int Fst, Snd;
    public Pair(int fst, int snd) {
        Fst = fst; Snd = snd;
    }
    public override string ToString() {
        return "("+Fst+","+Snd+")";
    }
//    public override bool Equals(object value) {
//      if (!value is Pair) return false;
//      Pair p = (Pair) value;
//      return this.Fst == p.Fst && this.Snd == p.Snd;
//    }
  }
  
  struct List:IEnumerable {
    ArrayList h;
    public int Add(object key){
      if (h==null) h = new ArrayList();
      h.Add(key);
      return h.Count;
    }
    public IEnumerator GetEnumerator() {
      if (h==null) h = new ArrayList();
      return h.GetEnumerator();
    }
  }   
  
  class M { 
    static void Print(string s, IEnumerable xs) {
        Console.Write(s+" ");
            foreach(DictionaryEntry d in xs){ Console.Write(d.Key); Console.Write("~>"); Console.Write(d.Value); Console.Write(" "); } 
        Console.WriteLine();
    }
    public static int Main(){
        int[] int0_2 = new int[]{0,1,2};

        Print("ListDisplay", new List{});
        Print("ListDisplay", new List{1~>'a',2~>'b',3~>'c'});
        Print("ListDisplay", new List{int i in int0_2;  i ~> i*i });
        Print("ListComprehension", new List{int i in new int[0]; i ~> i*i });
        Print("ListComprehension", new List{int i in int0_2; i ~> i*i });
        Print("ListComprehension", new List{int i in int0_2, i%2==0; i ~> i*i });
        Print("ListComprehension", new List{int i in int0_2, j in int0_2; new Pair(i,j)~>i*j });
        Print("ListComprehension", new List{int i in int0_2, i%2 == 0, j in int0_2, j %2 == 1; new Pair(i,j)~>i*j });
        Print("ListComprehension", new List{int i in new int[0]; i~>i; default 99~>99 });
        return 0;
    }
  }
}
`
ListDisplay 
ListDisplay 1~>a 2~>b 3~>c 
ListDisplay 0~>0 1~>1 2~>4 
ListComprehension 
ListComprehension 0~>0 1~>1 2~>4 
ListComprehension 0~>0 2~>4 
ListComprehension (0,0)~>0 (0,1)~>0 (0,2)~>0 (1,0)~>0 (1,1)~>1 (1,2)~>2 (2,0)~>0 (2,1)~>2 (2,2)~>4 
ListComprehension (0,1)~>0 (2,1)~>2 
ListComprehension 99~>99 
`
`/debug+ /d:DEFASSIGN 
using System;
using System.Collections;
//improve error message in case signatures don't match...
namespace N{
  struct List{
    ArrayList h;
    public void Add(object key){
      if (h==null) h = new ArrayList();
      h.Add(key);
      //return h.Count;
    }
  }   
  
  class M { 
    public static int Main(){
        new List{1~>'a',2~>'b',3~>'c'};
    }
  }
}
`
(16,9): error CS0143: The type 'N.List' has no constructors defined
`
`/debug+ /d:DEFASSIGN 
using System;
using System.Collections;
namespace N{
  struct Map{
    public void Add(object key, object value){
    }
  }   
  
  class M { 
    public static int Main(){
        new Map{int i in {1,2}; i~>1; default new M()};
        return 0;
    }
  }
}
`
(11,9): error CS0143: The type 'N.Map' has no constructors defined
`
`/debug+ /d:DEFASSIGN /d:NONONNULLTYPECHECK
// BUGBUG!! Should be able to do non-null checking on this one. For some reason, it doesn't work
using System;
using System.Collections.Generic;

namespace N{
  
 using C=System.Collections;

 struct Pair{
    int Fst, Snd;
    public Pair(int fst, int snd) {
        Fst = fst; Snd = snd;
    }
    public override string ToString() {
        return "("+Fst+","+Snd+")";
    }
  }
  
   class M { 
    
    
    static void Print(string s, IEnumerable<System.Collections.DictionaryEntry> xs) {
        Console.Write(s+" ");
            foreach(System.Collections.DictionaryEntry d in xs) Console.Write(d.Key+"~>"+d.Value+" "); 
        Console.WriteLine();
    }

    static void Print(string s, IEnumerable<object> xs) {
        Console.Write(s+" ");
            foreach(object d in xs) Console.Write(d+" "); 
        Console.WriteLine();
    }
    public static int Main(){
        int[] int0_2 = new int[]{0,1,2};

        Print("Display", {});
        Print("Display", {1~>'a',2~>'b',3~>'c'});
        Print("Display", {int i in int0_2;  i ~> i*i });
        Print("Comprehension", {int i in new int[0]; i ~> i*i });
        Print("Comprehension", {int i in int0_2; i ~> i*i });
        Print("Comprehension", {int i in int0_2, i%2==0; i ~> i*i });
        Print("Comprehension", {int i in int0_2, j in int0_2; new Pair(i,j)~>i*j });
        Print("Comprehension", {int i in int0_2, i%2 == 0, j in int0_2, j %2 == 1; new Pair(i,j)~>i*j });
        Print("Comprehension", {int i in new int[0]; i~>i; default 99~>99 });
        return 0;
    }
  }
}
`
Display 
Display 1~>a 2~>b 3~>c 
Display 0~>0 1~>1 2~>4 
Comprehension 
Comprehension 0~>0 1~>1 2~>4 
Comprehension 0~>0 2~>4 
Comprehension (0,0)~>0 (0,1)~>0 (0,2)~>0 (1,0)~>0 (1,1)~>1 (1,2)~>2 (2,0)~>0 (2,1)~>2 (2,2)~>4 
Comprehension (0,1)~>0 (2,1)~>2 
Comprehension 99~>99 
`
`/d:NONONNULLTYPECHECK
// BUGBUG!! Should be able to do non-null checking on this one. For some reason, it doesn't work
using System;
using C=System.Collections;
using System.Collections.Generic;

namespace N{
  
  class Pair{
    public object Fst, Snd;
    public Pair(object fst, object snd) {
        Fst = fst; Snd = snd;
    }
    public override string ToString() {
      return "("+Fst+","+Snd+")";
    }
  }
  
   class M { 
   
    static int Maximum(IEnumerable<int>  xs) {
          int max = 0; bool has = false;
          foreach (int x in xs){
            has = true;
            if (x > max) max = x;
          }
          if (has)
            return max;
          else
            return int.MinValue;
    }

//    static Pair Maximum(IEnumerable<Pair>  xs) {
//          Pair max = new Pair(int.MinValue, int.MinValue);
//          foreach (Pair x in xs)
//            if ((int)x.Fst > (int)max.Fst) max = x;
//            else if ((int)x.Fst == (int)max.Fst && (int)x.Snd > (int)max.Snd) max = x;
//          return max;
//    }
//    
    
    public static int Main(){
        int[] int0_2 = new int[]{0,1,2};

        //Console.WriteLine("Display " + (int)Maximum{}); //int.MinValue
        Console.WriteLine("Display " + Maximum{1,2,3}); //3
        Console.WriteLine("Display " + Maximum{int i in int0_2;  i}); //2
        Console.WriteLine("Comprehension " + Maximum{int i in new int[0]; i }); //int.MinValue
        Console.WriteLine("Comprehension " + Maximum{int i in int0_2; -i}); //0
        Console.WriteLine("Comprehension " + Maximum{int i in int0_2, i%2 == 1; i  }); //1
        //Console.WriteLine("Comprehension " + Maximum{int i in int0_2, j in int0_2; new Pair(i,j) }); // 2,2
        //Console.WriteLine("Comprehension " + Maximum{int i in int0_2, i%2 == 0, j in int0_2, j %2 == 1; new Pair(i,j)}); // 1,1
        Console.WriteLine("Comprehension" + Maximum {int i in new int[0]; i; default 99 }); //99
        return 0;
    }
  }
}
`
Display 3
Display 2
Comprehension -2147483648
Comprehension 0
Comprehension 1
Comprehension99
`
`/debug+ /d:DEFASSIGN 
:=3
// method contracts: Spec#-lite comment convention
using System;
using Microsoft.Contracts;

namespace N {

  class C  {
    [SpecPublic]
    protected int j = 0;

//^    invariant
//^      j >= 0;

    public virtual int f(int x)
/*^    
      requires (1/x) > 0;
      requires x >= 0;
      requires j >= 0 otherwise InvalidOperationException;
      requires x > j otherwise new InvalidOperationException("foo");
      ensures j == x;
      ensures old(j + 1) < j * 3;
      throws (InvalidOperationException e) ensures j == 0;
      ensures x > 0; // BUG! Because I'm duplicating post-conditions, it crashes if it encounters a parameter
      ensures result >= 0;
^*/      
    {
       if ( x == 3 ) { j = x; throw new InvalidOperationException("foo"); }
       if ( x == 5 ) { throw new InvalidOperationException("foo"); }
       return x * x;
    }
  }
  class M { 
    public static int Main(string[]! args){
      int x = Convert.ToInt32(args[0]);
      try { C c = new C(); Console.WriteLine(c.f(x)); Console.WriteLine("No contract violation"); }
      catch (Exception e) { Console.WriteLine(e.ToString()); }
      return 0;
    }
  }
}
`
(22,7): error CS2627: 'N.C.f' : Cannot specify an unchecked exception in a throws clause.
`
`/debug
// initial invariant level; default precondition on Increase checks invariant level
class Interval {
  int x;
  int y;
  
  invariant x < y;

  [Microsoft.Contracts.NotDelayed]  
  public Interval() {
    Increase(7);
  }
  
  public void Increase(int amount) {
    additive expose (this) {
      System.Console.WriteLine(x < y);
      x += amount;
      y += amount;
    }
  }
}

class Test {
  static void Main() {
    new Interval();
  }
}
`
The target object of this call must be exposable.
`
`/disable:guardedclasseschecks
// initial invariant level; unpack checks invariant level
// but violation uncaught: /disable:guardedclasseschecks specified
class Interval {
  int x;
  int y;
  
  invariant x < y;

  [Microsoft.Contracts.NotDelayed]  
  public Interval() {
    Increase(7);
  }
  
  public void Increase(int amount) {
    System.Console.WriteLine(x < y);
    x += amount;
    y += amount;
  }
}

class Test {
  static void Main() {
    new Interval();
  }
}
`
False
`
`/debug
// invariant level after unpack; unpack checks invariant level
class Interval {
  int x;
  int y;
  
  invariant x < y;
  
  public Interval() {
    y = 10;
  }
  
  public void Foo() {
    additive expose (this) {
      y = 0;
      System.Console.WriteLine(1);
      Increase(10);
    }
  }
  
  public void Increase(int amount) {
    additive expose (this) {
      System.Console.WriteLine(2);
      System.Console.WriteLine(x < y);
      x += amount;
      y += amount;
    }
  }
}

class Test {
  static void Main() {
    Interval interval = new Interval();
    interval.Foo();
  }
}
`
1
The target object of this call must be exposable.
`
`
// invariant level after unpack; unpack checks invariant level
// but violation uncaught: /debug not specified
class Interval {
  int x;
  int y;
  
  invariant x < y;
  
  public Interval() {
    y = 10;
  }
  
  public void Foo() {
    y = 0;
    System.Console.WriteLine(1);
    Increase(10);
  }
  
  public void Increase(int amount) {
    System.Console.WriteLine(2);
    System.Console.WriteLine(x < y);
    x += amount;
    y += amount;
  }
}

class Test {
  static void Main() {
    Interval interval = new Interval();
    interval.Foo();
  }
}
`
1
2
False
`
`/debug
// This test case checks that a default precondition that checks the invariant level is added to property getters
class Test {
  invariant true;

  [Microsoft.Contracts.NotDelayed]  
  public Test() {
    System.Console.WriteLine(X);
  }
  
  public int X {
    get {
      return 4;
    }
  }
  
  static void Main() {
    new Test();
  }
}
`
The target object of this call must be exposable.
`
`/debug+ /d:NONNULLTYPECHECK
// Test to see if analysis sees state from a previous precondition in a later one.
class C {
  int x;
  void f(C c)
    requires c != null;
    requires c.x > 0;
    {}
  static void Main() {}
}
`
`
`/debug+ /d:NONNULLTYPECHECK
// Test to see if analysis sees state from a previous postcondition in a later one.
class C {
  int x;
  C f()
    ensures result != null;
    ensures result.x > 0;
    { return new C(); }
  static void Main() {}
}
`
`
`/debug+ /d:NONNULLTYPECHECK
// Test that an exceptional postcondition is checked only if its associated type is thrown.
// Believe it or not, until now (26 August 2004), there had been no test for this!
using System;
using Microsoft.Contracts;
class CEX : CheckedException{}
class C {
  public int x;
  public void f()
    throws CEX ensures this.x > 0;
  { throw new CEX(); }
  public void g()
    throws CEX ensures this.x > 0;
  { throw new Exception("Exception of type System.Exception was thrown."); }
}

class M {

  static void Main(){
    try {
      C c = new C();
      c.f();
    }
    catch (CEX e) { Console.WriteLine(e.Message); }
    catch (Exception e) { Console.WriteLine(e.Message); }
    try {
      C c = new C();
      c.g();
    }
    catch (CEX e) { Console.WriteLine(e.Message); }
    catch (Exception e) { Console.WriteLine(e.Message); }
  }
}
`
Exceptional postcondition 'this.x > 0' violated from method 'C.f'
Exception of type System.Exception was thrown.
`
`/d:NONNULLTYPECHECK
using System;

class C {

  static void f(params int[] xs) {
    if (xs == null) return;
    Console.WriteLine("{0} {1} {2}", xs[0], xs[1], xs.Length);
  }

  static void g(int[]! ys) { f(ys); }

  public static void Main(){
    int[]! a = new int[]{0, 1};
    g(a);
  }
}
`
0 1 2
`
// check that we don't crash on constraint checking if type parameter is null.
class Region {
}

class S {

  public static R NewRegion<R>(R x) where R:Region
  {
    return x;
  }

  public void Test(Region x) {
    
    NewRegion<R>(x);
  }
}
`
(14,15): error CS0246: The type or namespace name 'R' could not be found (are you missing a using directive or an assembly reference?)
`
`/debug
using System;
class C {
  public void f(bool p, bool q)
    requires p <==> q;
  { }
}

class M {
  public static int Main() {
    try { new C().f(true,true); Console.WriteLine("No contract violation"); }
    catch (Exception e) { Console.WriteLine(e.Message); }
    try { new C().f(true,false); Console.WriteLine("No contract violation"); }
    catch (Exception e) { Console.WriteLine(e.Message); }
    try { new C().f(false,true); Console.WriteLine("No contract violation"); }
    catch (Exception e) { Console.WriteLine(e.Message); }
    try { new C().f(false,false); Console.WriteLine("No contract violation"); }
    catch (Exception e) { Console.WriteLine(e.Message); }
    return 0;
  }
}
`
No contract violation
Precondition 'p <==> q' violated from method 'C.f(System.Boolean,System.Boolean)'
Precondition 'p <==> q' violated from method 'C.f(System.Boolean,System.Boolean)'
No contract violation
`
`
// This test depends on the definite assignment checking being "on".
// It tests whether or not the field initializer blocks are being treated
// correctly. There had been a bug where the block was shared by all ctors
// and the second ctor would normalize the block and that happened in a context
// of "this captured by closure" so "this" was being normalized to "closure_local.this_value".
// Of course, this is invalid in the other constructors.
//
// If the bug is present, then the definite assignment checking should complain about
// the first constructor. If the bug is not present, no output should occur.
delegate int MyDelegate(int i);
class C {
   int x = 3;
   public C() {}
   [Microsoft.Contracts.NotDelayed]
   public C(int i)
   {
     MyDelegate f = delegate (int j) { return j+i; };
     int y = f(5);
   }
   // Check that we can create a delayed delegate if we don't use it
   // within the constructor
   MyDelegate md;
   public C(int i, int k)
   {
     MyDelegate f = delegate (int j) { return j+i+k; };
   }
   static void Main(){}
}
`
`
`
// This code used to crash the compiler, so just adding it as a regression
public class C {
  internal int k;
  public int z;

  public static void Main() { }
}

public class T {
  virtual /*public*/ void P(C! c)
    requires c.k == 43;
  {
  }
}
`
(10,3): error CS0621: 'T.P' : virtual or abstract members cannot be private
`
`/debug /d:NONNULLTYPECHECK
// This tests a bug where comprehensions in field initializers were not treated in the
// right context and also had bad code generated for them.
using Microsoft.SpecSharp.Collections;
public class C {
  int x = 3;
  public bool b = Reductions.Forall{int i in (0:1); i >= x};
}
public class M  {
  public static void Main(){
    System.Console.WriteLine(new C().b);
  }
}
`
(6,58): error CS0120: An object reference is required for the nonstatic field, method, or property 'C.x'
`
`/debug /d:NONNULLTYPECHECK
// This tests a bug where comprehensions in field initializers were not treated in the
// right context and also had bad code generated for them.
using Microsoft.SpecSharp.Collections;
public class C {
  int x = 3;
  public bool b = Reductions.Forall{int i in (0:1); i >= 0};
}
public class M  {
  public static void Main(){
    System.Console.WriteLine(new C().b);
  }
}
`
True
`
`/debug
// Make sure that T is recognized as something that can be enumerated
// even though its GetEnumerator and Current methods return a non-null
// type.
public interface T
{
  T! GetEnumerator();
  void Reset();
  object! Current {get;}
  bool MoveNext();
}

public class C {
  public void foo(T! t) {
	foreach (object! o in t){}
  }		
}

public class M {
  public static void Main() {}
}
`
(14,19): warning CS0219: The variable 'o' is assigned but its value is never used
`
`/debug
// Make sure that if a class does *not* have an invariant, but a supertype does that the compiler works
// There had been a bug where it crashed because the class C's contract did not have a reference to the
// "inv" field that --- if it were to have an invariant --- it would share with the class B.
class B {
  int x;
  invariant x >= 0;
}
class C : B {}

class M { public static void Main() {} }
`
`
`/debug
// Tests that an object is in the 'packed' state after a self ctor call
using System;
using Microsoft.Contracts;
public class C  {
  public int x;
  invariant x >= 0;

  public C() : this(3) { additive expose (this) { x++; } }

  public C(char c) { this(5); additive expose (this) { x++; } }

  public C(int i) { x = i; }
}

class M {
  public static void Main()
  { 
    Console.WriteLine(new C().x); 
    Console.WriteLine(new C('a').x); 
  }
}
`
4
6
`
`/debug
using System;
using Microsoft.Contracts;

public class T {
  public void M1(int x)
    requires 0 <= x otherwise new T();  // error: not an exception
  { }
  public void M2(int x)
    requires 0 <= x otherwise T;  // error: not an exception
  { }
  [Pure][Reads(ReadsAttribute.Reads.Everything)]
  private T! ReturnT() { return this; }
  public void M3(int x)
    requires 0 <= x otherwise ReturnT();  // error: not an exception
  { }

  public void M4(int x)
    requires 0 <= x otherwise new Exception();  // okay
  { }
  public void M5(int x)
    requires 0 <= x otherwise Exception;  // okay
  { }
  [Pure][Reads(ReadsAttribute.Reads.Everything)]
  public Exception! ReturnException() { return new Exception(); }
  public void M6(int x)
    requires 0 <= x otherwise ReturnException();  // okay
  { }

  public void M7(int x)
    requires 0 <= x otherwise new CheckedException();  // error: checked exception
  { }
  public void M8(int x)
    requires 0 <= x otherwise CheckedException;  // error: checked exception
  { }
  [Pure][Reads(ReadsAttribute.Reads.Everything)]
  private CheckedException! ReturnCheckedException() { return new CheckedException(); }
  public void M9(int x)
    requires 0 <= x otherwise ReturnCheckedException();  // error: not an exception
  { }

  public static void Main() { }
}
`
(6,5): error CS0155: The type caught or thrown must be derived from System.Exception
(9,5): error CS0155: The type caught or thrown must be derived from System.Exception
(14,5): error CS0155: The type caught or thrown must be derived from System.Exception
(30,5): error CS2634: Cannot specify a checked exception in an otherwise clause. 
(33,5): error CS2634: Cannot specify a checked exception in an otherwise clause. 
(38,5): error CS2634: Cannot specify a checked exception in an otherwise clause. 
`
`/debug
using System;
public class T {
  public static Exception my_exception;
  public void M(int x)
    requires 0 <= x otherwise my_exception;  // error: may be null
  { }
  public static void Main() { }
}
`
(5,5): error CS2653: otherwise expression must be of a non-null type
`
`/debug
using System;
public class T {
  public void M(int x)
    requires 0 <= x otherwise 5;  // error: may be null
  { }
  public static void Main() { }
}
`
(4,5): error CS2654: otherwise clause must be a type
`
using System;
using System.Collections; 

class M { 
  ArrayList al = new ArrayList{int i in (0:10);  i };
  static public void Main()
  {
  }
}
`
`
using Microsoft.Contracts; // needed for Pure
public struct C<T>{ // also an error if this is a class

  // complaint is on "implicit This" for "this.P()"
  // has to be a method call and not a field
  // has to be in a precondition and not in the body of the method
  public void foo()
    requires P();
  { }
  
  [Pure][Reads(ReadsAttribute.Reads.Everything)] public bool P(){return true;}
 
  // no error unless this method is included
  // its return type must be "C<T>" or else no error
  public C<T> bar(){
    return this;
  }
 
}
class M { public static void Main(){} }
`
`
using System;
using System.Collections;
class C{
  public ArrayList al1 = new ArrayList{3,4};
  public ArrayList al2 = new ArrayList{int i in (0:3); i};
  public bool b1 = forall{true,true};
  public bool b2 = exists{true,true};
  public bool b3 = forall{int i in (0:3); i > 0};
  public bool b4 = forall{int i in (0:3); i >= 0};
  public bool b5 = exists{int i in (0:3); i > 0};
  public bool b6 = exists{int i in (0:3); i >= 0};
  public bool b7 = exists{int i in (0:3); i >= 3};
  public Hashtable h1 = new Hashtable{1~>'a',2~>'b',3~>'c'};
}
class M{
  public static void Main(){
    C c = new C();
    Console.Write("c.al1 = [");
    foreach(int i in c.al1){Console.Write(i); Console.Write(",");}
    Console.WriteLine("]");
    Console.Write("c.al2 = [");
    foreach(int i in c.al2){Console.Write(i); Console.Write(",");}
    Console.WriteLine("]");
    Console.WriteLine("c.b1 = " + c.b1);
    Console.WriteLine("c.b2 = " + c.b2);
    Console.WriteLine("c.b3 = " + c.b3);
    Console.WriteLine("c.b4 = " + c.b4);
    Console.WriteLine("c.b5 = " + c.b5);
    Console.WriteLine("c.b6 = " + c.b6);
    Console.WriteLine("c.b7 = " + c.b7);
    Console.WriteLine(c.h1.Count);
  }
}
`
(19,22): warning CS2614: Receiver might be null (of type 'System.Collections.ArrayList')
(22,22): warning CS2614: Receiver might be null (of type 'System.Collections.ArrayList')
(31,23): warning CS2614: Receiver might be null (of type 'System.Collections.Hashtable')
c.al1 = [3,4,]
c.al2 = [0,1,2,]
c.b1 = True
c.b2 = True
c.b3 = False
c.b4 = True
c.b5 = True
c.b6 = True
c.b7 = False
3
`
`
// don't allow general comprehensions (those of type IEnumerable<T>) in contracts
using System;
using Microsoft.SpecSharp.Collections;
class C{
  public int f(int[] xs)
    requires Reductions.Forall{int i in xs; i > 0};
  { return 3; }
}
class M{
  public static void Main(){
  }
}
`
(6,31): error CS2655: General comprehensions are not currently supported in method contracts.
`
`/debug+
// If the body of an expose block terminates with a checked exception, then an attempt is made to pack the object; if successful, the checked exception propagates unchanged
using System;
using Microsoft.Contracts;
class TooBigException : CheckedException{}
class FooBar{
  int x;
  int y;
  invariant 2 * x == y;
  public FooBar(int x)
    requires int.MinValue / 2 <= x && x <= int.MaxValue / 2;
  {
    this.x = x;
    this.y = 2 * x;
  }
  public void IncrementX() throws TooBigException; {
    additive expose (this){
      x++;
      if (int.MaxValue - 2 < y){
        x--;
        throw new TooBigException();
      }
      y += 2;
    }
  }
  static void Main(){
	FooBar fb = new FooBar(int.MaxValue / 2);
    try{
      fb.IncrementX();
	}catch(TooBigException){
      if (!((!)Guard.GetFrameGuard(fb, typeof(FooBar))).CanStartWriting)
         Console.WriteLine("FAIL");
      Console.WriteLine("PASS");
      return;
	}
    Console.WriteLine("FAIL");
  }
}
`
PASS
`
`/debug+
// If the body of an expose block terminates with a checked exception, then an attempt is made to pack the object; if unsuccessful, the checked exception is dropped and a GuardException is thrown
using System;
using Microsoft.Contracts;
class TooBigException : CheckedException{}
class FooBar{
  int x;
  int y;
  invariant 2 * x == y;
  public FooBar(int x)
    requires int.MinValue / 2 <= x && x <= int.MaxValue / 2;
  {
    this.x = x;
    this.y = 2 * x;
  }
  public void IncrementX() throws TooBigException; {
    additive expose (this){
      x++;
      if (int.MaxValue - 2 < y){
        throw new TooBigException();
      }
      y += 2;
    }
  }
  static void Main() throws TooBigException; {
	FooBar fb = new FooBar(int.MaxValue / 2);
    try{
      fb.IncrementX();
	}catch(GuardException){
      Console.WriteLine("PASS");
      return;
	}
    Console.WriteLine("FAIL");
  }
}
`
PASS
`
`/debug+
// If the body of an expose block terminates with an unchecked exception, then no attempt is made to pack the object; the unchecked exception is always propagated unchanged
using System;
using Microsoft.Contracts;
class TooBigException : Exception {}
class FooBar{
  int x;
  int y;
  invariant 2 * x == y;
  public FooBar(int x)
    requires int.MinValue / 2 <= x && x <= int.MaxValue / 2;
  {
    this.x = x;
    this.y = 2 * x;
  }
  public void IncrementX() {
    additive expose (this){
      x++;
      if (int.MaxValue - 2 < y){
        throw new TooBigException();
      }
      y += 2;
    }
  }
  static void Main(){
	FooBar fb = new FooBar(int.MaxValue / 2);
    try{
      fb.IncrementX();
	}catch(TooBigException){
      Console.WriteLine("PASS");
      return;
	}
    Console.WriteLine("FAIL");
  }
}
`
PASS
`
`
using System;
class C{
  public void f(int[] xs){
    Console.Write("f(int[] xs) passed: ");
    foreach(int i in xs)
      Console.Write(i + " ");
    Console.WriteLine("");
    xs = new int[]{10,11,12};
  }
  public void f(ref int[] xs){
    Console.Write("f(ref int[] xs) passed: ");
    foreach(int i in xs)
      Console.Write(i + " ");
    Console.WriteLine("");
    xs = new int[]{10,11,12};
  }
}
class M{
  public static void PrintArray(int[]/*!*/ Arr){
    Console.Write("[");
    if (Arr.Length > 0)
      Console.Write(Arr[0]);
    for (int i = 1, n = Arr.Length; i < n; i++)
      Console.Write(", " + Arr[i]);
    Console.Write("]");
  }
  public static void Main(){
    int[] A = new int[]{1,2,3};
    int[] B = A;
    C c = new C();
    c.f(A);
    Console.Write("A = "); PrintArray(A); Console.WriteLine("");
    Console.Write("B = "); PrintArray(B); Console.WriteLine("");

    c.f(ref A);
    assert A != null;
    Console.Write("A = "); PrintArray(A); Console.WriteLine("");
    Console.Write("B = "); PrintArray(B); Console.WriteLine("");
  }
}
`
f(int[] xs) passed: 1 2 3 
A = [1, 2, 3]
B = [1, 2, 3]
f(ref int[] xs) passed: 1 2 3 
A = [10, 11, 12]
B = [1, 2, 3]
`
`
// test for Ranges
public enum Color { Red, Green, Blue};
public class M{
  public static bool g(int a){ System.Console.WriteLine("g called with: " + a); return true; }
  public static bool g(char x){ System.Console.WriteLine("g called with: " + x); return true; }
  public static bool g(Color x){ System.Console.WriteLine("g called with: " + x); return true; }
  public static void Main(){
    bool b;
    b = forall{int i in (0:3); g(i)};
    b = forall{int i in (0..3); g(i)};
    b = forall{char c in ('a':'d'); g(c)};
    b = forall{char c in ('a'..'d'); g(c)};
    b = forall{Color c in (Color.Red:Color.Blue); g(c)};
    b = forall{Color c in (Color.Red..Color.Blue); g(c)};
  }
}
`
(9,5): warning CS0219: The variable 'b' is assigned but its value is never used
g called with: 0
g called with: 1
g called with: 2
g called with: 0
g called with: 1
g called with: 2
g called with: 3
g called with: a
g called with: b
g called with: c
g called with: a
g called with: b
g called with: c
g called with: d
g called with: Red
g called with: Green
g called with: Red
g called with: Green
g called with: Blue
`
`/debug
// test "exists unique": fail because no test succeeds
using System;
public class C{
  public void f(int[] xs)
    requires exists unique{int i in xs; i > 0};
  {}
}
public class M{
  public static void Main(){
    int[] A = new int[]{-1,-2,-3};
    try{
      new C().f(A);
      Console.WriteLine("succeed");
    }catch{
      Console.WriteLine("fail");
    }
  }
}
`
fail
`
`/debug
// test "exists unique": fail because more than one test succeeds
using System;
public class C{
  public void f(int[] xs)
    requires exists unique{int i in xs; i > 0};
  {}
}
public class M{
  public static void Main(){
    int[] A = new int[]{-1,2,3};
    try{
      new C().f(A);
      Console.WriteLine("succeed");
    }catch{
      Console.WriteLine("fail");
    }
  }
}
`
fail
`
`/debug
// test "exists unique": succeed because exactly one test succeeds
using System;
public class C{
  public void f(int[] xs)
    requires exists unique{int i in xs; i > 0};
  {}
}
public class M{
  public static void Main(){
    int[] A = new int[]{-1,2,-3};
    try{
      new C().f(A);
      Console.WriteLine("succeed");
    }catch{
      Console.WriteLine("fail");
    }
  }
}
`
succeed
`
`/debug
// loop invariants: for loop: success
using System;
class Test{
  static int Multiply(int n, int x)
    ensures result == n * x;
  {
    int p = 0;
    for (int i = 0; i < n; i++)
      invariant p == i * x;
    {
      p += x;
    }
    return p;
  }
  static void Main(){
    try{
	  Console.WriteLine(Multiply(3, 5));
    }catch(Microsoft.Contracts.AssertException){
      Console.WriteLine("Assertion violation");
    }
  }
}
`
15
`
`/debug
// loop invariants: for loop: body is wrong
using System;
class Test{
  static int Multiply(int n, int x)
    ensures result == n * x;
  {
    int p = 0;
    for (int i = 0; i < n; i++)
      invariant p == i * x;
    {
      p *= x;
    }
    return p;
  }
  static void Main(){
    try{
	  Console.WriteLine(Multiply(3, 5));
    }catch(Microsoft.Contracts.AssertException){
      Console.WriteLine("Assertion violation");
    }
  }
}
`
Assertion violation
`
`/debug
// loop invariants: for loop: initial state is wrong
using System;
class Test{
  static int Multiply(int n, int x)
    ensures result == n * x;
  {
    int p = 1;
    for (int i = 0; i < n; i++)
      invariant p == i * x;
    {
      p += x;
    }
    return p;
  }
  static void Main(){
    try{
	  Console.WriteLine(Multiply(3, 5));
    }catch(Microsoft.Contracts.AssertException){
      Console.WriteLine("Assertion violation");
    }
  }
}
`
Assertion violation
`
`/debug
// loop invariants: while loop: success
using System;
class Test{
  static int Multiply(int n, int x)
    ensures result == n * x;
  {
    int p = 0;
    int i = 0;
    while (i < n)
      invariant p == i * x;
    {
      p += x;
      i++;
    }
    return p;
  }
  static void Main(){
    try{
	  Console.WriteLine(Multiply(3, 5));
    }catch(Microsoft.Contracts.AssertException){
      Console.WriteLine("Assertion violation");
    }
  }
}
`
15
`
`/debug
// loop invariants: while loop: body is wrong
using System;
class Test{
  static int Multiply(int n, int x)
    ensures result == n * x;
  {
    int p = 0;
    int i = 0;
    while (i < n)
      invariant p == i * x;
    {
      p *= x;
      i++;
    }
    return p;
  }
  static void Main(){
    try{
	  Console.WriteLine(Multiply(3, 5));
    }catch(Microsoft.Contracts.AssertException){
      Console.WriteLine("Assertion violation");
    }
  }
}
`
Assertion violation
`
`/debug
// loop invariants: while loop: initial state is wrong
using System;
class Test{
  static int Multiply(int n, int x)
    ensures result == n * x;
  {
    int p = 1;
    int i = 0;
    while (i < n)
      invariant p == i * x;
    {
      p += x;
      i++;
    }
    return p;
  }
  static void Main(){
    try{
	  Console.WriteLine(Multiply(3, 5));
    }catch(Microsoft.Contracts.AssertException){
      Console.WriteLine("Assertion violation");
    }
  }
}
`
Assertion violation
`
`/debug
// loop invariants: do-while loop: success
using System;
class Test{
  static int Multiply(int n, int x)
    requires 0 < n;
    ensures result == n * x;
  {
    int p = 0;
    int i = 0;
    do
      invariant p == i * x;
    {
      p += x;
      i++;
    } while (i != n);
    return p;
  }
  static void Main(){
    try{
	  Console.WriteLine(Multiply(3, 5));
    }catch(Microsoft.Contracts.AssertException){
      Console.WriteLine("Assertion violation");
    }
  }
}
`
15
`
`/debug
// loop invariants: do-while loop: body is wrong
using System;
class Test{
  static int Multiply(int n, int x)
    requires 0 < n;
    ensures result == n * x;
  {
    int p = 0;
    int i = 0;
    do
      invariant p == i * x;
    {
      p *= x;
      i++;
    } while (i != n);
    return p;
  }
  static void Main(){
    try{
	  Console.WriteLine(Multiply(3, 5));
    }catch(Microsoft.Contracts.AssertException){
      Console.WriteLine("Assertion violation");
    }
  }
}
`
Assertion violation
`
`/debug
// loop invariants: do-while loop: initial state is wrong
using System;
class Test{
  static int Multiply(int n, int x)
    requires 0 < n;
    ensures result == n * x;
  {
    int p = 1;
    int i = 0;
    do
      invariant p == i * x;
    {
      p += x;
      i++;
    } while (i != n);
    return p;
  }
  static void Main(){
    try{
	  Console.WriteLine(Multiply(3, 5));
    }catch(Microsoft.Contracts.AssertException){
      Console.WriteLine("Assertion violation");
    }
  }
}
`
Assertion violation
`
`/debug
// loop invariants: foreach loop: no induction variable; passes
using System;
using System.Collections.Generic;
class Patient{
  public bool IsHealthy;
  public void Heal(){
    IsHealthy = true;
    Console.WriteLine("I'm cured!");
  }
}
class Doctor{
  public void VisitPatients(ICollection<Patient>! patients){
    int initialCount = patients.Count;
    foreach (Patient patient in patients)
      invariant patients.Count == initialCount;
    {
      ((!) patient).Heal();
    }
  }
}
class Test{
  static void Main(){
    try{
      List<Patient> patients = new List<Patient>();
      patients.Add(new Patient());
      patients.Add(new Patient());
      patients.Add(new Patient());
      Doctor doctor = new Doctor();
      doctor.VisitPatients(patients);
    }catch(Microsoft.Contracts.AssertException){
      Console.WriteLine("Assertion violation");
    }
  }
}
`
I'm cured!
I'm cured!
I'm cured!
`
`/debug
// loop invariants: foreach loop: with induction variable; passes
using System;
using System.Collections.Generic;
class Patient{
  public bool IsHealthy;
  public void Heal(){
    IsHealthy = true;
    Console.WriteLine("I'm cured!");
  }
}
class Doctor{
  public void VisitPatients(ICollection<Patient>! patients){
    int initialCount = patients.Count;
    foreach (Patient patient in patients)
      elements_seen patientsSeen;
      invariant forall{Patient patient in patientsSeen; ((!) patient).IsHealthy};
      invariant patients.Count == initialCount;
    {
      ((!) patient).Heal();
    }
  }
}
class Test{
  static void Main(){
    try{
      List<Patient> patients = new List<Patient>();
      patients.Add(new Patient());
      patients.Add(new Patient());
      patients.Add(new Patient());
      Doctor doctor = new Doctor();
      doctor.VisitPatients(patients);
    }catch(Microsoft.Contracts.AssertException){
      Console.WriteLine("Assertion violation");
    }
  }
}
`
I'm cured!
I'm cured!
I'm cured!
`
`/debug
// loop invariants: foreach loop: with induction variable; fails
using System;
using System.Collections.Generic;
class Patient{
  public bool IsHealthy;
  public void Heal(){
    Console.WriteLine("I'm still sick!");
  }
}
class Doctor{
  public void VisitPatients(ICollection<Patient>! patients){
    foreach (Patient patient in patients)
      elements_seen patientsSeen;
      invariant forall{Patient patient in patientsSeen; ((!) patient).IsHealthy};
    {
      ((!) patient).Heal();
    }
  }
}
class Test{
  static void Main(){
    try{
      List<Patient> patients = new List<Patient>();
      patients.Add(new Patient());
      patients.Add(new Patient());
      patients.Add(new Patient());
      Doctor doctor = new Doctor();
      doctor.VisitPatients(patients);
    }catch(Microsoft.Contracts.AssertException){
      Console.WriteLine("Assertion violation");
    }
  }
}
`
I'm still sick!
Assertion violation
`
`
// test to make sure "implicit this" is not available before base calls
public class C {
  public void f(){}
  C(){
    f();
    base();
  }
}
public class M{
  public static void Main(){}
}
`
(5,5): error CS0120: An object reference is required for the nonstatic field, method, or property 'C.f()'
`
`
// test to make sure "this" is not available before base calls
public class C {
  public void f(){}
  C(){
    this.f();
    base();
  }
}
public class M{
  public static void Main(){}
}
`
(5,5): error CS0027: Keyword this is not available in the current context
`
`
public class C {
  string! s = g();
  public void f(){}
  public string! g(){ return "abc"; }
  C(){
    s = "abc";
    base();
    f();
  }
}
public class M{
  public static void Main(){}
}
`
(2,15): error CS0120: An object reference is required for the nonstatic field, method, or property 'C.g()'
`
`/debug
// Bug 145
public class C {
  public static void Main() {}

  public int x;

  private invariant 0 <= x;              // should be illegal
  internal invariant 0 <= x;             // should be illegal
  internal protected invariant 0 <= x;   // should be illegal
  protected internal invariant 0 <= x;   // should be illegal
  protected invariant 0 <= x;            // should be illegal
  public invariant 0 <= x;               // should be illegal

  invariant 0 <= x;  // yeah, this is the way to do it!
}
`
(7,3): error CS0106: The modifier 'private' is not valid for this item
(8,3): error CS0106: The modifier 'internal' is not valid for this item
(9,3): error CS0106: The modifier 'internal' is not valid for this item
(9,12): error CS0106: The modifier 'protected' is not valid for this item
(10,3): error CS0106: The modifier 'protected' is not valid for this item
(10,13): error CS0106: The modifier 'internal' is not valid for this item
(11,3): error CS0106: The modifier 'protected' is not valid for this item
(12,3): error CS0106: The modifier 'public' is not valid for this item
`
`/debug
// checks to make sure that the serialization of the non-null type cast
// that is inserted on the argument "x" doesn't screw anything up.
using Microsoft.Contracts;
public class B{
    [Pure] public bool foo(object! a) { return true; }
}
public class C{
  [Rep] B b;
  object x;
  invariant b.foo(x) == true;
}
public class M{ public static void Main(){} }
`
(10,19): warning CS2613: Conversion to 'object!' fails if the value is null
(10,13): warning CS2614: Receiver might be null (of type 'B')
`
`/debug
class Test{
  public static bool Foo()
    ensures result;
  {
    return true;
  }
  public static void Main()
  {
    Foo();
  }
}
`
`
`/debug
class Cell{
  int x;
  invariant 0 <= x;
  public int X{
    [Microsoft.Contracts.Pure]
    get{
      return x;
    }
  }
}
class Test{
  public static void Foo(int[]! x1, Cell! cell)
    requires x1.IsConsistent;
    requires cell.IsConsistent;
    requires 0 < x1.Length;
    ensures x1.IsConsistent;
    ensures cell.IsConsistent;
    ensures cell.X == old(cell.X);
  {
    x1[0] = cell.X;
  }
  public static void Main(){
    int[] x1 = new int[5];
    Cell cell = new Cell();
    Foo(x1, cell);
  }
}
`
`
`/debug
class Cell{
  int x;
  invariant 0 <= x;
  [Microsoft.Contracts.NotDelayed]
  public Cell(){
    Test.Foo(new int[3], this);
  }
  public int X{
    [Microsoft.Contracts.Pure]
    get{
      return x;
    }
  }
}
class Test{
  public static void Foo(int[]! x1, Cell! cell)
    requires x1.IsConsistent;
    requires cell.IsConsistent;
    requires 0 < x1.Length;
    ensures x1.IsConsistent;
    ensures cell.IsConsistent;
    ensures cell.X == old(cell.X);
  {
    x1[0] = cell.X;
  }
  public static void Main(){
    int[] x1 = new int[5];
    System.Console.WriteLine(1);
    Cell cell = new Cell();
    System.Console.WriteLine(2);
    Foo(x1, cell);
    System.Console.WriteLine(3);
  }
}
`
1
Precondition 'cell.IsConsistent' violated from method 'Test.Foo(optional(Microsoft.Contracts.NonNullType) System.Int32[],optional(Microsoft.Contracts.NonNullType) Cell)'
`
`/debug
class Cell{
  int x;
  invariant 0 <= x;
  [Microsoft.Contracts.NotDelayed]
  public Cell(){
    Test.Foo(new int[3], this);
  }
  public int X{
    [Microsoft.Contracts.Pure]
    get{
      return x;
    }
  }
}
class Test{
  public static void Foo(int[]! x1, object! cell)
    requires x1.IsConsistent;
    requires cell.IsConsistent;
    requires 0 < x1.Length;
    ensures x1.IsConsistent;
    ensures cell.IsConsistent;
  {
    x1[0] = ((Cell) cell).X;
  }
  public static void Main(){
    int[] x1 = new int[5];
    System.Console.WriteLine(1);
    Cell cell = new Cell();
    System.Console.WriteLine(2);
    Foo(x1, cell);
    System.Console.WriteLine(3);
  }
}
`
1
Precondition 'cell.IsConsistent' violated from method 'Test.Foo(optional(Microsoft.Contracts.NonNullType) System.Int32[],optional(Microsoft.Contracts.NonNullType) System.Object)'
`
`/debug
// Check that IsConsistent is available in assertions (in the broad sense) only
class Test{
  bool foo = new object().IsConsistent;
}
`
(3,27): error CS0117: 'object' does not contain a definition for 'IsConsistent'
`
`/debug
class Cell{
  int x;
  invariant 0 <= x;
  
  static void Main(){
    Cell cell = new Cell();
    assert cell.IsConsistent;
    assert cell.IsExposable;
    additive expose (cell){
      assert cell.IsExposed;
      assert cell.IsPrevalid;
      assert cell.IsValid;
    }
    assert cell.IsConsistent;
    assert cell.IsExposable;
  }
}
`
`
`/debug
class Cell{
  int x;
  
  static void Main(){
    Cell cell = new Cell();
    assert cell.IsConsistent;
    assert cell.IsExposable;
    additive expose (cell){
      assert cell.IsExposed;
      assert cell.IsPrevalid;
      assert cell.IsValid;
    }
    assert cell.IsConsistent;
    assert cell.IsExposable;
  }
}
`
`
`/debug
class Cell{
  int x;
  invariant 0 <= x;
  
  static void Main(){
    Cell cell = new Cell();
    try{
      assert cell.IsExposed;
    }catch(System.Exception e){
      System.Console.WriteLine(((!)e.GetType()).Name);
    }
  }
}
`
AssertException
`
`/debug
class Cell{
  int x;
  invariant 0 <= x;
  
  static void Main(){
    Cell cell = new Cell();
    try{
      assert cell.IsPrevalid;
    }catch(System.Exception e){
      System.Console.WriteLine(((!)e.GetType()).Name);
    }
  }
}
`
AssertException
`
`/debug
class Cell{
  int x;
  invariant 0 <= x;
  
  static void Main(){
    Cell cell = new Cell();
    try{
      assert cell.IsValid;
    }catch(System.Exception e){
      System.Console.WriteLine(((!)e.GetType()).Name);
    }
  }
}
`
AssertException
`
`/debug
class Cell{
  int x;
  invariant 0 <= x;
  
  static void Main(){
    Cell cell = new Cell();
    try{
      additive expose (cell){
	      assert cell.IsExposable;
	    }
    }catch(System.Exception e){
      System.Console.WriteLine(((!)e.GetType()).Name);
    }
  }
}
`
AssertException
`
`
// Unqualified pseudomembers
using System;
class Test{
  invariant true;
  [Microsoft.Contracts.NoDefaultContract]
  void Foo()
    requires IsConsistent;
  {}
  static void Main(){
    new Test().Foo();
    Console.WriteLine("PASS");
  }
}
`
PASS
`
`
// Unqualified pseudomembers
using System;
class Test{
  invariant true;
  [Microsoft.Contracts.NoDefaultContract]
  void Foo()
    requires IsConsistent;
  {}
  static void Main(){
    try{
      Test test = new Test();
      additive expose (test){
        test.Foo();
      }
      Console.WriteLine("FAIL");
    }catch(Microsoft.Contracts.RequiresException){
      Console.WriteLine("PASS");
    }
  }
}
`
PASS
`
`
// Unqualified pseudomembers
using System;
class Test{
  invariant true;
  [Microsoft.Contracts.NoDefaultContract]
  void Foo()
    requires IsExposed;
  {}
  static void Main(){
    try{
      new Test().Foo();
      Console.WriteLine("FAIL");
    }catch(Microsoft.Contracts.RequiresException){
      Console.WriteLine("PASS");
    }
  }
}
`
PASS
`
`
// Unqualified pseudomembers
using System;
class Test{
  invariant true;
  [Microsoft.Contracts.NoDefaultContract]
  void Foo()
    requires IsExposed;
  {}
  static void Main(){
    try{
      Test test = new Test();
      additive expose (test){
        test.Foo();
      }
      Console.WriteLine("PASS");
    }catch(Microsoft.Contracts.RequiresException){
      Console.WriteLine("FAIL");
    }
  }
}
`
PASS
`
`
// Unqualified pseudomembers
using System;
class Test{
  invariant true;
  [Microsoft.Contracts.NoDefaultContract]
  void Foo()
    requires IsExposable;
  {}
  static void Main(){
    new Test().Foo();
    Console.WriteLine("PASS");
  }
}
`
PASS
`
`
// Unqualified pseudomembers
using System;
class Test{
  invariant true;
  [Microsoft.Contracts.NoDefaultContract]
  void Foo()
    requires IsExposable;
  {}
  static void Main(){
    try{
      Test test = new Test();
      additive expose (test){
        test.Foo();
      }
      Console.WriteLine("FAIL");
    }catch(Microsoft.Contracts.RequiresException){
      Console.WriteLine("PASS");
    }
  }
}
`
PASS
`
`/debug
// Make sure IsPeerConsistent (more generally any pseudomember) can be used on "result"
// without crashing the contract serializer
// Also, make sure the source contexts include all of the expression
class C{
  object foo(object o)
    requires o.IsPeerConsistent;
    ensures result.IsPeerConsistent;
  { return null; }
  public static void Main(){}
}
`
(6,14): warning CS2613: Conversion to 'object!' fails if the value is null
(7,13): warning CS2612: Null cannot be used where a non-null value is expected
`
`/debug
// Property getters are confined by default
using Microsoft.Contracts;
class Cell{
  int x;
  public int X{
      [Pure]
    get{
      return x;
    }
  }
}
class Interval{
  [Rep] Cell! a;
  [Rep] Cell! b;
  invariant a.X <= b.X;
  
  public Interval(){
    a = new Cell();
    b = new Cell();
    base();
  }
}
class Test{
  static void Main(){
    new Interval();
  }
}
`
`
`/debug
using Microsoft.Contracts;
// Property getters are confined by default, but this can be overridden using NoDefaultContract
class Cell{
  int x;
  public int X{
    [NoDefaultContract]
    get{
      return x;
    }
  }
}
class Interval{
  [Rep] Cell! a;
  [Rep] Cell! b;
  invariant a.X <= b.X;
  
  public Interval(){
    a = new Cell();
    b = new Cell();
    base();
  }
}
class Test{
  static void Main(){
    new Interval();
  }
}
`
(15,13): error CS2631: The member 'Cell.get_X' must be pure, confined or state independent (use custom attributes Contracts.Pure and Contracts.Reads).
(15,20): error CS2631: The member 'Cell.get_X' must be pure, confined or state independent (use custom attributes Contracts.Pure and Contracts.Reads).
`
`
using System;
using Microsoft.Contracts;
class Cell{
  [StrictReadonly] readonly int x;
  
  public Cell(int x){
    this.x = x;
    base();
  }
  
  static void Main(){
    Console.WriteLine(new Cell(3).x);
  }
}
`
3
`
`
using System;
using Microsoft.Contracts;
class Cell{
  [StrictReadonly] readonly int x;
  
  public Cell(int x){
    if (x == 5){
      this.x = 7;
    }
    this.x = x;
    base();
  }
  
  static void Main(){
    Console.WriteLine(new Cell(3).x);
  }
}
`
(10,5): error CS2659: Assignment to [StrictReadonly] field that may already have been assigned is not allowed
`
`
using System;
using Microsoft.Contracts;
class Cell{
  [StrictReadonly] readonly int x;
  
  public Cell(int x){
    this.x = x;
  }
}
`
(7,5): error CS2658: Assignments to [StrictReadonly] fields must occur prior to base class construction
`
`
using System;
using Microsoft.Contracts;
class Cell{
  [StrictReadonly] int x;
  
  public Cell(int x){
    this.x = x;
    base();
  }
}
`
(4,3): error CS2656: A [StrictReadonly] field must be declared readonly
`
`
using System;
using Microsoft.Contracts;
class Cell{
  [StrictReadonly] static readonly int x;
}
`
(4,3): error CS2657: A field must not be declared both static and [StrictReadonly]
`
`
class A{
  public A(int x){}
  public A(bool b){}
}
class B : A{
  int x;
  public B(bool b){
    if (b)
      base(5);
    else
      base(true);
  }
  public B(bool b, int x){
    if (b)
      base(5);
  }
  public B(){
    base(3);
    base(4);
  }
  static void Main(){
    new B(true);
    new B(false);
  }
}
`
(13,3): warning CS2667: Some code paths do not initialize the base class
(19,5): warning CS2668: Possible duplicate constructor call
`
`/debug
// Program point after "assert false" is considered unreachable.
class Test{
  static void Main(){
    try{
      Foo();
      System.Console.WriteLine("2");
    }catch(Microsoft.Contracts.AssertException){
      System.Console.WriteLine("3");
    }
    System.Console.WriteLine("4");
  }
  static int Foo(){
    assert false;
    System.Console.WriteLine("1");
  }
}
`
3
4
`
`/debug
// Program point after "assume false" is considered unreachable.
class Test{
  static void Main(){
    try{
      Foo();
      System.Console.WriteLine("2");
    }catch(Microsoft.Contracts.AssumeException){
      System.Console.WriteLine("3");
    }
    System.Console.WriteLine("4");
  }
  static int Foo(){
    assume false;
    System.Console.WriteLine("1");
  }
}
`
3
4
`
`/debug
// Performing an expose on an unguarded frame should be a no-op
using System;
class Test{
  static void Main(){
    additive expose (new Test()) { Console.WriteLine("Hi!"); }
  }
}
`
Hi!
`
`
// Run-time checks are enabled by default
class Test{
  static void Main(){
    try{
      assert false;
      System.Console.WriteLine("FAIL");
    }catch(Microsoft.Contracts.AssertException){
      System.Console.WriteLine("PASS");
    }
  }
}
`
PASS
`
`/disable:internalchecks
class Test{
  static void Main(){
    try{
      assert false;
      System.Console.WriteLine("PASS");
    }catch(Microsoft.Contracts.AssertException){
      System.Console.WriteLine("FAIL");
    }
  }
}
`
PASS
`
`
class Test{
  public static void Foo()
    requires false;
  {}
  static void Main(){
    try{
      Foo();
      System.Console.WriteLine("FAIL");
    }catch(Microsoft.Contracts.RequiresException){
      System.Console.WriteLine("PASS");
    }
  }
}
`
PASS
`
`/disable:internalchecks
public class Test{
  public static void Foo()
    requires false;
  {}
  static void Main(){
    try{
      Foo();
      System.Console.WriteLine("FAIL");
    }catch(Microsoft.Contracts.RequiresException){
      System.Console.WriteLine("PASS");
    }
  }
}
`
PASS
`
`/disable:defensivechecks
public class Test{
  public static void Foo()
    requires false;
  {}
  static void Main(){
    try{
      Foo();
      System.Console.WriteLine("PASS");
    }catch(Microsoft.Contracts.RequiresException){
      System.Console.WriteLine("FAIL");
    }
  }
}
`
PASS
`
`
class Test{
  invariant false;
  static void Main(){
    try{
      new Test();
      System.Console.WriteLine("FAIL");
    }catch(Microsoft.Contracts.ObjectInvariantException){
      System.Console.WriteLine("PASS");
    }
  }
}
`
PASS
`
`/disable:guardedclasseschecks
class Test{
  invariant false;
  static void Main(){
    try{
      new Test();
      System.Console.WriteLine("PASS");
    }catch(Microsoft.Contracts.ObjectInvariantException){
      System.Console.WriteLine("FAIL");
    }
  }
}
`
PASS
`
`
// Run-time checks are enabled by default
class Test{
  static void Main(){
    try{
      assume false;
      System.Console.WriteLine("FAIL");
    }catch(Microsoft.Contracts.AssumeException){
      System.Console.WriteLine("PASS");
    }
  }
}
`
PASS
`
`/disable:assumechecks
class Test{
  static void Main(){
    try{
      assume false;
      System.Console.WriteLine("PASS");
    }catch(Microsoft.Contracts.AssumeException){
      System.Console.WriteLine("FAIL");
    }
  }
}
`
PASS
`
`
// Exception during contract evaluation throws InvalidContractException
class Test{
  static void Foo()
    requires (new bool[0])[1];
  {}
  static void Main(){
    try{
      Foo();
      System.Console.WriteLine("FAIL");
    }catch(Microsoft.Contracts.InvalidContractException){
      System.Console.WriteLine("PASS");
    }
  }
}
`
Index was outside the bounds of the array.
`
`
// Exception during contract evaluation throws InvalidContractException
class Test{
  static void Foo()
    ensures (new bool[0])[1];
  {}
  static void Main(){
    try{
      Foo();
      System.Console.WriteLine("FAIL");
    }catch(Microsoft.Contracts.InvalidContractException){
      System.Console.WriteLine("PASS");
    }
  }
}
`
Index was outside the bounds of the array.
`
`
// Test of IsNew. Note: IsNew is a temporary measure for specifying aliasing information. It breaks encapsulation.
// In the long term, we should replace it with something like scoped references and unique references or something.
class FooFactory{
  public object CreateFoo()
    ensures result.IsNew;
  {
    return new object();
  }
  static void Main(){
    new FooFactory().CreateFoo();
  }
}
`
`
`
// Modifies clauses with wildcards.
class Test{
  void Foo(int[]! x)
    modifies this.*, x[*];
  {
  }
  static void Main(){
    Test test = new Test();
    int[] a = {1, 2};
    test.Foo(a);
  }
}
`
`
`
//Modelfield - Basic test
class Test {
static void Main() {}
model int mf;	//allowed: default witness and satisfies true.
int model;	//allowed, model keyword is context sensitive
int i;
sealed model int mf2 {
	satisfies this.mf2 == this.i;
	witness this.i;
}
public int m() 
	requires this.mf2 == 4;
	ensures result == this.mf2;
{	return this.i;
}	//allowed: model fields can occur in pre- and postconditions and have public visibility
}
`
`
`
//Modelfield admissibility - visibility checks
class Test {
int i;
internal protected int k;
internal int j;
protected int l;
public int m;

model int mf {
	satisfies this.mf == this.m; //public field always allowed
	satisfies this.mf > this.l; //protected fields always allowed
	satisfies this.mf < this.k; //allowed: Test not visible outside assembly, so field visible to all subclasses 
	satisfies this.mf != this.j; //allowed: Test not visible outside assembly, so field visible to all subclasses	
	satisfies this.mf == this.i; //error: private field only allowed when f sealed (i.e., f or Test has sealed keyword)
}

sealed model int mf2 {
	satisfies this.mf2 == this.i; //allowed, f sealed 
}
}

sealed class Test2 {
int i;
model int mf {
	satisfies this.mf == i;	//allowed, f sealed (as Test2 sealed)
}
}

public class Test3 {
internal int i;
model int mf {
	satisfies this.mf == i;	//error: if mf is overridden in a subclass, i would not be visible.
}	
static void Main() {}
}
`
(14,23): error CS2738: Field i occurs in a satisfies clause of model field mf, but mf can be overridden in a subclass to which i is not visible.
    Possible solutions: make i more visible, or make either mf or Test sealed, or make Test less visible.
(32,23): error CS2738: Field i occurs in a satisfies clause of model field mf, but mf can be overridden in a subclass to which i is not visible.
    Possible solutions: make i more visible, or make either mf or Test3 sealed, or make Test3 less visible.
`
//Modelfield admissibility - references types
class C {}
class D : C {}

class Test {
protected C c;
protected D d;

model C mf5 {
	satisfies this.mf5 == this.c;
	witness this.c;
}  //allowed

model D mf6 {
	satisfies this.mf6 == this.c;
	witness this.c;
}	//allowed

model C mf7 {
	witness this.d; //error: type of witness does not match
}
}
`
(16,10): error CS0029: Cannot implicitly convert type 'C' to 'D'
`
//Modelfield admissibility - owned state
using Microsoft.Contracts;
public class C {
internal int i;
}

class Test {
[Rep] public C c;
model int mf {
	satisfies this.mf == (this.c == null ? 0 : this.c.i);	//allowed: model field can mention owned state
	witness (this.c == null ? 0 : this.c.i);
}
static void Main() {}
}
`
`
`
class Test {
model int mf;
invariant this.mf == 4; 	//model fields can occur in invariants
model int mfSat { satisfies this.mfSat == this.mf; } //model fields can occur in satisfies clauses
static void Main() {}
}
`
`
//Modelfield admissibility - Inheritance tests
using Microsoft.Contracts;
class C {

[Additive] public int i;
public int j;
model int mf {
	satisfies this.mf > this.i;
	witness this.i+1;
}
sealed model int mf2;
public void m() {}

}

class D : C {

override model int mf {
	satisfies this.mf == this.i+2;
	witness this.i+2;
} //allowed

model int mfNoAdd {
	satisfies this.mfNoAdd == this.j; //error: only additive superclass fields are allowed.
	witness this.j;
}

model int m;	//warning: hides superclass member without new keyword.

new model int mf2; //allowed. 

}
`
(28,11): warning CS0108: The keyword new is required on 'D.m' because it hides inherited member 'C.m()'
(12,13): (Location of symbol related to previous warning)
(24,28): error CS2701: Field access not admissible: 'j' should be marked Additive.
`
`/debug+
//Modelfield admissibility - Interface tests
interface I {
	model int i;
}

interface J : I {
	model int i;	//disallowed
	
}

interface K : I {
	override model int i; 	//disallowed (could be allowed, but complicates matters)
}

interface L {
	model int i;
}

class Cwithi : I {
	model int i;	//allowed, C.i will implement I.i;
}

public class C : I {
	//allowed, new model field that implements I.i is created implicitly
}


class D : I,L {
	//disallowed: can't implement 2 interface that both define a model field i (prevents unexpected modification)
} 

class E {
	model int i;
}

class F : E,I {
	//disallowed (prevents unexpected modification)
}

class G : E,I {
	new model int i;	//allowed.
}

class H : C {
	override model int i;	//allowed, overrides the model field implicitly added to C.
}

public interface M {
  [Rep] model C mf;   //interfaces can own model fields 
}
`
(12,2): error CS0106: The modifier 'override' is not valid for this item
(7,12): warning CS0114: 'J.i' hides inherited member 'I.i'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.
(3,12): (Location of symbol related to previous warning)
(12,21): warning CS0114: 'K.i' hides inherited member 'I.i'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.
(3,12): (Location of symbol related to previous warning)
(28,1): error CS2739: Class D cannot implement two interfaces that both define a model field i
(0,0): error CS2628: Requires not allowed in interface implementation of 'L.i.get'.
(36,1): error CS2739: Class F does not define a model field i that implements I.i and hides E.i
(3,12): (Location of symbol related to previous error)
(33,12): (Location of symbol related to previous error)
(36,7): error CS0535: 'F' does not implement interface member 'I.i.get'
`
//Modelfield Runtime tests
//Throw ModelfieldException when Modelfield's satisfies clause not satisfied on pack. 
class Test{
  model int f {
	satisfies this.f == 4;
	witness 3;
  }
  static void Main(){
    try{
      new Test();
      System.Console.WriteLine("FAIL");
    }catch(Microsoft.Contracts.ModelfieldException){
      System.Console.WriteLine("PASS");
    }
  }
}
`
PASS
`
//Do not throw ModelfieldException when Modelfield's satisfies clause is satisfied on pack. 
class Test{
  protected int g;
  model int f {
	satisfies this.f == this.g;
	witness this.g;
  }  
  static void Main(){    
    new Test();    
  }
}
`
`
`
class C{
  object!! test = "a";
  public static void Main(){}
}
`
(2,3): warning CS2552: Type 'object!' already cannot be null
`
`
:=1 =2 =3
// test to make sure that non-reserved keywords can still be used as identifiers
using System;
class C{
  public void f(int count, int forall, int get){
    Console.WriteLine("count = " + count);
    Console.WriteLine("forall = " + forall);
    Console.WriteLine("get = " + get);
    count = count + 1;
    get++;
    forall++;
    Console.WriteLine("count = " + count);
    Console.WriteLine("forall = " + forall);
    Console.WriteLine("get = " + get);
  }
}
class M{
  public static void Main(string[]! args)
    requires args.Length > 2;
  {
    int x = Convert.ToInt32(args[0]);
    int y = Convert.ToInt32(args[1]);
    int z = Convert.ToInt32(args[2]);
    new C().f(x,y,z);
}}
`
count = 1
forall = 2
get = 3
count = 2
forall = 3
get = 4
`
public class ParamMixup {
  public static void Main() {
    string[] myArgs = {"hello", "bye"};

    M("this is my format {0}", "hello");
    M("this is my format {0}", "hello", "bye");
    M("this is my format {0}", myArgs);

    P("this is my format {0}", "hello");
    P("this is my format {0}", "hello", "bye");
    P("this is my format {0}", myArgs);
  }

  public static void M(string! format, string! arg0) {
    System.Console.WriteLine("Calling the arg0 version of M");
  }

  public static void M(string! format, params string[]! args) {
    System.Console.WriteLine("Calling the array-args version of M");
  }

  public static void P(string! format, object! arg0) {
    System.Console.WriteLine("Calling the arg0 version of P");
  }

  public static void P(string! format, params object[]! args) {
    System.Console.WriteLine("Calling the array-args version of P");
  }
}
`
Calling the arg0 version of M
Calling the array-args version of M
Calling the array-args version of M
Calling the arg0 version of P
Calling the array-args version of P
Calling the array-args version of P
`
`
// Base constructor marking (needed for C# compatibility)
using System;
public class C {
  protected int i;
  public C(int z) { this.i = z; }
  public C() { this.i = 27; }
}
public class D : C{
  string! x;
  public D() : base(3){
    x = "abc";
    base;
  }
  public string X { get { return x + this.i; } }
}
public class M { public static void Main(){ Console.WriteLine(new D().X); } }
`
abc3
`
`
// Base constructor marking (needed for C# compatibility)
using System;
public class C {
  protected int i;
  public C() { this.i = 27; }
}
public class D : C{
  string! x;
  public D() : base(3){
    x = "abc";
    base;
  }
  public string X { get { return x + this.i; } }
}
public class M { public static void Main(){ Console.WriteLine(new D().X); } }
`
(9,16): error CS1501: No overload for method 'C' takes '1' arguments
(5,10): (Location of symbol related to previous error)
`
`
// Base constructor marking (needed for C# compatibility)
using System;
public class C {
  protected int i;
  public C() { this.i = 27; }
}
public class D : C{
  string! x;
  public D(){
    x = "abc";
    base;
  }
  public string X { get { return x + this.i; } }
}
public class M { public static void Main(){ Console.WriteLine(new D().X); } }
`
(11,5): error CS0201: Only assignment, call, increment, decrement, and new object expressions can be used as a statement
`
`
using System;
public class A{ public override string! ToString() { return "a"; } }
public class B:A{ public override string! ToString() { return "b"; } }
public class C:B{ public override string! ToString() { return "c"; } }
public class M{
  public static void f(object! o){
    string s = o.ToString();
    Console.WriteLine(s);
  }
  public static void Main(){
    f(new A());
    f(new B());
    f(new C());
  }
}
`
a
b
c
`
`
using System;
public class A{ public override string! ToString() { return "a"; } }
public class B:A{ public override string ToString() { return "b"; } }
public class C:B{ public override string! ToString() { return "c"; } }
public class M{
  public static void f(object! o){
    string s = o.ToString();
    Console.WriteLine(s);
  }
  public static void Main(){
    f(new A());
    f(new B());
    f(new C());
  }
}
`
(3,42): error CS0508: 'B.ToString()': cannot change return type when overriding inherited member 'A.ToString()'
(2,41): (Location of symbol related to previous error)
`
`/debug+ /d:DEBUG
// Tests whether or not implicit non-null coercions work for generics
using System;
class C<T>{
  public T x;
  public void g() { h(x); }
  public void h(T! t){
    if (t == null)
      Console.WriteLine("null: " + typeof(T).ToString());
    else
      Console.WriteLine(t.ToString() + ": " + typeof(T).ToString());
  }
}
class M{
  public static void Main(){
    try{
      C<int> c1 = new C<int>();
      c1.g();
      C<string> c2 = new C<string>();
      c2.g();
    }
    catch (Exception e) {
      Console.WriteLine("Caught '{0}'.", e.GetType().ToString());
    }
  }
}
`
(5,23): warning CS2613: Conversion to 'T!' fails if the value is null
0: System.Int32
Caught 'Microsoft.Contracts.NullException'.
`
`/debug+
// Tests whether or not precondition for h's parameter is generated correctly for generics.
using System;
class C<T>{
  public T x;
  public void g() { h(x); }
  public void h(T! t){
    if (t == null)
      Console.WriteLine("null: " + typeof(T).ToString());
    else
      Console.WriteLine(t.ToString() + ": " + typeof(T).ToString());
  }
}
class M{
  public static void Main(){
    C<int> c1 = new C<int>();
    c1.x = 3;
    c1.g();
    C<string> c2 = new C<string>();
    c2.x = "abc";
    c2.g();
  }
}
`
(5,23): warning CS2613: Conversion to 'T!' fails if the value is null
3: System.Int32
abc: System.String
`
`/debug
// Tests whether or not explicit non-null coercions work for generics
using System;
class C<T>{
  public T x;
  public void g() { h(x); }
  public void h(T t)
  { Console.WriteLine(((!)t).ToString()); }
}
class M{
  public static void Main(){
    C<int> c = new C<int>();
    c.x = 3;
    c.g();
  }
}
`
3
`
`/debug
// Tests to see if /*^...^*/ is seen as Spec# (i.e., no space required after the opening "/*^").
// Same for //^.
// But /*^^... should be parsed as a comment. (same for //^^...)
class C{
  public void foo(string/*^!^*/ s){ } // s should be recognized as a non-null string
  public void bar(string s){  foo(s); } // error if foo takes a non-null string
  public string //^!
    baz(){ return "abc"; } // baz should be recognized as returning a non-null string
  //^^^^^^^ But I'm a comment! ^^^^^^^
  public void baz2() { foo(baz()); } // no complaint if baz returns a non-null string
  /*^^ And so am I! ^^*/
}
class M{ public static void Main(){ } }
`
(6,35): warning CS2613: Conversion to 'string!' fails if the value is null
`
// Test that properties can be used as ref and out paramters.
using System;
class Test {

  int foo;
  int Foo { set { this.foo = value; }
            get { return this.foo; } }

  public static void TestByRef(ref int x) {
    x++;
  }

  public static void TestOut(out int x, int y) {
    x = y;
  }

  public static void Main() {

    Test t = new Test();

    TestOut(out t.Foo, 5);
    if (t.Foo != 5) { Console.WriteLine("Failed"); }
    TestByRef(ref t.Foo);
    if (t.Foo != 6) { Console.WriteLine("Failed"); }
  }
  
}
`
`
namespace ConsoleApplication1
{
    class Program
    {
        static int Foo { get { return 0; } set { } }
        public static void Bar(ref int f){ f = 0;}
        public static void Main(){ Bar( ref Foo);}
    }
 
}
`
`
`/debug
// check to make sure that the same context conditions are imposed on assert/assume
// statements as on other contract elements in terms of pure methods
using System;
using Microsoft.Contracts;
class C{
  public int f(){ return 3; }
}
class M{
   void foo(C! c){
     assert c.f() > 0;
   }
   public static void Main(){}
}
`
(10,13): error CS2621: The member 'C.f' must be pure, confined or state independent (use custom attributes Contracts.Pure and Contracts.Reads).
`
`/debug
// check to make sure that the same context conditions are imposed on assert/assume
// statements as on other contract elements in terms of pure methods
using System;
using Microsoft.Contracts;
class C{
  [Pure][Reads(ReadsAttribute.Reads.Everything)] public int f(){ return 3; }
}
class M{
   void foo(C! c){
     assert c.f() > 0;
   }
   public static void Main(){}
}
`
`
using System;
class C{
  public int Test1<T>(T x, T y){
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test2<T>(T x, T/*!*/ y){
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test3<T>(T x, T/*?*/ y){
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test4<T>(T x, object y){
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test5<T>(T x){
    if (x == null)
        return 0;
    else
        return 1;
  }
  public int Test6<T>(T x, string y){
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test7<T>(T x, C y) {
    if (x == y)
        return 0;
    else
        return 1;
  }
  
    //////////////////////////////////////////////
  public int Test11<T>(T x, T y) where T:struct{
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test13<T>(T x, T/*?*/ y) where T:struct{
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test14<T>(T x, object y) where T:struct{
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test15<T>(T x) where T:struct{
    if (x == null)
        return 0;
    else
        return 1;
  }
  public int Test16<T>(T x, string y) where T:struct{
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test17<T>(T x, C y) where T:struct{
    if (x == y)
        return 0;
    else
        return 1;
  }
  
    //////////////////////////////////////////////
  public int Test21<T>(T x, T y) where T:class{
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test22<T>(T x, T/*!*/ y) where T:class{
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test23<T>(T x, T/*?*/ y) where T:class{
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test24<T>(T x, object y) where T:class{
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test25<T>(T x) where T:class{
    if (x == null)
        return 0;
    else
        return 1;
  }
  public int Test26<T>(T x, string y) where T:class{
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test27<T>(T x, C y) where T:class{
    if (x == y)
        return 0;
    else
        return 1;
  }

    //////////////////////////////////////////////

  public int Test31<T,R>(T x, R y){
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test32<T,R>(T x, R/*!*/ y){
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test33<T,R>(T x, R/*?*/ y){
    if (x == y)
        return 0;
    else
        return 1;
  }
  
    //////////////////////////////////////////////
  public int Test41<T,R>(T x, R y) where T:struct{
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test42<T,R>(T x, R/*!*/ y) where T:struct {
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test43<T,R>(T x, R/*?*/ y) where T:struct{
    if (x == y)
        return 0;
    else
        return 1;
  }
  
    //////////////////////////////////////////////
  public int Test51<T,R>(T x, R y) where T:class{
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test52<T,R>(T x, R/*!*/ y) where T:class {
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test53<T,R>(T x, R/*?*/ y) where T:class{
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test54<T,R>(T/*!*/ x, R y) where T:class {
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test55<T,R>(T/*!*/ x, R/*!*/ y) where T:class {
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test56<T,R>(T/*!*/ x, R/*?*/ y) where T:class{
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test57<T,R>(T/*?*/ x, R y) where T:class {
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test58<T,R>(T/*?*/ x, R/*!*/ y) where T:class {
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test59<T,R>(T/*?*/ x, R/*?*/ y) where T:class{
    if (x == y)
        return 0;
    else
        return 1;
  }
  
    //////////////////////////////////////////////
  public int Test61<T,R>(T x, R y) where T:class where R:class{
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test62<T,R>(T x, R/*!*/ y) where T:class where R:class {
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test63<T,R>(T x, R/*?*/ y) where T:class where R:class{
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test64<T,R>(T/*!*/ x, R/*!*/ y) where T:class where R:class {
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test65<T,R>(T/*!*/ x, R/*?*/ y) where T:class where R:class{
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test66<T,R>(T/*?*/ x, R/*?*/ y) where T:class where R:class{
    if (x == y)
        return 0;
    else
        return 1;
  }
  
    //////////////////////////////////////////////
  public int Test71<T,R>(T x, R y) where T:class where R:struct{
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test72<T,R>(T/*!*/ x, R y) where T:class where R:struct {
    if (x == y)
        return 0;
    else
        return 1;
  }
  public int Test73<T,R>(T/*?*/ x, R y) where T:class where R:struct{
    if (x == y)
        return 0;
    else
        return 1;
  }
  
    //////////////////////////////////////////////
  public int Test81<T,R>(T x, R y) where T:struct where R:struct{
    if (x == y)
        return 0;
    else
        return 1;
  }
    //////////////////////////////////////////////

}
`
(4,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'T'
(10,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'T'
(16,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'T'
(22,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'object'
(34,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'string'
(40,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'C'
(48,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'T'
(54,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'T?'
(60,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'object'
(66,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and '<null>'
(72,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'string'
(78,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'C'
(131,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
(137,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
(143,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
(151,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
(157,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
(163,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
(171,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
(177,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
(183,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
(189,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
(195,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
(201,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
(207,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
(213,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
(219,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
(265,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
(271,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
(277,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
(285,9): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'R'
`
`
internal enum ContainerState : byte {
    Initialized,
    StartedLoading,
    Loaded,
  }
 
internal abstract class ScopedContainerMetadataObject {
    protected internal ContainerState ContainerState;
    internal void AddMember()
      //^ requires this.ContainerState != ContainerState.Loaded;
    {
    }
}
 
public class foo{
  public static void Main(string[] s){
  }
}
`
`
`/unsafe /nn
unsafe internal struct LittleEndianMemoryReader{
    internal LittleEndianMemoryReader(
      byte* buffer,
      int length,
      int offset
    )
      //^ requires buffer != null;
      //^ requires buffer + length < buffer;
    {
    }
 
}
 
public unsafe class foo{
  public static unsafe void Main(string[] s){}
}
`
`
`/debug
using Microsoft.Contracts;
class B{ [MustOverride] public void foo(){} }
class C:B{ public static void Main(){} }
`
(2,37): error CS2680: 'B.foo()' is marked as MustOverride, but is not virtual
`
`/debug
using Microsoft.Contracts;
class B{ [MustOverride] public virtual void foo(){} }
class C:B{ public static void Main(){} }
`
(3,7): error CS2678: 'C' does not implement the method 'B.foo()' which is marked as MustOverride
(2,45): (Location of symbol related to previous error)
`
`/debug
using Microsoft.Contracts;
class B{ [MustOverride] public virtual void foo(){} }
class C:B{ public override void foo(){} public static void Main(){} }
`
(3,7): error CS2679: 'C.foo()' must be marked as MustOverride
`
`/debug
using Microsoft.Contracts;
class B{ [MustOverride] public virtual void foo(){} }
class C:B{ [MustOverride] public override void foo(){} public static void Main(){} }
`
`
`/debug
// Don't complain about marking MustOverride methods with the attribute
// for sealed classes.
using Microsoft.Contracts;
class B{ [MustOverride] public virtual void foo(){} }
sealed class C:B{ public override void foo(){} public static void Main(){} }
`
`
`/debug
using System;
using Microsoft.Contracts;
class A { 
  public B g; public int f;
  invariant this.g;   // error: expression is not of type bool
  invariant this.f;   // error: expression is not of type bool

  void m() 
    requires this.g;  // error: expression is not of type bool
    ensures this.f;   // error: expression is not of type bool
  { }
}
class B { }
`
(9,14): error CS0029: Cannot implicitly convert type 'B' to 'bool'
(10,13): error CS0029: Cannot implicitly convert type 'int' to 'bool'
(5,13): error CS0029: Cannot implicitly convert type 'B' to 'bool'
(6,13): error CS0029: Cannot implicitly convert type 'int' to 'bool'
`
`/debug
using System;
using Microsoft.Contracts;

class E1 : CheckedException {}
class A { 
  public object f;
  void m()
    requires this.f otherwise InvalidOperationException; // error: condition is not of type bool
    throws E1 ensures this.f;                            // error: condition is not of type bool
  { }
}
`
(8,14): error CS0029: Cannot implicitly convert type 'object' to 'bool'
(9,23): error CS0029: Cannot implicitly convert type 'object' to 'bool'
`
`/debug
using System;
using Microsoft.Contracts;

class A : Object { }
[Immutable] class B : Object { }
class C : A { }
[Immutable] class D : B { }

[Immutable] class E {
  [Rep] Object f;
  Object g;
}
class F {
  E f;
  [Rep] Object g;
}

[Immutable] class G {
  bool b;
  public G(bool value) {
    b = value;
    base();
  } 
}
[Immutable] class H : G {
  int i;
  H(int valueI, bool valueB) {
    i = valueI;
    base(valueB);
  }
}

[Immutable] interface IA { }
interface IB { }
[Immutable] interface IC : IA { }
interface ID : IB { }
[Immutable] interface IE { }
[Immutable] interface IF : IA, IE { }
[Immutable] class CA : IC, IE { }
interface IG { }
class CB : IB, IG { public static void Main() { }}
[Immutable] interface IH : IB { }
[Immutable] class CC : IE, IB { }
`
`
`/debug
using System;
using Microsoft.Contracts;

[Immutable] class A { }
class B : A { }
class C { }
[Immutable] class D : C { }

[Immutable] class E {
  [Peer] Object f;
}
class F {
  [Peer] E f;
  [Rep] E g;
}

[Immutable] class G {
  bool b;
  public G(bool value) { b = value; base(); } 
}
[Immutable] class H : G {
  int i;
  H(int valueI, bool valueB) {
    base(valueB);    
    i = valueI;
  }
}

[Immutable] interface IA { }
interface IB : IA { }
interface IC { }
class BB : IA, IC { }
`
(5,7): error CS2684: Mutable classes cannot have immutable base classes.
(7,19): error CS2685: Immutable classes cannot have mutable base classes.
(10,17): error CS2689: Immutable classes cannot have peer fields.
(13,12): error CS2688: Peer and rep fields cannot be of immutable type.
(14,11): error CS2688: Peer and rep fields cannot be of immutable type.
(30,11): error CS2687: Mutable interfaces cannot extend immutable interfaces.
(32,7): error CS2686: Mutable classes cannot implement immutable interfaces.
`
`/debug
using Microsoft.Contracts;
abstract class A {
  [Additive(true)] public abstract void m(); 
}
class B : A {
  public static void Main() { }
  [Additive] public override void m() { }
  [Additive(false)] private void n() { }
  [Additive] public virtual void o() { }
  private void p() { }
}
class C : B {
  [Additive(true)] public override void m() { }
}
`
`
`/debug
using Microsoft.Contracts;
abstract class A {
  [Additive] public abstract void m();
}
class B : A {
  public override void m() { }
  public virtual void n() { }
}
class C: B {
  [Additive] public override void n() { }
}
class D {
  [Additive] public void foo() { }
  [Additive(true)] public void goo() { }
  [Additive(false)] public void boo() { }
  [Additive] public static C staticfooBad() { }
  [return: Additive] public static C staticfooGood() { }
  [return: Additive] public static void staticfooBadAgain() { }
  public void fooParam([Additive] C c) { }
  public void fooBadParam([Additive] int x) { }
}
`
(6,3): error CS2683: Overriding methods must have same 'Microsoft.Contracts.AdditiveAttribute' annotation as the overriden method.
(10,3): error CS2683: Overriding methods must have same 'Microsoft.Contracts.AdditiveAttribute' annotation as the overriden method.
(16,3): error CS2682: Static methods cannot be marked as 'Microsoft.Contracts.AdditiveAttribute'.
(18,4): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.AdditiveAttribute' annotation.
(20,28): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.AdditiveAttribute' annotation.
`
`/debug
using Microsoft.Contracts;
class Empty{}

static class Stat{

  // OK: reference-type return value marked as Inside
  [return:Inside] static public object Return0() { }
  // ERROR: non reference-type return value marked as Inside
  [return:Inside] static public int Return1() { }
  // OK: reference-type return value marked as Additive
  [return:Additive] static public object Return2() { }
  // ERROR: non reference-type return value marked as Additive
  [return:Additive] static public int Return3() { }
  // ERROR: reference-type return value marked as Captured
  [return:Captured] static public object Return4() { }
  // ERROR: non reference-type return value marked as Captured
  [return:Captured] static public int Return5() { }

  // OK: reference-type parameter marked as Inside
  static public void Parameter0([Inside] object o) { }
  // ERROR: non reference-type parameter marked as Inside
  static public void Parameter1([Inside] int o) { }

  // OK: reference-type parameter marked as Additive
  static public void Parameter2([Additive] object o) { }
  // ERROR: non reference-type parameter marked as Additive
  static public void Parameter3([Additive] int o) { }

  // OK: reference-type parameter marked as Captured
  static public void Parameter4([Captured] object o) { }
  // ERROR: non reference-type parameter marked as Captured
  static public void Parameter5([Captured] int o) { }
}

interface I{
  // ERROR: receiver marked as Inside on interface method
  [Inside] void I_Inside();
  // OK: receiver marked as Additive on interface method
  [Additive] void I_Additive();
  // OK: receiver marked as Captured on interface method
  [Captured] void I_Captured();

  // OK: reference-type return value marked as Inside
  [return:Inside] object Return0();
  // ERROR: non reference-type return value marked as Inside
  [return:Inside] int Return1();
  // OK: reference-type return value marked as Additive
  [return:Additive] object Return2();
  // ERROR: non reference-type return value marked as Additive
  [return:Additive] int Return3();
  // ERROR: reference-type return value marked as Captured
  [return:Captured] object Return4();
  // ERROR: non reference-type return value marked as Captured
  [return:Captured] int Return5();

  // OK: reference-type parameter marked as Inside
  void Parameter0([Inside] object o);
  // ERROR: non reference-type parameter marked as Inside
  void Parameter1([Inside] int o);

  // OK: reference-type parameter marked as Additive
  void Parameter2([Additive] object o);
  // ERROR: non reference-type parameter marked as Additive
  void Parameter3([Additive] int o);

  // OK: reference-type parameter marked as Captured
  void Parameter4([Captured] object o);
  // ERROR: non reference-type parameter marked as Captured
  void Parameter5([Captured] int o);
}


abstract class A {
  // ERROR: virtual methods cannot be marked as Inside
  [Inside] public abstract void M0();
  // OK: virtual methods can be marked as Captured
  [Captured] public abstract void M1();
  // OK: virtual methods can be marked as Additive
  [Additive] public abstract void M2();
}
class B_Good : A {
  public override void M0() { } // OK
  [Captured] public override void M1(){ } // OK
  [Additive] public override void M2(){ } // OK
  public virtual void N0() { }
}
class B_Bad : A {
  [Inside] public override void M0() { } // ERROR
  public override void M1(){ } // ERROR: override needs annotation
  public override void M2(){ } // ERROR: override needs annotation
}
class C: B_Good {
  [Inside] Empty e0; // ERROR: cannot mark fields as Inside
  [Additive] public Empty e1; // OK: can mark fields as Additive if non-private and of a reference type
  [Additive] protected Empty e2; // OK: can mark fields as Additive if non-private and of a reference type
  [Additive] private Empty e3; // ERROR: cannot mark fields as Additive if private
  [Additive] int e4; // ERROR: cannot mark fields as Additive if not of a reference type
  [Captured] Empty e5; // ERROR: cannot mark fields as Captured

  [Inside] public override void n() { } // ERROR: override needs annotation
}
struct S{
  // ERROR: receiver marked as Inside on value type
  [Inside] public void M_Inside() { }
  // ERROR: receiver marked as Additive on value type
  [Additive] public void M_Additive() { }
  // ERROR: receiver marked as Captured on value type
  [Captured] public void M_Captured() { }

  // OK: reference-type return value marked as Inside
  [return:Inside]
  public object Return0() { }
  // ERROR: non reference-type return value marked as Inside
  [return:Inside]
  public int Return1() { }

  // OK: reference-type return value marked as Additive
  [return:Additive]
  public object Return2() { }
  // ERROR: non reference-type return value marked as Additive
  [return:Additive]
  public int Return3() { }

  // ERROR: reference-type return value marked as Captured
  [return:Captured]
  public object Return4() { }
  // ERROR: non reference-type return value marked as Captured
  [return:Captured]
  public int Return5() { }

  // OK: reference-type parameter marked as Inside
  public void Parameter0([Inside] object o) { }
  // ERROR: non reference-type parameter marked as Inside
  public void Parameter1([Inside] int o) { }

  // OK: reference-type parameter marked as Additive
  public void Parameter2([Additive] object o) { }
  // ERROR: non reference-type parameter marked as Additive
  public void Parameter3([Additive] int o) { }

  // OK: reference-type parameter marked as Captured
  public void Parameter4([Captured] object o) { }
  // ERROR: non reference-type parameter marked as Captured
  public void Parameter5([Captured] int o) { }

}
class D {
  // ERROR: ctor cannot be marked as Additive
  [Additive] public D(){}
  // ERROR: ctor marked as Inside
  [Inside] public D(int x){}
  // OK: ctor marked as Captured
  [Captured] public D(int x, int y){}

  // ERROR: virtual method has receiver marked as Inside
  [Inside]
  public virtual void Virtual1() { }
  // OK: non-virtual method has receiver marked as Inside
  [Inside]
  public void NonVirtual2() { }

  // OK: reference-type parameter marked as Inside
  public void Parameter0([Inside] object o) { }
  // ERROR: non reference-type parameter marked as Inside
  public void Parameter1([Inside] int o) { }
  // OK: reference-type parameter marked as Additive
  public void Parameter2([Additive] object o) { }
  // ERROR: non reference-type parameter marked as Additive
  public void Parameter3([Additive] int o) { }
  // OK: reference-type parameter marked as Captured
  public void Parameter4([Captured] object o) { }
  // ERROR: non reference-type parameter marked as Captured
  public void Parameter5([Captured] int o) { }

  // OK: out parameter marked as Inside
  public void Parameter6([Inside] out object o) { o = this; }
  // OK: out parameter marked as Additive
  public void Parameter7([Additive] out object o) { o = this; }
  // ERROR: out parameter marked as Captured
  public void Parameter8([Captured] out object o) { o = this; }
  // OK: ref parameter marked as Inside
  public void Parameter9([Inside] ref object o) { }
  // OK: ref  parameter marked as Additive
  public void Parameter10([Additive] ref object o) { }
  // OK: ref parameter marked as Captured
  public void Parameter11([Captured] ref object o) { }


  // OK: reference-type return value marked as Inside
  [return:Inside] public object Return0() { }
  // ERROR: non reference-type return value marked as Inside
  [return:Inside] public int Return1() { }
  // OK: reference-type return value marked as Additive
  [return:Additive] public object Return2() { }
  // ERROR: non reference-type return value marked as Additive
  [return:Additive] public int Return3() { }
  // ERROR: reference-type return value marked as Captured
  [return:Captured] public object Return4() { }
  // ERROR: non reference-type return value marked as Captured
  [return:Captured] public int Return5() { }

}

// ERROR: delegate marked as Inside
[Inside] public delegate object Del0(object o);
// ERROR: delegate marked as Additive
[Additive] public delegate object Del1(object o);
// ERROR: delegate marked as Captured
[Captured] public delegate object Del2(object o);
`
(9,4): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.InsideAttribute' annotation.
(13,4): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.AdditiveAttribute' annotation.
(15,11): error CS0592: Attribute 'Captured' is not valid on this declaration type. It is valid on 'constructor, method, param' declarations only.
(17,11): error CS0592: Attribute 'Captured' is not valid on this declaration type. It is valid on 'constructor, method, param' declarations only.
(22,34): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.InsideAttribute' annotation.
(27,34): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.AdditiveAttribute' annotation.
(32,34): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.CapturedAttribute' annotation.
(37,4): error CS2719: Interface methods cannot be marked as 'Microsoft.Contracts.InsideAttribute'.
(46,4): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.InsideAttribute' annotation.
(50,4): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.AdditiveAttribute' annotation.
(52,11): error CS0592: Attribute 'Captured' is not valid on this declaration type. It is valid on 'constructor, method, param' declarations only.
(54,11): error CS0592: Attribute 'Captured' is not valid on this declaration type. It is valid on 'constructor, method, param' declarations only.
(59,20): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.InsideAttribute' annotation.
(64,20): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.AdditiveAttribute' annotation.
(69,20): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.CapturedAttribute' annotation.
(75,3): error CS2718: Virtual methods cannot be marked as 'Microsoft.Contracts.InsideAttribute'.
(88,3): error CS2718: Virtual methods cannot be marked as 'Microsoft.Contracts.InsideAttribute'.
(89,3): error CS2683: Overriding methods must have same 'Microsoft.Contracts.CapturedAttribute' annotation as the overriden method.
(90,3): error CS2683: Overriding methods must have same 'Microsoft.Contracts.AdditiveAttribute' annotation as the overriden method.
(100,33): error CS0115: 'C.n()': no suitable method found to override
(93,4): error CS0592: Attribute 'Inside' is not valid on this declaration type. It is valid on 'method, param, return' declarations only.
(96,4): error CS2720: Private member cannot be marked as 'Microsoft.Contracts.AdditiveAttribute'.
(97,4): error CS2720: Private member cannot be marked as 'Microsoft.Contracts.AdditiveAttribute'.
(98,4): error CS0592: Attribute 'Captured' is not valid on this declaration type. It is valid on 'constructor, method, param' declarations only.
(100,3): error CS2718: Virtual methods cannot be marked as 'Microsoft.Contracts.InsideAttribute'.
(104,4): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.InsideAttribute' annotation.
(106,4): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.AdditiveAttribute' annotation.
(108,4): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.CapturedAttribute' annotation.
(114,4): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.InsideAttribute' annotation.
(121,4): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.AdditiveAttribute' annotation.
(125,11): error CS0592: Attribute 'Captured' is not valid on this declaration type. It is valid on 'constructor, method, param' declarations only.
(128,11): error CS0592: Attribute 'Captured' is not valid on this declaration type. It is valid on 'constructor, method, param' declarations only.
(134,27): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.InsideAttribute' annotation.
(139,27): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.AdditiveAttribute' annotation.
(144,27): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.CapturedAttribute' annotation.
(149,4): error CS0592: Attribute 'Additive' is not valid on this declaration type. It is valid on 'field, method, param, return' declarations only.
(151,4): error CS0592: Attribute 'Inside' is not valid on this declaration type. It is valid on 'method, param, return' declarations only.
(156,3): error CS2718: Virtual methods cannot be marked as 'Microsoft.Contracts.InsideAttribute'.
(165,27): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.InsideAttribute' annotation.
(169,27): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.AdditiveAttribute' annotation.
(173,27): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.CapturedAttribute' annotation.
(180,27): error CS2722: Only in-parameters can be marked as 'Microsoft.Contracts.CapturedAttribute'.
(192,4): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.InsideAttribute' annotation.
(196,4): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.AdditiveAttribute' annotation.
(198,11): error CS0592: Attribute 'Captured' is not valid on this declaration type. It is valid on 'constructor, method, param' declarations only.
(200,11): error CS0592: Attribute 'Captured' is not valid on this declaration type. It is valid on 'constructor, method, param' declarations only.
(205,2): error CS0592: Attribute 'Inside' is not valid on this declaration type. It is valid on 'method, param, return' declarations only.
(207,2): error CS0592: Attribute 'Additive' is not valid on this declaration type. It is valid on 'field, method, param, return' declarations only.
(209,2): error CS0592: Attribute 'Captured' is not valid on this declaration type. It is valid on 'constructor, method, param' declarations only.
`
`/debug
using System;
using Microsoft.Contracts;

public interface Interface{}
[Immutable] public interface ImmutableInterface{}
public class C : ImmutableInterface {} // error: Mutable classes cannot implemement immutable interfaces
public class B : Interface {} 
[Immutable] public class ImmutableClass : Interface, ImmutableInterface {} 
[Immutable] public class ImmutableB : B {} // error: immutable classes can not have mutable base classes
public class D : ImmutableClass {} // error: Mutable classes can not have immutable base classes
[Immutable] public class ImmutableOwnerClass  {
  [Rep] ImmutableClass r0; // error: Peer and rep fields cannot be of immutable type
  [Peer] ImmutableClass p0;  // error: Immutable classes cannot have peer fields + error: Peer and rep fields cannot be of immutable type
  [Rep] ImmutableInterface r1; // error: Peer and rep fields cannot be of immutable type
  [Peer] ImmutableInterface p1; // error: Immutable classes cannot have peer fields + error: Peer and rep fields cannot be of immutable type
  [Rep] B r2; 
  [Peer] B p2;  // error: Immutable classes cannot have peer fields
  [Peer] string s;  // should generate an error once System.String has the [Immutable] attribute
  B b;
  Interface i;
  ImmutableInterface imf;
  ImmutableClass imc;
} 
[Immutable] class F {}
[Immutable]
class Initializaion0 {
  private int x;
  private F! f;

  public Initializaion0() {
    f = this.f; // error: Keyword this is not available
    x = this.x + 1; // error: Keyword this is not available
    base();
  }
}
[Immutable]
class Initializaion1 {
  private int x;
  private F! f;

  public Initializaion1() { // error: last statement of an immutable class's constructor must be base call + error: base call "in the middle"
    f = new F();
    this.x = 2;
    base();  
    f = this.f; 
    x = x + 1;
  }
}
[Immutable]
class Initializaion2 {
  private int x;
  private F! f;

  public Initializaion2() { // error: last stmt is not base or this call
    f = this.f; 
    x = this.x + 1; 
  }
}
[Immutable]
class Initialization3 {
  private int x;
  private F! f;

  public Initialization3() { 
    this(new F(),72);
  }

  private Initialization3(F f0, int x0) { // error: last stmt is not base or this call
    f = f0; 
    x = x0; 
  }
}
`
(6,14): error CS2686: Mutable classes cannot implement immutable interfaces.
(9,26): error CS2685: Immutable classes cannot have mutable base classes.
(10,14): error CS2684: Mutable classes cannot have immutable base classes.
(12,24): error CS2688: Peer and rep fields cannot be of immutable type.
(13,25): error CS2689: Immutable classes cannot have peer fields.
(13,25): error CS2688: Peer and rep fields cannot be of immutable type.
(14,28): error CS2688: Peer and rep fields cannot be of immutable type.
(15,29): error CS2689: Immutable classes cannot have peer fields.
(15,29): error CS2688: Peer and rep fields cannot be of immutable type.
(17,12): error CS2689: Immutable classes cannot have peer fields.
(18,17): error CS2689: Immutable classes cannot have peer fields.
(31,9): error CS0027: Keyword this is not available in the current context
(32,9): error CS0027: Keyword this is not available in the current context
`
`/debug
using Microsoft.Contracts;
class C {
  C c;
  [Rep] C m() { return new C(); }
  public virtual C n() { return c; }
  [Peer] public virtual C o() { return c; }
  [Rep] int p() { return 5; }
  [Pure][Reads(ReadsAttribute.Reads.Everything)] void q() { }
  [Peer] public virtual int r() { return 5; }
  [Rep] public virtual C s() { return c; }
  [Rep] public virtual C t() { return c; }
}
`
(7,3): error CS2692: Methods without return value or with value-type return value must not be marked Owned.
(9,3): error CS2692: Methods without return value or with value-type return value must not be marked Owned.
(10,3): error CS2693: Virtual methods must not be marked rep.
(11,3): error CS2693: Virtual methods must not be marked rep.
`
`/debug
public class ClassWithoutInvariant {
  public void LocalExpose() {
    expose (this) { }
  }
  public void AdditiveExpose() {
    additive expose (this) { }
  }
}
public class ClassWithInvariant {
  int x;
  invariant 0 <= x;
  public void LocalExpose() {
    expose (this) { }
  }
  public void AdditiveExpose() {
    additive expose (this) { }
  }
  public static void Main() {
    ClassWithoutInvariant wo = new ClassWithoutInvariant();
    wo.LocalExpose();
    wo.AdditiveExpose();
    ClassWithInvariant w = new ClassWithInvariant();
    w.LocalExpose();
    w.AdditiveExpose();
  }
}
`
`
`/debug
using System;
using System.Collections;
using Microsoft.Contracts;

class C {

  [ElementsRep]
  object[] arr;

  [ElementsPeer]
  IEnumerable alist;

  [ElementsPeer]
  IEnumerator blist;

  [ElementsRep]
  ArrayList arrList; 

  [ElementsPeer]
  Hashtable ht;

  [ElementsRep]
  Object o;

  [ElementsPeer]
  int i;
}
`
(22,3): error 0456: Only fields of IEnumerable-like type and array-type may be marked as ElementsRep or ElementsPeer.
(25,3): error 0456: Only fields of IEnumerable-like type and array-type may be marked as ElementsRep or ElementsPeer.
`
`/debug
using System;
using Microsoft.Contracts;

class A { 
  [Rep] 
  public Object f;

  [Peer]
  public Object g;
  
  public Object h;

  invariant this.f != null;
  invariant this.g != null;
  invariant this.h != null;
  invariant this.f != null && this.g != null && this.h != null;
  
  public static void Main() {}
}
`
`
`/debug
using System;
using Microsoft.Contracts;

class A { 
  Object o;

  [Pure][Rep] 
  public Object f() {return o;}

  [Pure][Peer]
  public Object g() {return o;}
  
  [Pure]
  public Object h() {return o;}

  invariant this.f() != null;
  invariant this.g() != null;
  invariant this.h() != null;
  
  public static void Main() {}

}
`
`
`/debug
using System;
using Microsoft.Contracts;

class A { 
  [Rep] 
  public B! f = new B();

  // rep-anything chain
  invariant this.f.g != null;
  invariant this.f.gg != null;
  invariant this.f.ggg != null;

  // rep-rep-anything chain
  invariant this.f.g.h != null;
  invariant this.f.g.hh != null;
  invariant this.f.g.hhh != null;

  // rep-peer-anything chain
  invariant this.f.gg.h != null;
  invariant this.f.gg.hh != null;
  invariant this.f.gg.hhh != null;
  
  public static void Main() {}
}

class B {
  [Rep]
  public C g;

  [Peer]
  public C gg;

  public C ggg;
}

class C {
  [Rep]
  public Object h;

  [Peer]
  public Object hh;

  public Object hhh;
}
`
`
`/debug
using System;
using Microsoft.Contracts;

class A { 
 
  public B! b;

  A() { b = new B();}

    [Pure][Rep]
  public B! f() {return b;} 

  // rep-anything chain
  invariant this.f().g() != null;
  invariant this.f().gg() != null;
  invariant this.f().ggg() != null;

  // rep-rep-anything chain
  invariant this.f().g().h() != null;
  invariant this.f().g().hh() != null;
  invariant this.f().g().hhh() != null;

  // rep-peer-anything chain
  invariant this.f().gg().h() != null;
  invariant this.f().gg().hh() != null;
  invariant this.f().gg().hhh() != null;

  public static void Main() {}
}

class B {
  C! c;

  public B() { c = new C();}

  [Pure][Rep]
  public C! g() {return c;}

  [Pure][Peer]
  public C! gg() {return c;}

  [Pure]
  public C! ggg() {return c;}

}

class C {
  Object! o;

  public C() { o = new Object();}

  [Pure][Rep]
  public Object! h() {return o;}

  [Pure][Peer]
  public Object! hh() {return o;}

  [Pure]
  public Object! hhh() {return o;}
}
`
`
`/debug
using Microsoft.Contracts;

class A {
  B! b = new B();

  [Rep]
  B! repB = new B();

  // visibility-based
  invariant this.b.value == null;
  invariant this.repB.peerC.value == null;
  invariant this.repB.defC.value == null;

  readonly B! roB = new B();
  readonly A! roA = new A();

  // mixed readonly access, field access on field of imm. type, StateIndependent method call
  invariant roB != null;
  invariant roA.roB != null;
  invariant roB.roImm != null;
  invariant roB.roImm.b.foo().value != null;
  
  public static void Main() {}
}

public class B {
  [Dependent(typeof(A))]
  public object value;

  [Rep]
  public C! c = new C();

  [Peer]
  public C! peerC = new C();

  public C! defC = new C();

  public readonly Imm! roImm = new Imm();

    [Pure][Reads(ReadsAttribute.Reads.Nothing)]
  public B! foo() { return this;}
}

public class C {
  [Dependent(typeof(A))]
  public object value;
}

[Immutable]
public class Imm {

  public B! b = new B();

}
`
`
`/debug
using Microsoft.Contracts;

class A {
  B! b = new B();

  [Pure]
  B! defB() { return b;}

  [Pure][Rep]
  B! repB() { return b;}
  
  // visibility-based
  invariant this.defB().value == null;
  invariant this.repB().peerC().value == null;
  invariant this.repB().defC().value == null;
  
  public static void Main() {}
}

public class B {
  [Dependent(typeof(A))]
  public object value;

  C! c = new C();

    [Pure][Peer]
  public C! peerC() {return c;}

    [Pure]
  public C! defC() {return c;}
}

public class C {
  [Dependent(typeof(A))]
  public object value;
}
`
`
`/debug
using System;
using Microsoft.Contracts;

class A { 
  [Peer] 
  public B f;

  public B ff;

  // peer-anything chain
  invariant this.f != null && this.f.g != null;
  invariant this.f.gg != null;
  invariant this.f.ggg != null;

  // none-anything chain
  invariant this.ff.g != null;
  invariant this.ff.gg != null;
  invariant this.ff.ggg != null;

  // peer-rep-anything chain
  invariant this.f.g.h != null;
  invariant this.f.g.hh != null;
  invariant this.f.g.hh != null; 
  
  public static void Main() {}
} 


class B {
  [Rep]
  public C g;

  [Peer]
  public C gg;

  public C ggg;
}

class C {
  [Rep]
  public Object h;

  [Peer]
  public Object hh;

  public Object hhh;
}
`
(11,31): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'f' is non-rep thus further field access is not admitted.
(12,13): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'f' is non-rep thus further field access is not admitted.
(13,13): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'f' is non-rep thus further field access is not admitted.
(16,13): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'ff' is non-rep thus further field access is not admitted.
(17,13): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'ff' is non-rep thus further field access is not admitted.
(18,13): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'ff' is non-rep thus further field access is not admitted.
(21,13): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'f' is non-rep thus further field access is not admitted.
(22,13): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'f' is non-rep thus further field access is not admitted.
(23,13): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'f' is non-rep thus further field access is not admitted.
`
`/debug
using System;
using Microsoft.Contracts;

class A { 
  [Rep] 
  public B! f = new B();

  invariant this.f.g.h != null;
  invariant this.f.g.hh != null;
  invariant this.f.g.hhh != null;
  invariant this.f.g.h != null && this.f.g.hh != null && this.f.g.hhh != null;

  public static void Main() {}
}

class B {
  public C! g = new C();
}

class C {
  [Rep]
  public Object h;

  [Peer]
  public Object hh;

  public Object hhh;
} 
`
(8,13): error CS2697: Expression is not admissible: it is not visibility-based, and access 'g' is neither rep nor peer thus further field access is not admitted.
(9,13): error CS2697: Expression is not admissible: it is not visibility-based, and access 'g' is neither rep nor peer thus further field access is not admitted.
(10,13): error CS2697: Expression is not admissible: it is not visibility-based, and access 'g' is neither rep nor peer thus further field access is not admitted.
(11,13): error CS2697: Expression is not admissible: it is not visibility-based, and access 'g' is neither rep nor peer thus further field access is not admitted.
(11,35): error CS2697: Expression is not admissible: it is not visibility-based, and access 'g' is neither rep nor peer thus further field access is not admitted.
(11,58): error CS2697: Expression is not admissible: it is not visibility-based, and access 'g' is neither rep nor peer thus further field access is not admitted.
`
`/debug
using System;
using Microsoft.Contracts;

class A { 
  B b;

  [Pure][Peer] 
  public B f() {return b;}

  [Pure]
  public B ff() {return b;}

  // peer-anything chain
  invariant this.f() != null && this.f().g != null;
  invariant this.f().gg != null;
  invariant this.f().ggg != null;

  // none-anything chain
  invariant this.ff().g != null;
  invariant this.ff().gg != null;
  invariant this.ff().ggg != null;

  // peer-rep-anything chain
  invariant this.f().g.h != null;
  invariant this.f().g.hh != null;
  invariant this.f().g.hh != null; 
  
  public static void Main() {}
}

class B {
  [Rep]
  public C g;

  [Peer]
  public C gg;

  public C ggg;
}

class C {
  [Rep]
  public Object h;

  [Peer]
  public Object hh;

  public Object hhh;
}
`
(14,33): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'f' is non-rep thus further field access is not admitted.
(15,13): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'f' is non-rep thus further field access is not admitted.
(16,13): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'f' is non-rep thus further field access is not admitted.
(19,13): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'ff' is non-rep thus further field access is not admitted.
(20,13): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'ff' is non-rep thus further field access is not admitted.
(21,13): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'ff' is non-rep thus further field access is not admitted.
(24,13): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'f' is non-rep thus further field access is not admitted.
(25,13): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'f' is non-rep thus further field access is not admitted.
(26,13): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'f' is non-rep thus further field access is not admitted.
`
`/debug
using System;
using Microsoft.Contracts;

class A { 
  public B! b;
 
  public A() {b = new B();}

  [Pure][Rep]
  public B! f() {return b;}

  invariant this.f().g().h != null;
  invariant this.f().g().hh != null;
  invariant this.f().g().hhh != null;
  
  public static void Main() {}
}

class B {
  private C! c;

  public B() {c = new C();}

  [Pure]
  public C! g() {return c;}
}

class C {
  [Rep]
  public Object h;

  [Peer]
  public Object hh;

  public Object hhh;
}
`
(12,13): error CS2697: Expression is not admissible: it is not visibility-based, and access 'g' is neither rep nor peer thus further field access is not admitted.
(13,13): error CS2697: Expression is not admissible: it is not visibility-based, and access 'g' is neither rep nor peer thus further field access is not admitted.
(14,13): error CS2697: Expression is not admissible: it is not visibility-based, and access 'g' is neither rep nor peer thus further field access is not admitted.
`
`/debug
using System;
using Microsoft.Contracts;

class A { 

  public B g;

  invariant this.g != null && new B().g != null;
  invariant new B().gg != null;
  invariant new B().ggg != null;
  invariant new B().g.h != null;
  invariant new B().g.h != null && new B().g != null;
  invariant new B().foo().g == null;  

  invariant (1 < 0 ? this : this).g != null;
  invariant (1 < 0 ? this : this).bar().g != null;

  [Pure][Rep]
  public B! bar() { return (!)g;}
  
  public static void Main() {}
}


class B {
  [Rep]
  public C g;

  [Peer]
  public C gg;

  public C ggg;

  [Pure][Rep]
  public B foo() { return this;}
}

class C {
  [Rep]
  public Object h;
}
`
(8,31): error CS2695: Expression is not admissible: initial target of field access must be 'this'.
(9,13): error CS2695: Expression is not admissible: initial target of field access must be 'this'.
(10,13): error CS2695: Expression is not admissible: initial target of field access must be 'this'.
(11,13): error CS2695: Expression is not admissible: initial target of field access must be 'this'.
(12,13): error CS2695: Expression is not admissible: initial target of field access must be 'this'.
(12,36): error CS2695: Expression is not admissible: initial target of field access must be 'this'.
(13,13): error CS2695: Expression is not admissible: initial target of field access must be 'this'.
(15,13): error CS2695: Expression is not admissible: initial target of field access must be 'this'.
(16,13): error CS2695: Expression is not admissible: initial target of field access must be 'this'.
`
`/debug
using Microsoft.Contracts;

class A {
  int i;  

  [Rep]
  object[]! arr = new object[10];

  [Rep]
  A! repA = new A();

  [Peer]
  A! peerA = new A();

  invariant arr[i] == null;
  invariant repA.peerA.peerA.arr[i] == null;
  invariant repA.peerA.repA.arr[i] == null;

  public static void Main() {}
}

class B {
  int i;

  [Rep]
  B! repB = new B();

  [Peer]
  B! peerB = new B();
  
  [Rep][ElementsRep]
  B[]! arr1 = new B[10];

  [Rep][ElementsRep]
  B[]! arr2a = new B[10];

  [Peer][ElementsRep]
  B[]! arr2b = new B[10];

  [Rep][ElementsPeer]
  B[]! arr2c = new B[10];

  [Peer][ElementsPeer]
  B[]! arr2d = new B[10];

  invariant arr1[i].i == 0;
  invariant arr1[i].peerB.repB.i == 0;

  invariant repB.arr2a[i].repB.i == 0;
  invariant repB.arr2b[i].repB.i == 0;
  invariant repB.peerB.repB.arr2a[i].repB.i == 0;
  invariant repB.peerB.repB.arr2b[i].repB.i == 0;

  invariant repB.arr2c[i].repB.i == 0;
  invariant repB.repB.arr2d[i].repB.i == 0;
}
`
(46,13): warning CS2614: Receiver might be null (of type 'B')
(47,13): warning CS2614: Receiver might be null (of type 'B')
(49,13): warning CS2614: Receiver might be null (of type 'B')
(50,13): warning CS2614: Receiver might be null (of type 'B')
(51,13): warning CS2614: Receiver might be null (of type 'B')
(52,13): warning CS2614: Receiver might be null (of type 'B')
(54,13): warning CS2614: Receiver might be null (of type 'B')
(55,13): warning CS2614: Receiver might be null (of type 'B')
`
`/debug
using Microsoft.Contracts;

class A {
  int i;  

  [Peer]
  object[]! peerArr = new object[10];

  object[]! defArr = new object[10];

  [Rep]
  A! repA = new A();

  [Peer]
  A! peerA = new A();

  invariant peerArr[i] == null;
  invariant defArr[i] == null;
  invariant repA.peerA.peerA.defArr[i] == null;
  
  public static void Main() {}
}

class B {
  int i;

  [Rep]
  B! repB = new B();

  [Peer]
  B! peerB = new B();
  
  [Rep]
  B[]! arr1a = new B[10];

  [Peer][ElementsRep]
  B[]! arr1b = new B[10];

  invariant arr1a[i].repB.i == 0;
  invariant arr1b[i].repB.i == 0;

  [Rep]
  B[]! arr2a = new B[10];

  [Peer]
  B[]! arr2b = new B[10];

  [Peer][ElementsPeer]
  B[]! arr2c = new B[10];

  invariant repB.peerB.arr2a[i].repB.i == 0;
  invariant repB.repB.arr2b[i].repB.i == 0;
  invariant repB.arr2c[i].repB.i == 0;
  invariant repB.arr2c[i].i == 0;
}
`
(17,13): error CS2698: Expression is not admissible: first access on array or binding member must be rep.
(18,13): error CS2698: Expression is not admissible: first access on array or binding member must be rep.
(19,13): error CS2699: Expression is not admissible: array or binding member must be owned by self.
(39,13): error CS2697: Expression is not admissible: it is not visibility-based, and access 'on element of arr1a' is neither rep nor peer thus further field access is not admitted.
(40,13): error CS2698: Expression is not admissible: first access on array or binding member must be rep.
(51,13): error CS2697: Expression is not admissible: it is not visibility-based, and access 'on element of arr2a' is neither rep nor peer thus further field access is not admitted.
(52,13): error CS2697: Expression is not admissible: it is not visibility-based, and access 'on element of arr2b' is neither rep nor peer thus further field access is not admitted.
(53,13): error CS2697: Expression is not admissible: it is not visibility-based, and access 'on element of arr2c' is neither rep nor peer thus further field access is not admitted.
(54,13): error CS2697: Expression is not admissible: it is not visibility-based, and access 'on element of arr2c' is neither rep nor peer thus further field access is not admitted.
`
`/debug
using System;
using System.Collections;
using Microsoft.Contracts;

class A {
  Dummy! d = new Dummy();
 
  [Rep]
  object[]! arr1 = new object[100];

  [Rep][ElementsRep]
  Dummy[]! arr2 = new Dummy[100];

  invariant forall{int i in (1:d.MAX); arr1[i] != arr2[i].value};
} 

class Dummy { 
  public readonly int MAX; 
  public object value;
}

class C {
  int value;

  [Rep][ElementsRep]
  MyHashtable! collRepElemRep; 

  [Rep]
  C! repC = new C();  

  [Peer]
  C! peerC = new C();  

  invariant forall{object! o in collRepElemRep; ((C)o).value != 0};
  invariant forall{object! o in repC.collRepElemRep; ((C)o).peerC.value != 0};
  invariant forall{object o in repC.peerC.collRepElemRep; o != null};
  invariant forall{object o in collRepElemRep.Keys; o != null};
  invariant forall{object o in repC.collRepElemRep.Keys; o != null};

  [Peer][ElementsRep]
  MyHashtable! collPeerElemRep; 

  invariant forall{object o in repC.collPeerElemRep; o != null};
  invariant forall{object o in repC.collPeerElemRep.Keys; o != null};

  [Rep][ElementsPeer]
  MyHashtable! collRepElemPeer; 

  invariant forall{object o in repC.collRepElemPeer; o != null};
  invariant forall{object o in repC.collRepElemPeer.Keys; o != null};
  
  public static void Main() {}
} 

class D {

  [Rep][ElementsRep]
  D[]! arrRepElemRep = new D[10];

  invariant forall{D d in arrRepElemRep; d != null};

  [Rep]
  D! repD = new D();

  invariant forall{D d in repD.arrRepElemRep; d != null};

  [Peer][ElementsRep]
  D[]! arrPeerElemRep = new D[10];

  invariant forall{D d in repD.arrPeerElemRep; d != null};

  [Rep][ElementsPeer]
  D[]! arrRepElemPeer = new D[10];

  invariant forall{D d in repD.arrRepElemPeer; d != null};
}
// need HashTable spec as the inclusion of mscorlib via /r: causes other (completely unrelated) test-cases to fail...
public interface MyHashtable 
{
    object this [object! key] {
      get;
      set;
    }
    int Count {
      get;
    }
    ICollection! Keys {
      [ElementCollection] get;
    }
    ICollection! Values {
      [ElementCollection] get;
    }
    void Remove (object! key);
    IDictionaryEnumerator! GetEnumerator ();
    [Pure]
    bool Contains (object! key);
    void Add (object! key, object value);
}
`
(14,51): warning CS2614: Receiver might be null (of type 'Dummy')
(25,3): warning CS2676: The non-null field C.collRepElemRep is not initialized by the default constructor
(40,3): warning CS2676: The non-null field C.collPeerElemRep is not initialized by the default constructor
(46,3): warning CS2676: The non-null field C.collRepElemPeer is not initialized by the default constructor
`
`/debug
using System;
using System.Collections;
using Microsoft.Contracts;

class A {
  Dummy! d = new Dummy();
 
  [Peer]
  object[]! arr1 = new object[100];

  [Rep][ElementsPeer]
  Dummy[]! arr2 = new Dummy[100];

  invariant forall{int i in (1:d.MAX); true};
  invariant forall{int i in (1:100); arr1[i] == null};
  invariant forall{int i in (1:100); arr2[i].value == null};
} 

class Dummy { 
  public int MAX; 
  public object value;
}

class C {
  [Peer][ElementsRep]
  MyHashtable! collPeerElemRep; 

  invariant forall{object o in collPeerElemRep; o != null};
  invariant forall{object o in collPeerElemRep.Keys; o != null};

  [Rep][ElementsPeer]
  MyHashtable! collRepElemPeer; 

  invariant forall{object o in collRepElemPeer; o != null};
  invariant forall{object o in collRepElemPeer.Keys; o != null};

  [Rep]
  MyHashtable! collRepElemDef; 

  invariant forall{object o in collRepElemDef; o != null};
  invariant forall{object o in collRepElemDef.Keys; o != null};

  [Rep]
  C! repC = new C();

  [ElementsRep]
  MyHashtable! collDefElemRep; 

  invariant forall{object o in repC.collDefElemRep; o != null};
  invariant forall{object o in repC.collDefElemRep.Keys; o != null};
 
  invariant forall{object o in repC.collRepElemDef; o != null};
  invariant forall{object o in repC.collRepElemDef.Keys; o != null};

  C! defC = new C();
  int val;

  invariant forall{object o in repC.collRepElemPeer.Keys; ((C)o).defC.val!=0};
} 

class D {

  [ElementsRep]
  D[]! arrDefElemRep = new D[10];

  invariant forall{D d in arrDefElemRep; d != null};

  [Rep][ElementsPeer]
  D[]! arrRepElemPeer = new D[10];

  invariant forall{D d in arrRepElemPeer; d != null};

  [Rep]
  D[]! arrRepElemDef = new D[10];

  invariant forall{D d in arrRepElemDef; d != null};

  [Rep]
  D! repD = new D();

  invariant forall{D d in repD.arrDefElemRep; d != null};
  invariant forall{D d in repD.arrRepElemDef; d != null};
}

// need HashTable spec as the inclusion of mscorlib via /r: causes other (completely unrelated) test-cases to fail...
public interface MyHashtable 
{
    object this [object! key] {
      get;
      set;
    }
    int Count {
      get;
    }
    ICollection! Keys {
      [ElementCollection] get;
    }
    ICollection! Values {
      [ElementCollection] get;
    }
    void Remove (object! key);
    IDictionaryEnumerator! GetEnumerator ();
    [Pure]
    bool Contains (object! key);
    void Add (object! key, object value);
}
`
(14,32): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'd' is non-rep thus further field access is not admitted.
(15,38): error CS2698: Expression is not admissible: first access on array or binding member must be rep.
(16,38): error CS2697: Expression is not admissible: it is not visibility-based, and access 'on element of arr2' is neither rep nor peer thus further field access is not admitted.
(28,32): error CS2698: Expression is not admissible: first access on array or binding member must be rep.
(29,32): error CS2698: Expression is not admissible: first access on array or binding member must be rep.
(34,32): error CS2699: Expression is not admissible: array or binding member must be owned by self.
(35,32): error CS2699: Expression is not admissible: array or binding member must be owned by self.
(40,32): error CS2699: Expression is not admissible: array or binding member must be owned by self.
(41,32): error CS2699: Expression is not admissible: array or binding member must be owned by self.
(49,32): error CS2699: Expression is not admissible: array or binding member must be owned by self.
(50,32): error CS2699: Expression is not admissible: array or binding member must be owned by self.
(52,32): error CS2699: Expression is not admissible: array or binding member must be owned by self.
(53,32): error CS2699: Expression is not admissible: array or binding member must be owned by self.
(58,59): error CS2697: Expression is not admissible: it is not visibility-based, and access 'defC' is neither rep nor peer thus further field access is not admitted.
(66,27): error CS2698: Expression is not admissible: first access on array or binding member must be rep.
(71,27): error CS2699: Expression is not admissible: array or binding member must be owned by self.
(76,27): error CS2699: Expression is not admissible: array or binding member must be owned by self.
(81,27): error CS2699: Expression is not admissible: array or binding member must be owned by self.
(82,27): error CS2699: Expression is not admissible: array or binding member must be owned by self.
`
`/debug
using Microsoft.Contracts;

class C { 
  object o;

  [Pure]
  static int foo() { return 5;}

  invariant foo() == 5;
  invariant Owner.Is(this, o, typeof(C));
}
`
(10,13): error CS2700: Static methods must be StateIndependent in invariants and model-field satisfies clauses.
(10,13): error CS2631: The member 'Microsoft.Contracts.Owner.Is' must be pure, confined or state independent (use custom attributes Contracts.Pure and Contracts.Reads).
`
`/debug
using Microsoft.Contracts;

class A { 
  [Additive]
  public int add;

  public int non_add;
}
class B : A{

  invariant this.add == 0;
  invariant this.non_add == 0;
  invariant ((C)this).value == 0;
}
class C : B {
  public int value;
}
`
(12,13): error CS2701: Field access not admissible: 'non_add' should be marked Additive.
(13,13): error CS2702: Field access not admissible: 'value' is declared in subtype.
`
`/debug
using Microsoft.Contracts;

class Subject{
   [SpecPublic] Observer! o;

   public Subject(Observer! o) { this.o = o;}
  [Dependent(typeof(Observer))]
  public int state;

  [NoDefaultContract]
  void Update(int y) 
    requires this.IsExposable;
    requires o!= null ==> o.IsConsistent;
  {
    expose(this) {
      expose(o) {
        state=y;
        o.Notify();
      }
    }
  }

  [NoDefaultContract]
  public int Get() 
    ensures result == state;
  {
    return state;
  }
  
  public static void Main() { }
}

sealed class Observer{
  [SpecPublic] Subject! s;
  [SpecPublic] int cache;
  invariant cache == s.state;

  public Observer(Subject! s) { this.s = s; this.cache = s.Get();}

  [NoDefaultContract]
  public void Notify() 
    requires IsExposed;
    ensures cache == s.state;
  {
    cache = s.Get();
  }
}
`
`
`/debug
using Microsoft.Contracts;

class C {
  int value;  

  [Peer]
  C! peerC = new C();

  C! defC = new C();

  [Pure][Reads(ReadsAttribute.Reads.Nothing)]
  int foo(int i) { return 5; }
 
  [Pure]
  static int bar(int i) { return 5; }

  invariant this.peerC.foo(peerC.value) == 5; // no requirement on params of StateIndependent methods
  invariant this.defC.foo(5) == 5;

  invariant C.bar(peerC.value) == 5;

  [Pure]
  int con(int i) { return 5; }
  invariant this.peerC.con(peerC.value) == 5; // 2 error: params of Confined must be admissible
}
`
(24,13): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'peerC' is non-rep thus further field access is not admitted.
(24,28): error CS2696: Expression is not admissible: it is not visibility-based, and first access 'peerC' is non-rep thus further field access is not admitted.
`
`/debug
using Microsoft.Contracts;

class C {
  int value;

  [Rep]
  C! repC = new C();

  [Peer]
  C! peerC = new C();

  C! defC = new C();

  [Pure][Rep]
  C foo() 
    requires this.repC != null && this.defC != null;  
    requires this.repC.peerC.value != 5;
    ensures  this.repC.value == 5;
    ensures  result.value == 5;  
    ensures  result == bar();
    ensures  this.repM().peerM() == null;
  { return this; }
 
  [Pure][Reads(ReadsAttribute.Reads.Nothing)][ResultNotNewlyAllocated]
  C! bar() { return this;}

  [Pure][Rep]
  C! repM() { return this;}

    [Pure][Peer]
  C! peerM() { return this;} 
  
  public static void Main(){}
}

class B {
  int i;

  [Rep]
  B! repB = new B();

  [Peer]
  B! peerB = new B();
  
  [Rep][ElementsRep]
  B[]! arr1 = new B[10];

  [Rep][ElementsRep]
  B[]! arr2a = new B[10];

  [Peer][ElementsRep]
  B[]! arr2b = new B[10];

  [Rep][ElementsPeer]
  B[]! arr2c = new B[10];

  [Peer][ElementsPeer]
  B[]! arr2d = new B[10];

  [Pure]
  B foo() 
    ensures arr1[i].i == 0;
    ensures arr1[i].peerB.repB.i == 0;
    ensures repB.arr2a[i].repB.i == 0;
    ensures repB.arr2b[i].repB.i == 0;
    ensures repB.peerB.repB.arr2a[i].repB.i == 0;
    ensures repB.peerB.repB.arr2b[i].repB.i == 0;
    ensures repB.arr2c[i].repB.i == 0;
    ensures repB.repB.arr2d[i].repB.i == 0;
  { return this; }
  
}
`
(62,13): warning CS2614: Receiver might be null (of type 'B')
(63,13): warning CS2614: Receiver might be null (of type 'B')
(64,13): warning CS2614: Receiver might be null (of type 'B')
(65,13): warning CS2614: Receiver might be null (of type 'B')
(66,13): warning CS2614: Receiver might be null (of type 'B')
(67,13): warning CS2614: Receiver might be null (of type 'B')
(68,13): warning CS2614: Receiver might be null (of type 'B')
(69,13): warning CS2614: Receiver might be null (of type 'B')
`
`/debug
using Microsoft.Contracts;

class A {
  [Dependent(typeof(C))]
  public int value;
}

class C {
  int value;

  A! defA = new A();

  [Rep]
  C! repC = new C();

  [Peer]
  C! peerC = new C();

  C! defC = new C();

  [Pure][Peer]
  C foo() 
    requires this.peerC.value != 5;
    requires this.defA.value == 5;  // method spec may not be visibility-based 
    ensures  result.value == 5;
    ensures  result == bar();
    ensures  this.peerM().repM() == null;
  { return this; }
  
  [Pure][Reads(ReadsAttribute.Reads.Everything)][ResultNotNewlyAllocated]
  C bar() { return this;}

  [Pure][Rep]
  C! repM() { return this;}

  [Pure][Peer]
  C! peerM() { return this;}
   
  public static void Main(){}
}

class B {
  int i;

  [Rep]
  B! repB = new B();

  [Peer]
  B! peerB = new B();
  
  [Rep]
  B[]! arr1a = new B[10];

  [Peer][ElementsRep]
  B[]! arr1b = new B[10];

  [Rep]
  B[]! arr2a = new B[10];

  [Peer]
  B[]! arr2b = new B[10];

  [Peer][ElementsPeer]
  B[]! arr2c = new B[10];

  [Pure]
  B foo() 
    ensures repB.peerB.arr2a[i].repB.i == 0;
    ensures repB.repB.arr2b[i].repB.i == 0;
    ensures repB.arr2c[i].repB.i == 0;
    ensures repB.arr2c[i].i == 0;
  { return this;}
  
  public static void Main(){}
}
`
(23,14): error CS2696: Expression is not admissible: first access 'peerC' is non-rep thus further field access is not admitted.
(24,14): error CS2696: Expression is not admissible: first access 'defA' is non-rep thus further field access is not admitted.
(25,14): error CS2696: Expression is not admissible: first access 'result' is non-rep thus further field access is not admitted.
(26,24): error CS2704: Confined methods must not contain calls to Pure methods.
(27,14): error CS2696: Expression is not admissible: first access 'peerM' is non-rep thus further field access is not admitted.
(68,13): error CS2697: Expression is not admissible: access 'on element of arr2a' is neither rep nor peer thus further field access is not admitted.
(69,13): error CS2697: Expression is not admissible: access 'on element of arr2b' is neither rep nor peer thus further field access is not admitted.
(70,13): error CS2697: Expression is not admissible: access 'on element of arr2c' is neither rep nor peer thus further field access is not admitted.
(71,13): error CS2697: Expression is not admissible: access 'on element of arr2c' is neither rep nor peer thus further field access is not admitted.`
`/debug
using Microsoft.Contracts;

[Immutable]
class Imm {
  public A! a = new A();
}

class A {
  readonly int value;
  readonly A! a = new A();
  readonly Imm! roImm = new Imm();
  Imm! imm = new Imm();

  [Pure][Reads(ReadsAttribute.Reads.Nothing)]
  A foo() 
    ensures si() == 5;
    ensures this.a.value == 5;
    ensures this.roImm.a.value == 5;
  { return this; }

  [Pure][Reads(ReadsAttribute.Reads.Nothing)]
  int si() { return 5;}
  
  public static void Main(){}
}
`
`
`/debug
using Microsoft.Contracts;

class A {
  int value;

  [Pure][Reads(ReadsAttribute.Reads.Nothing)]
  A foo() 
    ensures pure() == 5;
    ensures con() == 5;
    ensures this.value == 5;
  { return this; }

  [Pure][Reads(ReadsAttribute.Reads.Everything)]
  int pure() { return 5;}

  [Pure]
  int con() { return 5;}
  
  public static void Main(){}
}
`
(8,13): error CS2705: StateIndependent methods must not contain calls to Pure or Confined methods.
(9,13): error CS2705: StateIndependent methods must not contain calls to Pure or Confined methods.
(10,13): error CS2703: Expression is not admissible: only readonly fields and fields of Immutable types are allowed to be accessed in StateIndependent specifications.
`
`/debug
using Microsoft.Contracts;

class C {
  [Rep]
  C! repC = new C();

  [Peer]
  C! peerC = new C();

  // purity-level  

  [Pure][Reads(ReadsAttribute.Reads.Everything)]
  int pure() 
    ensures con() == 5; 
    ensures si() == 5; 
  { return 5; }

  [Pure]
  int con() 
    ensures si() == 5; 
  { return 5; }

  // receiver is rep

  [Pure][Reads(ReadsAttribute.Reads.Nothing)]
  int si()
    ensures repC.si() == 5; 
    ensures repC.peerC.si() == 5;  
  { return 5;}

  [Pure]
  int con2()
    ensures repC.con2() == 5;
    ensures repC.peerC.con2() == 5;
    ensures repM().peerM().con2() == 5;
  { return 5;}

  [Pure][Reads(ReadsAttribute.Reads.Everything)]
  int pure2()
    ensures repC.pure() == 5;
    ensures repC.peerC.pure() == 5;
    ensures repM().peerM().pure() == 5;
  { return 5;}

  [Rep]  [Pure]
  C! repM() {return this;}

  [Peer]  [Pure]
  C! peerM() {return this;}

  // recursion termination value

  [Pure][Reads(ReadsAttribute.Reads.Everything)][RecursionTermination(20)]
  int pure3()
    ensures pure4() == 5;
    ensures pure5() == 5;
    ensures pure6() == 5;  // infered!
  { return 5;}

  [Pure][Reads(ReadsAttribute.Reads.Everything)][RecursionTermination]
  int pure4() {return 5;}

  [Pure][Reads(ReadsAttribute.Reads.Everything)][RecursionTermination(10)]
  int pure5() {return 5;}

  [Pure][Reads(ReadsAttribute.Reads.Everything)]
  int pure6() 
    ensures result > 0;
  {return 5;}
  
  public static void Main() {}
}
`
`
`/debug
using Microsoft.Contracts;

class C {
  [Rep]
  C! repC = new C();

  [Peer]
  C! peerC = new C();

  // non-rep receiver

  [Pure][Reads(ReadsAttribute.Reads.Nothing)]
  int si()
    ensures si() == 5;  // receiver is non-rep
    ensures peerC.si() == 5;  // receiver is non-rep
    ensures peerC.repC.si() == 5;  // receiver is non-rep
  { return 5;}

  [Pure]
  int con()
    ensures repM().defM().con() == 5;
    ensures peerM().con() == 5;
  { return 5;}

  [Rep]  [Pure]
  C! repM() {return this;}

  [Pure]
  C! defM() {return this;}

  [Peer]  [Pure]
  C! peerM() {return this;}

  // non-decreasing recursion termination value

  [Pure][Reads(ReadsAttribute.Reads.Everything)][RecursionTermination(10)]
  int pure3()
    ensures pure4() == 5;
    ensures pure5() == 5; // infered MAXINT
  { return 5;}

  [Pure][Reads(ReadsAttribute.Reads.Everything)][RecursionTermination(100)]
  int pure4() {return 5;}

  [Pure][Reads(ReadsAttribute.Reads.Everything)]
  int pure5() 
    ensures result == pure6(); // ok: infering MAXINT for pure5
  {return 5;}

  [Pure][Reads(ReadsAttribute.Reads.Everything)]
  int pure6() 
    ensures result > 0; // ok: just to make pure5 admissible
  {return 5;}

}
`
(14,13): warning CS2663: Method call 'si' not admissible: could not find decreasing measure based on purity-level, receiver, and recursion termination value.
(15,13): warning CS2663: Method call 'si' not admissible: could not find decreasing measure based on purity-level, receiver, and recursion termination value.
(16,13): warning CS2663: Method call 'si' not admissible: could not find decreasing measure based on purity-level, receiver, and recursion termination value.
(21,13): warning CS2663: Method call 'con' not admissible: could not find decreasing measure based on purity-level, receiver, and recursion termination value.
(21,13): error CS2697: Expression is not admissible: access 'defM' is neither rep nor peer thus further field access is not admitted.
(22,13): warning CS2663: Method call 'con' not admissible: could not find decreasing measure based on purity-level, receiver, and recursion termination value.
(22,13): error CS2696: Expression is not admissible: first access 'peerM' is non-rep thus further field access is not admitted.
(38,13): warning CS2663: Method call 'pure4' not admissible: could not find decreasing measure based on purity-level, receiver, and recursion termination value.
(39,13): warning CS2663: Method call 'pure5' not admissible: could not find decreasing measure based on purity-level, receiver, and recursion termination value.
`
`/debug
using Microsoft.Contracts;

interface I {
  object F();
}
abstract class A : I {
  public virtual object F() { return new object();}
}
class B : A {
  object! o = new object();

  [Pure][Reads(ReadsAttribute.Reads.Nothing)][NoReferenceComparison]
  public override object F() { return new object();}

  [ResultNotNewlyAllocated]      // error: should be marked pure
  public object G() { return o;}

  [Pure][ResultNotNewlyAllocated]
  public virtual object H() { return o;}

  [Pure][Reads(ReadsAttribute.Reads.Everything)][ResultNotNewlyAllocated]
  public int J() {  return 5;}  // error: return value not ref-type
}
class C : B {
  [Pure][Reads(ReadsAttribute.Reads.Nothing)]
  public override object F() { return new object();}  // error: does not copy NRC attribute

  [Pure]
  public override object H() { return new object();}  // error: does not copy RNNA attribute
 
  [NoReferenceComparison]      // error: should be marked pure
  public object K() { return new object(); }
}
class D {
  object! o = new object();

  [Pure][Reads(ReadsAttribute.Reads.Everything)][NoReferenceComparison]
  void Foo1(D p1, D p2) {
    if (p1 == null)          // ok
      o = new object();
  }

  [Pure][Reads(ReadsAttribute.Reads.Everything)][NoReferenceComparison]
  void Foo2(D p1, D p2) {
    if (p1 == p2)            // error: method contains ref comparison
      o = new object();
  }

  [Pure][Reads(ReadsAttribute.Reads.Everything)][NoReferenceComparison]
  void Foo3(D p1, D p2) {
    D d = new D();
    if (p1 == d)            // error: ref. comparison although could be eliminated by a more precise analysis since d is newly allocated
      o = new object();
  }
}

class E {
  object! o = new object();

  void Foo()
    ensures M(new object(), N());  // error: method should be marked NoReferenceComparison
  { }

  void Bar()
    ensures O(new object(), N());  // ok: O marked NRC
  { }

  [Pure][Reads(ReadsAttribute.Reads.Everything)]
  bool M(object p1, object p2) { return true;}

  [Pure][Reads(ReadsAttribute.Reads.Everything)][NoReferenceComparison]
  bool O(object p1, object p2) { return true;}
 
  [Pure][Reads(ReadsAttribute.Reads.Everything)]
  object N() { return new object();}

  void Woo()
    ensures M(new object(), this);  // ok: P only takes one MRNAO argument 
    ensures M(new object(), RNNA());  // ok: P only takes one MRNAO argument 
    ensures P(new object());  // ok: P only takes one MRNAO argument 
  { }

  [Pure][Reads(ReadsAttribute.Reads.Everything)]
  bool P(object o) { return true;}

  [Pure][Reads(ReadsAttribute.Reads.Everything)][ResultNotNewlyAllocated]
  object RNNA() { return o;}
}

class X {
  object! o = new object();

  void Foo() 
    ensures M() == M();  // error: both operands MRNAO 
    ensures M() == null;  // ok: 'null' is not MRNAO
    ensures M() == this;  // ok: 'this' is not MRNAO
    ensures N() == N();  // ok: N is of non-reference type
    ensures RNNA() == RNNA();  // ok: RNNA is ResultNotNewlyAllocated
  { }

  [Pure][Reads(ReadsAttribute.Reads.Everything)]
  object M() {return new object();}

  [Pure][Reads(ReadsAttribute.Reads.Everything)]
  int N() {return 7;}

  [Pure][Reads(ReadsAttribute.Reads.Everything)][ResultNotNewlyAllocated]
  object RNNA() { return o;}

  object Bar() 
    ensures result == M(); // error: both operands MRNAO 
  { return new object();}

  [Pure][Reads(ReadsAttribute.Reads.Everything)][ResultNotNewlyAllocated]
  object Woo() 
    ensures result == M();
  { return o;}
}
`
(15,3): error CS2712: Only pure methods may be marked as ResultNotNewlyAllocated.
(21,3): error CS2713: Only methods with reference-type return value may be marked as ResultNotNewlyAllocated.
(25,3): error CS2708: Method 'F' should be marked NoReferenceComparison because the overriden method is marked so.
(28,3): error CS2711: Method 'H' should be marked ResultNotNewlyAllocated because the overriden method is marked so.
(31,3): error CS2709: Only pure methods may be marked as NoReferenceComparison.
(43,3): error CS2710: Could not verify that method 'Foo2' does not compare references although it is marked NoReferenceComparison.
(49,3): error CS2710: Could not verify that method 'Foo3' does not compare references although it is marked NoReferenceComparison.
(61,13): error CS2714: Method 'M' possibly compares references and has at least two arguments that might return newly allocated objects. Maybe you need to mark the method 'NoReferenceComparison'?.
(94,13): error CS2715: Both operands of reference comparison possibly refer to newly created objects which is forbidden in specifications. Maybe you need to mark one of the operands as 'ResultNotNewlyAllocated'?
(111,13): error CS2715: Both operands of reference comparison possibly refer to newly created objects which is forbidden in specifications. Maybe you need to mark one of the operands as 'ResultNotNewlyAllocated'?
`
//
// Test type inference for delegate construction. (Beyond C# 2.0)
//
using System;

class Test {

    public static void FooNN(Predicate<string>/*!*/ p) {
    }

    public static void Foo(Predicate<string> p) {
    }

    public static void BarNN<T>(Predicate<T>/*!*/ p) {
    }

    public static void Bar<T>(Predicate<T> p) {
    }

    bool Pred1(string s) { return false; }


    public void Test1(Test t2) {

        Foo(this.Pred1);
        FooNN(this.Pred1);

        Bar(this.Pred1);
        BarNN(this.Pred1);

    }

    public static void Main() {}
}
`
`
`/debug
// New quantifiers: sum, max, min
using System;
class Test {
  public static int Sum(int[]! xs){
    return sum{int i in (0:xs.Length); xs[i]};
  }
  public static int Max(int[]! xs){
    return max{int i in (0:xs.Length); xs[i]};
  }
  public static int Min(int[]! xs){
    return min{int i in (0:xs.Length); xs[i]};
  }
  public static void Main() {
    int[] A = new int[]{3, 4, 5};
    Console.WriteLine(Sum(A));
    Console.WriteLine(Max(A));
    Console.WriteLine(Min(A));
  }
}
`
12
5
3
`
`/debug
// New quantifier: product
using System;
class Test {
  public static int Product(int[]! xs){
    return product{int i in (0:xs.Length); xs[i]};
  }
  public static void Main() {
    int[] A = new int[]{3, 4, 5};
    Console.WriteLine(Product(A));
  }
}
`
60
`
`/debug
// Allowing NoDefaultContract attribute on parameters
using Microsoft.Contracts;
class Node{
  public Node(int d, [NoDefaultContract] Node p){}
}
class M { public static void Main(){} }
`
`
`/debug
// Allowing NoDefaultContract attribute only on parameters of reference type
using Microsoft.Contracts;
class Node{
  public Node([NoDefaultContract] int d, [NoDefaultContract] Node p){}
}
class M { public static void Main(){} }
`
(4,16): error CS2716: Only parameters/return values/receivers that have a reference type may have the 'Microsoft.Contracts.NoDefaultContractAttribute' annotation.
`
`/debug
// Test new visibility conditions for postconditions
using Microsoft.Contracts;
class C{
  private int priv;
  [SpecPublic] private int specPublicPriv;
  protected int prot;
  internal int intern;
  public int pub;

  /*non-virtual*/ int foo0()
    ensures 0 < priv;
    ensures 0 < prot;
    ensures 0 < intern;
    ensures 0 < pub;
    ensures 0 < specPublicPriv;
  { return 0; }

  public virtual int foo1()
    ensures 0 < priv;
    ensures 0 < prot;
    ensures 0 < intern;
    ensures 0 < pub;
    ensures 0 < specPublicPriv;
  { return 0; }

}
public class Public{
  private int priv;
  [SpecPublic] private int specPublicPriv;
  protected int prot;
  internal int intern;
  protected internal int protAndIntern;
  public int pub;

  public virtual int foo1()
    ensures 0 < priv;
    ensures 0 < prot;
    ensures 0 < intern;
    ensures 0 < pub;
    ensures 0 < specPublicPriv;
    ensures 0 < protAndIntern;
  { return 0; }
}
class InternalPubSub : Public {
  int xPriv;
  public override int foo1()
    ensures 0 < prot;
    ensures 0 < intern;
    ensures 0 < pub;
    ensures 0 < specPublicPriv;
    ensures 0 < protAndIntern;
    ensures 0 < xPriv;  // error
  { return 0; }
}
public sealed class X : Public {
  public override int foo1()
    ensures 0 < prot;
    ensures 0 < intern;
    ensures 0 < pub;
    ensures 0 < specPublicPriv;
    ensures 0 < protAndIntern;
  { return 0; }
}
public class Y : Public {
  public sealed override int foo1()
    ensures 0 < prot;
    ensures 0 < intern;
    ensures 0 < pub;
    ensures 0 < specPublicPriv;
    ensures 0 < protAndIntern;
  { return 0; }
}
class M{ public static void Main(){} }
`
(19,17): error CS0122: 'C.priv' is inaccessible due to its protection level
(36,17): error CS0122: 'Public.priv' is inaccessible due to its protection level
(38,17): error CS0122: 'Public.intern' is inaccessible due to its protection level
(52,17): error CS0122: 'InternalPubSub.xPriv' is inaccessible due to its protection level
`
`/debug
// Check for assignments within method contracts
class C{
  bool x;
  int y;
  invariant x = 3;
  invariant (y += 5) > 0;
  public bool f()
    ensures result = true;
  { return true; }
  public void g(bool b)
    requires b += true;
  {}
  public void g()
    requires new bool[]{true,false}[0] == true;
  {}
  public void h(bool a, bool b){
    assert a = b;
    assume a = b;
  }
  public static void Main(){}
}
`
(8,13): error 0460: Contracts may not contain expressions with side effects.
(11,14): error 0460: Contracts may not contain expressions with side effects.
(17,12): error 0460: Contracts may not contain expressions with side effects.
(18,12): error 0460: Contracts may not contain expressions with side effects.
(5,13): error 0460: Contracts may not contain expressions with side effects.
(6,14): error 0460: Contracts may not contain expressions with side effects.
`
class T {
  string! [] data1 = new string! [200];
  string! []! data = new string! [200];
  public static void Main(){}
}
`
(2,3): warning CS2725: Field 'T this.T.data1', a non-null element array, may not have been initialized. Did you forget to call NonNullType.AssertInitialized()?
(3,3): warning CS2725: Field 'T this.T.data', a non-null element array, may not have been initialized. Did you forget to call NonNullType.AssertInitialized()?
`
`/debug
// The comma after the open curly used to crash the compiler
// Now it should give an error message
class C{
  public int f(int x){
    assert count{,
    return x + 1; }
  }
}
`
(5,18): error CS1525: Invalid expression term ','
(5,12): error CS1003: Syntax error, 'iterator or expression' expected
(5,18): error CS1002: ; expected
(8,1): error CS1519: Invalid token '}' in class, struct, or interface member declaration
`
`/d:NONONNULLTYPECHECK
class StringP {
  public static StringP whenString(WhenString todo){
            StringP result = todo("back ");
            System.Console.WriteLine("result of applying delegate is a {0}", result);
            return result;
  }

  public delegate StringP WhenString(string arg);

  string o;
  
  public StringP(string o) {
    this.o = o;
  }
  
  static public implicit operator StringP(string o) {
         return new StringP(o);
  }
  
  static public void Main (string [] args) {
    StringP.whenString(delegate (string n) { return n + "haha"; });
  }
}
`
result of applying delegate is a StringP
`
using Microsoft.Contracts;

class E {
  public E(params string[] c) {
  }
}

class C {
  static public void Main(string[] args) {
    E e = new E();
    System.Console.WriteLine("{0}", e);
  }
}
`
E
`
using System;
public class Program
{
  static void Main(string![]! args)
    // The following precondition is redundant with the type
    // signature for the parameter, but shown here as an example.
    requires forall{int i in (0:args.Length); args[i] != null};
  {
    Console.WriteLine("Spec# says hello!");
  }

  static void Test1(D<string, string! > x) {} // should be an error, as string is not a subtype of string!
}

class D<T, S> where T:class where T:S {
}
`
(12,23): error CS0309: The type 'string' must be convertible to 'string!' in order to use it as parameter 'T' in the generic type or method 'D<T,S>'
`
`/debug
/*\ Tests for context checks on modifies clauses
 *
 *  The basic rules are these:
 *  modifies g; // [modifies the global field g] g must be a static field
 *  modifies E.x; // [modifies the field x] x must be an instance field, E must have a non-array reference type
 *  modifies E.*; // [modifies any field] E must have a non-array reference type
 *  modifies E.0; // [doesn't modify] E must have a reference type (array allowed)
 *  modifies E[*]; // [modifies elements of E] E must be an array, any rank
 *  modifies E[E0,E1,...]; // [modifies specific element of E] E must be an array of the proper rank, Ei an integer expression
 *  modifies E.**; // [modifies peers of E] E must have a reference type (array allowed)
 *
 *  Note that some of these checks are made as part of just the general type checking, e.g., that E[x,y] is allowed only when
 *  E is an array of rank 2 and x and y are both type-compatible with integer.
 *
\*/
struct S{
  int f;
  public static T T_Through_S;

  public void ModifiesTest(int[]! A, int[,] B, T t)

    modifies T.G; // OK
    modifies S.T_Through_S.G; // Error

    modifies this; // Error in a struct, the receiver of a struct method is implicitly a ref parameter. Ref parameters are automatically included in the modifies clause
    modifies this.0; // Error in a struct
    modifies this.f; // Error in a struct, even though field exists
    modifies this.g; // Error: no such field
    modifies this.*; // Error in a struct
    modifies this.**; // Error in a struct

    modifies A; // Error
    modifies A.0; // OK
    modifies A.f; // Error: no such field
    modifies A.*; // Error
    modifies A.**; // OK
    modifies A[*]; // OK
    modifies A[2]; // OK

    modifies B; // Error
    modifies B.0; // OK
    modifies B.f; // Error: no such field
    modifies B.*; // Error
    modifies B.**; // OK
    modifies B[*]; // OK
    modifies B[2,3]; // OK

    modifies t; // Error
    modifies t.0; // OK
    modifies t.f; // OK
    modifies t.g; // Error: no such field
    modifies t.*; // OK
    modifies t.**; // OK
  {}
}

class T{
  public int f;
  public static int G;
}

class C{
  int f;
  public void ModifiesTest(int[] A, int[,] B, T t, S s, out S s_out, int x, out int y, string str, object o)

    modifies T.G;
    modifies S.T_Through_S.G;

    modifies this; // Error in a reference type
    modifies this.0; // OK
    modifies this.f; // OK
    modifies this.g; // Error: no such field
    modifies this.*; // OK
    modifies this.**; // OK

    modifies A; // Error
    modifies A.0; // OK
    modifies A.f; // Error: no such field
    modifies A.*; // Error
    modifies A.**; // OK
    modifies A[*]; // OK
    modifies A[2]; // OK

    modifies B; // Error
    modifies B.0; // OK
    modifies B.f; // Error: no such field
    modifies B.*; // Error
    modifies B.**; // OK
    modifies B[*]; // OK
    modifies B[2,3]; // OK

    modifies t; // Error
    modifies t.0; // OK
    modifies t.f; // OK
    modifies t.*; // OK
    modifies t.**; // OK

    modifies s; // Error
    modifies s.0; // Error: struct
    modifies s.f; // Error: struct (but there is a field f)
    modifies s.g; // Error: no such field (and it wouldn't be allowed anyway)
    modifies s.*; // Error: struct
    modifies s.**; // Error: struct

    modifies s_out; // Error
    modifies s_out.0; // Error: struct
    modifies s_out.f; // Error: struct (but there is a field f)
    modifies s_out.g; // Error: no such field (and it wouldn't be allowed anyway)
    modifies s_out.*; // Error: struct
    modifies s_out.**; // Error: struct

    modifies x; // Error
    modifies x.0; // Error: value type
    modifies x.f; // Error: value type
    modifies x.*; // Error:  value type
    modifies x.**; // Error:  value type

    modifies y; // Error
    modifies y.0; // Error: value type
    modifies y.f; // Error: value type
    modifies y.*; // Error:  value type
    modifies y.**; // Error:  value type

    modifies str; // Error
    modifies str.0; // OK
    modifies str.f; // Error: no such field
    modifies str.*; // OK
    modifies str.**; // OK
    modifies str[2]; // Error: not an array

    modifies no_such_parameter.*; // Error
    modifies no_such_parameter.0; // Error
  {}
}
class M { public static void Main(){} }
`
(23,14): error CS2740: Invalid modifies clause : invalid static field reference
(26,14): error CS2740: Invalid modifies clause : 'E.0' is allowed only when E has a reference type, not 'ref S'
(27,14): error CS2740: Invalid modifies clause : 'E.x' is allowed only when E has a reference type, not 'ref S'
(29,14): error CS2740: Invalid modifies clause : 'E.*' is allowed only when E has a reference type, not 'ref S'
(30,14): error CS2740: Invalid modifies clause : 'E.**' is allowed only when E has a reference type, not 'ref S'
(32,14): error CS2740: Invalid modifies clause : 'E.x' is allowed only when E has a reference type, not 'ref S'
(35,14): error CS2740: Invalid modifies clause : 'E.*' is allowed only when E has a reference type, not 'int[]!'
(40,14): error CS2740: Invalid modifies clause : 'E.x' is allowed only when E has a reference type, not 'ref S'
(43,14): error CS2740: Invalid modifies clause : 'E.*' is allowed only when E has a reference type, not 'int[*,*]'
(48,14): error CS2740: Invalid modifies clause : 'E.x' is allowed only when E has a reference type, not 'ref S'
(28,19): error CS0117: 'S' does not contain a definition for 'g'
(34,16): error CS0117: 'int[]' does not contain a definition for 'f'
(42,16): error CS0117: 'int[*,*]' does not contain a definition for 'f'
(51,16): error CS0117: 'T' does not contain a definition for 'g'
(67,14): error CS2740: Invalid modifies clause : invalid static field reference
(76,14): error CS2740: Invalid modifies clause : 'E.x' is allowed only when E has a reference type, not 'C'
(79,14): error CS2740: Invalid modifies clause : 'E.*' is allowed only when E has a reference type, not 'int[]'
(84,14): error CS2740: Invalid modifies clause : 'E.x' is allowed only when E has a reference type, not 'C'
(87,14): error CS2740: Invalid modifies clause : 'E.*' is allowed only when E has a reference type, not 'int[*,*]'
(92,14): error CS2740: Invalid modifies clause : 'E.x' is allowed only when E has a reference type, not 'C'
(98,14): error CS2740: Invalid modifies clause : 'E.x' is allowed only when E has a reference type, not 'C'
(99,14): error CS2740: Invalid modifies clause : 'E.0' is allowed only when E has a reference type, not 'S'
(100,14): error CS2740: Invalid modifies clause : 'E.x' is allowed only when E has a reference type, not 'S'
(102,14): error CS2740: Invalid modifies clause : 'E.*' is allowed only when E has a reference type, not 'S'
(103,14): error CS2740: Invalid modifies clause : 'E.**' is allowed only when E has a reference type, not 'S'
(105,14): error CS2740: Invalid modifies clause : 'E.x' is allowed only when E has a reference type, not 'C'
(106,14): error CS2740: Invalid modifies clause : 'E.0' is allowed only when E has a reference type, not 'ref S'
(107,14): error CS2740: Invalid modifies clause : 'E.x' is allowed only when E has a reference type, not 'ref S'
(109,14): error CS2740: Invalid modifies clause : 'E.*' is allowed only when E has a reference type, not 'ref S'
(110,14): error CS2740: Invalid modifies clause : 'E.**' is allowed only when E has a reference type, not 'ref S'
(112,14): error CS2740: Invalid modifies clause : 'E.x' is allowed only when E has a reference type, not 'C'
(113,14): error CS2740: Invalid modifies clause : 'E.0' is allowed only when E has a reference type, not 'int'
(115,14): error CS2740: Invalid modifies clause : 'E.*' is allowed only when E has a reference type, not 'int'
(116,14): error CS2740: Invalid modifies clause : 'E.**' is allowed only when E has a reference type, not 'int'
(118,14): error CS2740: Invalid modifies clause : 'E.x' is allowed only when E has a reference type, not 'C'
(119,14): error CS2740: Invalid modifies clause : 'E.0' is allowed only when E has a reference type, not 'ref int'
(121,14): error CS2740: Invalid modifies clause : 'E.*' is allowed only when E has a reference type, not 'ref int'
(122,14): error CS2740: Invalid modifies clause : 'E.**' is allowed only when E has a reference type, not 'ref int'
(124,14): error CS2740: Invalid modifies clause : 'E.x' is allowed only when E has a reference type, not 'C'
(69,14): error CS1510: A ref or out argument must be an lvalue
(72,19): error CS0117: 'C' does not contain a definition for 'g'
(78,16): error CS0117: 'int[]' does not contain a definition for 'f'
(86,16): error CS0117: 'int[*,*]' does not contain a definition for 'f'
(101,16): error CS0117: 'S' does not contain a definition for 'g'
(108,20): error CS0117: 'S' does not contain a definition for 'g'
(114,16): error CS0117: 'int' does not contain a definition for 'f'
(120,16): error CS0117: 'int' does not contain a definition for 'f'
(126,18): error CS0117: 'string' does not contain a definition for 'f'
(129,14): error CS0206: A readonly property or indexer may not be passed as an out or ref parameter
(131,14): error CS0103: The name 'no_such_parameter' does not exist in the current context
(132,14): error CS0103: The name 'no_such_parameter' does not exist in the current context
`
`/debug
using System;
using Microsoft.Contracts;
class CEX : CheckedException{
  public int ErrorCode;
}
class C{
  public int x;
  public int M(int y)
    ensures result == 3;
    throws (CEX e) ensures e.ErrorCode == 0 && x >= 0;
  {
    if (y == 0)
      return 3;
    else
      throw new CEX(); 
  }
}
class M{
  public static void Main(){
    try{
      Console.WriteLine(new C().M(0));
    }
    catch (CEX e) { Console.WriteLine("Caught an e: " + e.ErrorCode); }
    catch (Exception e) { Console.WriteLine(e.Message); }
  }
}  
`
3
`
`/debug
using System;
using Microsoft.Contracts;
class CEX : CheckedException{
  public int ErrorCode;
}
class C{
  public int x;
  public int M(int y)
    ensures result == 3;
    throws (CEX e) ensures e.ErrorCode == 0 && x >= 0;
  {
    if (y == 0)
      return 3;
    else
      throw new CEX(); 
  }
}
class M{
  public static void Main(){
    try{
      Console.WriteLine(new C().M(1));
    }
    catch (CEX e) { Console.WriteLine("Caught an e: " + e.ErrorCode); }
    catch (Exception e) { Console.WriteLine(e.Message); }
  }
}  
`
Caught an e: 0
`
`/debug
using System;
using Microsoft.Contracts;
class CEX : CheckedException{
  public int ErrorCode;
}
class C{
  public int x;
  public int M(int y)
    ensures result == 3;
    throws (CEX e) ensures e.ErrorCode == 1 && x >= 0;
  {
    if (y == 0)
      return 3;
    else
      throw new CEX(); 
  }
}
class M{
  public static void Main(){
    try{
      Console.WriteLine(new C().M(1));
    }
    catch (CEX e) { Console.WriteLine("Caught an e: " + e.ErrorCode); }
    catch (Exception e) { Console.WriteLine(e.Message); }
  }
}  
`
Exceptional postcondition 'e.ErrorCode == 1 && x >= 0' violated from method 'C.M(System.Int32)'
`
`/debug
// Test to make sure that the order of the overrides doesn't matter for contract inheritance
using System;
public class C{
  public virtual int M(int y)
    ensures result == 3;
  {
    return 3;
  }
}
public class E : D{
  public override int M(int y){ return 4; }
}
public class D : C{
  public override int M(int y){ return 4; }
}
class M{
  public static void Main(){
    new E().M(0);
  }
}  
`
Postcondition 'result == 3' violated from method 'E.M(System.Int32)'
`
`/debug+
using Microsoft.Contracts;
public class C{
  [Additive][Rep]
  public C f0;
  [Additive][Rep]
  public C f1;
}
class M{ public static void Main(){} }
`
(3,3): error CS2717: Attributes 'Microsoft.Contracts.RepAttribute' and 'Microsoft.Contracts.AdditiveAttribute' cannot both be specified together.
(5,3): error CS2717: Attributes 'Microsoft.Contracts.RepAttribute' and 'Microsoft.Contracts.AdditiveAttribute' cannot both be specified together.
`
`/debug+
using Microsoft.Contracts;
public class C{
  [Pure][Reads(ReadsAttribute.Reads.Everything)]
  public int P0 { get { return 3; } }
  [Pure][Reads(ReadsAttribute.Reads.Everything)]
  public int P1 { get { return 3; } set {} }
}
class M{ public static void Main(){} }
`
(6,37): error 0469: The member 'C.P1.set' cannot be annotated as being pure.
`
`/debug
using System;
using Microsoft.Contracts;
class C{
  [Pure][Reads(ReadsAttribute.Reads.Everything)] public int foo(ref int x){
    return 3;
  }
  [Pure][Reads(ReadsAttribute.Reads.Everything)] public int foo(out string xs){
    xs = "abc";
    return 3;
  }
  void bar0(string ys){
    assert foo(out ys) > 0; // Error: cannot use in a spec
  }
  void bar1(string ys){
    assume foo(out ys) > 0; // Error: cannot use in a spec
  }
  void bar2(string ys)
    requires foo(out ys) > 0; // Error: cannot use in a spec
  {
  }
  [Pure][Reads(ReadsAttribute.Reads.Everything)] public int baz(out string xs){ // Okay, never used in a spec.
    xs = "abc";
    return 3;
  }

}

class M{ public static void Main(){} }
`
(4,65): error CS2744: Pure methods can't have ref parameters.
(7,65): error CS2743: Pure methods with out parameters cannot be used in specifications.
(7,65): error CS2743: Pure methods with out parameters cannot be used in specifications.
(7,65): error CS2743: Pure methods with out parameters cannot be used in specifications.
`
`/d:NONONNULLTYPECHECK
class D {
  public static void Main(string [] args) {
    int [][] arr = new int[10][];
    for (int i=0; i<10; i++) {
      arr[i] = new int[10];
      for (int j=0; j<10;j++) 
        arr[i][j]= i+j;
    }
    foo((int[]![]!) arr);
  }

  public static void foo(int []![]! arr) 
   ensures forall{int i in (0:3), int j in (0:3); arr[i][j] == old(arr[i][j])};
  {
     arr[1][0] = 2;
  }
}
`
Postcondition 'forall{int i in (0:3), int j in (0:3); arr[i][j] == old(arr[i][j])}' violated from method 'D.foo(System.Int32[][])'
`
`/d:NONONNULLTYPECHECK
class D {
  public static void Main(string [] args) {
    int [][] arr = new int[10][];
    for (int i=0; i<10; i++) {
      arr[i] = new int[10];
      for (int j=0; j<10;j++) 
        arr[i][j]= i+j;
    }
    foo((int[]![]!) arr);
  }

  public static void foo(int []![]! arr) 
   ensures forall{int i in (0:3), int j in (0:3); arr[i][j] == old(arr[i][j])};
  {
  }
}
`
`
// IL generated for comparison in assignment or return was not right. 
// .un was missed. 
class C {
  public static void Main(string [] args) {}
  public static bool foo(uint x, uint y) 
    requires (x>y);
  {
    bool v = x>y;
    if (v) return x>y;
    return !v;
  }
}
`
`
`/debug
// For C# compaitibility (and common sense): make sure that if an attribute is marked as obsolete
// the compiler warns on its use.
using System;

[Obsolete("What are you thinking of?")]
[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
class A : Attribute{}

public class C {
  [A]
  public int M(){ return 3; }
}

public class M{
  public static void Main(){}
}
`
(10,4): warning CS0618: 'A' is obsolete: 'What are you thinking of?'
`
`/debug
using Microsoft.Contracts;
class C { 
  [Pure] // Okay, compiler picks a default reads
  public static int P0 { get { return 3; } }
  [Pure][Reads(ReadsAttribute.Reads.Owned)] // error
  public static int P1 { get { return 3; } }
  [Pure][Reads(ReadsAttribute.Reads.Everything)] // ok
  public static int P2 { get { return 3; } }
  [Pure][Reads(ReadsAttribute.Reads.Nothing)] // ok
  public static int P3 { get { return 3; } }
}
struct S { 
  [Pure] // Okay, compiler picks a default reads
  public int P0 { get { return 3; } }
  [Pure][Reads(ReadsAttribute.Reads.Owned)] // error
  public int P1 { get { return 3; } }
  [Pure][Reads(ReadsAttribute.Reads.Everything)] // ok
  public int P2 { get { return 3; } }
  [Pure][Reads(ReadsAttribute.Reads.Nothing)] // ok
  public int P3 { get { return 3; } }
}
class M { public static void Main(){} }
`
(6,26): error CS2747: Inconsistent purity annotation: methods in a struct or that are static cannot be marked as Owned.
(16,19): error CS2747: Inconsistent purity annotation: methods in a struct or that are static cannot be marked as Owned.
`
`
using System;
class Arglist {

  private static void mywrite(string fmt, params object[] rest) {
    foreach (object o in rest) {
      System.Console.WriteLine("arg:{0}", o);
    }
  } 
  
  public static void Main(string [] args) {
    mywrite("me", __arglist("hello", 4), "pei");
  }
}
`
arg:hello
arg:4
arg:pei
`
`
public class C {
  public int x;
  public virtual void M()
    // default modifies clause
  {
  }
  public virtual void N()
    modifies this.x;
  {
  }
  public virtual void P()
    modifies this.*;
  {
  }
}

public interface J {
  void Q();
    modifies this.0;
  void R();
    modifies this.*;
  void S();
    // default modifies clause
}

public class D : C, J {
  public int y;
  public override void M()
    modifies y;  // error: modifies not allowed in override
  {
  }
  public override void N()
    modifies y;  // error: modifies not allowed in override
  {
  }
  public override void P()
    modifies y;  // error: modifies not allowed in override
  {
  }
  public void Q()
    modifies y;  // error: modifies not allowed in override
  {
  }
  public void R()
    modifies y;  // error: modifies not allowed in override
  {
  }
  public void S()
    modifies y;  // error: modifies not allowed in override
  {
  }
}
`
(28,24): error CS2646: 'D.M()' : modifies clause not allowed in override.
(32,24): error CS2646: 'D.N()' : modifies clause not allowed in override.
(36,24): error CS2646: 'D.P()' : modifies clause not allowed in override.
(40,15): error CS2646: 'D.Q()' : modifies clause not allowed in override.
(44,15): error CS2646: 'D.R()' : modifies clause not allowed in override.
(48,15): error CS2646: 'D.S()' : modifies clause not allowed in override.
`
`
using Microsoft.Contracts;

public class C {
  string givenName = "Rustan";
  string familyName = "Leino";

  [Pure]//[ResultNotNewlyAllocated]
  string FullName() {
    return givenName + " " + familyName;
  }

  public void MethodA()
    ensures FullName() == FullName();  // not allowed here
  {
    assert FullName() == FullName();  // not allowed here either
  }
}
`
(13,13): error CS2714: Method 'Equals' possibly compares references and has at least two arguments that might return newly allocated objects. Maybe you need to mark the method 'NoReferenceComparison'?.
(15,12): error CS2714: Method 'Equals' possibly compares references and has at least two arguments that might return newly allocated objects. Maybe you need to mark the method 'NoReferenceComparison'?.
`