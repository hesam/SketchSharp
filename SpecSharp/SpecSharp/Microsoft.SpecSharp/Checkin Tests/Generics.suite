``/d:NONONNULLTYPECHECK
`
class test{
  public static void Main(){}
}
`
`
`/p:v2 /r:System.dll;GCollections.dll
// File index: a list of all words and the lines on which they occur
// This program requires .Net version 2.0.
// Peter Sestoft (sestoft@dina.kvl.dk) 2001-11-30, 2003-08-11

// Compile GCollections.cs with 
//   csc /t:module GCollections.cs
// Then compile this file with 
//   csc /r:System.dll /addmodule:GCollections.netmodule FileIndex.cs

using System;
using System.IO;
using System.Text.RegularExpressions; 
using GCollections;		// For LinkedList<T>


class Fileindex {
  static void Main(string[] args) {
    Index(Mary);
  }

  static void Index(string S) {
    TreeMap< string, TreeSet<int> > index = 
      new OTreeMap< string, TreeSet<int> >();
    Regex delim = 
      new Regex("[ \\t~!@#$%^&*()_+=;':\\[\\]\\{\\}<>\\\\\\|\",./?-]+");
    TextReader rd = new StringReader(S);
    int lineno = 0;
    string line;
    while (null != (line = rd.ReadLine())) {
      string[] res = delim.Split(line);
      lineno++;
      foreach (string s in res)
	if (s != "") {
	  if (!index.Contains(s)) 
	    index[s] = new OTreeSet<int>();
	  index[s].Add(lineno);
	}
    }
    rd.Close();
    foreach (MapEntry< string, TreeSet<int> > wordlist in index) {
      Console.Write("{0}: ", wordlist.Key);
      foreach (int ln in wordlist.Value)
	Console.Write(ln + " ");
      Console.WriteLine();
    }
  }

  static string Mary =  @"
Mary had a little lamb,
Little lamb, little lamb,
Mary had a little lamb,
Its fleece was white as snow

And everywhere that Mary went,
Mary went, Mary went,
Everywhere that Mary went
The lamb was sure to go

It followed her to school one day
School one day, school one day
It followed her to school one day
Which was against the rules.

It made the children laugh and play,
Laugh and play, laugh and play,
It made the children laugh and play
To see a lamb at school

And so the teacher turned it out,
Turned it out, turned it out,
And so the teacher turned it out,
But still it lingered near

And waited patiently about,
Patiently about, patiently about,
And waited patiently about
Till Mary did appear

Why does the lamb love Mary so?
Love Mary so? Love Mary so?
Why does the lamb love Mary so?
The eager children cry

Why, Mary loves the lamb, you know.
Loves the lamb, you know, loves the lamb, you know
Why, Mary loves the lamb, you know.
The teacher did reply";
}
`
a: 2 4 20 
about: 27 28 29 
against: 15 
and: 17 18 19 
And: 7 22 24 27 29 
appear: 30 
as: 5 
at: 20 
But: 25 
children: 17 19 35 
cry: 35 
day: 12 13 14 
did: 30 40 
does: 32 34 
eager: 35 
everywhere: 7 
Everywhere: 9 
fleece: 5 
followed: 12 14 
go: 10 
had: 2 4 
her: 12 14 
it: 22 23 24 25 
It: 12 14 17 19 
Its: 5 
know: 37 38 39 
lamb: 2 3 4 10 20 32 34 37 38 39 
laugh: 17 18 19 
Laugh: 18 
lingered: 25 
little: 2 3 4 
Little: 3 
love: 32 34 
Love: 33 
loves: 37 38 39 
Loves: 38 
made: 17 19 
Mary: 2 4 7 8 9 30 32 33 34 37 39 
near: 25 
one: 12 13 14 
out: 22 23 24 
patiently: 27 28 29 
Patiently: 28 
play: 17 18 19 
reply: 40 
rules: 15 
school: 12 13 14 20 
School: 13 
see: 20 
snow: 5 
so: 22 24 32 33 34 
still: 25 
sure: 10 
teacher: 22 24 40 
that: 7 9 
the: 15 17 19 22 24 32 34 37 38 39 
The: 10 35 40 
Till: 30 
to: 10 12 14 
To: 20 
turned: 22 23 24 
Turned: 23 
waited: 27 29 
was: 5 10 15 
went: 7 8 9 
Which: 15 
white: 5 
Why: 32 34 37 39 
you: 37 38 39 
`
`/p:v2
// Generic typesafe collections in Generic C#
// This program requires .Net version 2.0.
// Peter Sestoft (sestoft@dina.kvl.dk) 2001-12-02, 2003-11-23, 2004-07-26

// See documentation in file collections.txt

// To create a module for use from other files, compile with 
//   csc /t:module GCollections.cs

// To do:
//  * Test systematically (no time, unfortunately)
//  * Make GetHashCode constant time everywhere
//  * Make the collections themselves implement IComparable<T> ?
//  * Add interval operators to ISortedSet and ISortedMap operations
//  * Implement HashSets from the ground up, using linked list for
//    buckets, and retaining the hashcode to avoid recomputing it.
//  * There's a fair amount of code duplication (generic/non-generic)
//    in TreeMap, but I fear the performance consequences of removing it.

using System;			// For exceptions
using Microsoft.Contracts;

namespace GCollections {

// INTERFACES ===================================================

// Enumerators --------------------------------------------------

public interface IEnumerator<T> {
  T Current { get; } 
  bool MoveNext();
  void Reset();
}

// Enumerables --------------------------------------------------

public interface IEnumerable<T> { 
  IEnumerator<T> GetEnumerator();
}

// Collections --------------------------------------------------

public interface ICollection<T> : IEnumerable<T> { 
  int Count { get; }
}

// Comparing two things -----------------------------------------

public interface IComparer<T> {
  int Compare(T v1, T v2);
}

// Comparing to type T ------------------------------------------

public interface IComparable<T> {
  int CompareTo(T that);
}

// Maps ---------------------------------------------------------

public interface IMap<K,V> : ICollection< MapEntry<K,V> > {
  bool Add(K key, V val);       // Cannot return old value ...
  MapEntry<K,V> Remove(K key);
  V this[K key] { get; set; }
  bool Contains(K key);
  //  ICollection<K> Keys { get; }
  //  ICollection<V> Values { get; }
}

// Sorted maps --------------------------------------------------

public interface ISortedMap<K, V> : IMap<K, V> { }

// Map entries --------------------------------------------------

public struct MapEntry<K,V> {
  K key; V val;
  
  public MapEntry(K key, V val) {
    this.key = key; this.val = val;
  }

  public K Key { get { return key; } }

  public V Value { get { return val; } }
}

// Sets ---------------------------------------------------------

public interface ISet<T> : ICollection<T> {
  bool Add(T item);             // return true if item was added
  T Remove(T item);             // return removed item
  bool Contains(T item);
}

// Sorted sets --------------------------------------------------

public interface ISortedSet<T> : ISet<T> { }

// Lists, stacks and queues -------------------------------------

public interface IList<T> : ICollection<T> {
  bool Add(T item);
  bool Add(int i, T item);
  T Remove();
  T RemoveAt(int i);
  T Remove(T item);
  bool Contains(T item);        // using Equals
  T this[int index] { get; set; }
}

// IMPLEMENTATIONS ==============================================

// HashMaps -----------------------------------------------------

public class HashMap<K,V> : IMap<K,V> {
  private System.Collections.Hashtable table;
  
  public HashMap() {
    table = new System.Collections.Hashtable();
  }

  public ICollection<K> Keys {
    get { return new Collection<K>(table.Keys); }
  }

  public ICollection<V> Values {
    get { return new Collection<V>(table.Values); }
  }

  public int Count {
    get { return table.Count; }
  }

  public bool Add(K key, V val) {
    if (table.Contains(key))
      return false;
    else { 
      table.Add(key, val);
      return true;
    }
  }

  public MapEntry<K,V> Remove(K key) {
    if (table.Contains(key)) {
      V val = (V)table[key];
      table.Remove(key);
      return new MapEntry<K,V>(key, val); // Issue: not quite as spec'ed
    } else
      throw new ElementNotFoundException();
  }
  
  public V this[K key] { 
    get { return (V)table[key]; }
    set { table[key] = value; }
  }
  
  public bool Contains(K key) {
    return table.Contains(key);
  }

  // Two classes to help convert the underlying Hashtable's Keys and
  // Values object ICollections into generic collections

  class Collection<T> : ICollection<T> {
    private System.Collections.ICollection coll;
    
    public Collection(System.Collections.ICollection coll) {
      this.coll = coll;
    }
    
    public IEnumerator<T> GetEnumerator() {
      return new Enumerator<T>(coll.GetEnumerator());
    }

    public int Count {
      get { return coll.Count; }
    }
  }

  // Issue: this function could be optimized to not use the enumerators

  public override int GetHashCode() {
    int sum = 0;
    foreach (MapEntry<K,V> entry in this)
      sum += entry.Key.GetHashCode() ^ entry.Value.GetHashCode();
    return sum;
  }
  
  class Enumerator<T> : IEnumerator<T> {
    System.Collections.IEnumerator enm;
    
    public Enumerator(System.Collections.IEnumerator enm) {
      this.enm = enm;
    }
    
    public T Current { 
      get { return (T)enm.Current; }
    }

    public bool MoveNext() {
      return enm.MoveNext();
    }

    public void Reset() {
      enm.Reset();
    }
  }

  public IEnumerator<MapEntry<K,V>> GetEnumerator() {
    return new HashMapEnumerator(this, table.GetEnumerator());
  }

  class HashMapEnumerator : IEnumerator<MapEntry<K,V>> {
    HashMap<K,V> map;
    System.Collections.IEnumerator enm;
    
    public HashMapEnumerator(HashMap<K,V> map, 
                             System.Collections.IEnumerator enm) {
      this.map = map; this.enm = enm;
    }

    // Issue: should probably not create a new struct on every invocation
    public virtual MapEntry<K,V> Current { 
      get { 
        System.Collections.DictionaryEntry entry 
          = (System.Collections.DictionaryEntry)enm.Current; 
        return new MapEntry<K,V>((K)entry.Key, (V)entry.Value);
      }
    }

    public bool MoveNext() {
      return enm.MoveNext();
    }
    
    public void Reset() {
      enm.Reset();
    }
  }
}

// HashSet, sets of unordered items -----------------------------

public class HashSet<T> : ISet<T> {
  private System.Collections.Hashtable /* from T to null */ table;
  private int hashCode = 0;     // to save recomputing it
  
  public HashSet() { 
    table = new System.Collections.Hashtable();
  }

  [NotDelayed]
  public HashSet(T v) : this() { 
    Add(v);
  }

  [NotDelayed]  
  public HashSet(HashSet<T> s) : this() { 
    IEnumerator<T> sIter = s.GetEnumerator();
    while (sIter.MoveNext())
      Add(sIter.Current);
  }
  
  public int Count { 
    get { return table.Count; }
  }

  public bool Add(T v) {
    if (!table.Contains(v)) {
      table.Add(v, null);
      hashCode += v.GetHashCode();
      return true;
    } else
      return false;
  }

  public T Remove(T v) {
    if (table.Contains(v)) {
      table.Remove(v);
      hashCode -= v.GetHashCode();
      return v;				// Issue: not quite according to spec
    } else
      throw new ElementNotFoundException();      
  }

  public bool Contains(T v) {
    return table.Contains(v);
  }

  public IEnumerator<T> GetEnumerator() {
    return new HashSetEnumerator(table);
  }

  class HashSetEnumerator : IEnumerator<T> {
    System.Collections.IEnumerator enm;
    
    public HashSetEnumerator(System.Collections.Hashtable table) {
      this.enm = table.Keys.GetEnumerator();
    }

    public virtual T Current { 
      get { return (T)enm.Current; }
    }

    public bool MoveNext() {
      return enm.MoveNext();
    }
    
    public void Reset() {
      enm.Reset();
    }
  }
  
  public override int GetHashCode() {
    return hashCode;
  }

  public override bool Equals(object that) {
    // Issue: could compare hashcodes, if GetHashCode were constant time
    if (that is ISet<T> && Count == ((ISet<T>)that).Count) {
      ISet<T> thatSet = (ISet<T>)that;
      IEnumerator<T> thisenm = this.GetEnumerator();
      while (thisenm.MoveNext()) {
        if (!thatSet.Contains(thisenm.Current)) 
          return false;
      }
      return true;
    } else
      return false;
  }
}

// Doubly-linked lists ------------------------------------------
// Add(T) at end, Remove() from front; behaves like a queue (FIFO)

public class LinkedList<T> : IList<T> {
  int size;			// Number of elements in the list
  int stamp;			// To detect modification during enumeration
  Node first, last;		// Invariant: first==null iff last==null

  private class Node {
    public Node prev, next;
    public T item;

    public Node(T item) {
      this.item = item; 
    }

    public Node(T item, Node prev, Node next) {
      this.item = item; this.prev = prev; this.next = next; 
    }
  }

  public LinkedList() {
    first = last = null;
    size = stamp = 0;
  }

  public int Count {
    get { return size; }
  }

  public T this[int index] {
    get { return get(index).item; }
    set { get(index).item = value; }
  }      

  private Node get(int n) {
    if (n < 0 || n >= size)
      throw new IndexOutOfRangeException();
    else if (n < size/2) {              // Closer to front
      Node node = first;
      for (int i=0; i<n; i++)
        node = node.next;
      return node;
    } else {                            // Closer to end
      Node node = last;
      for (int i=size-1; i>n; i--)
        node = node.prev;
      return node;
    }
  }

  public bool Add(T item) { 
    return AddLast(item);
  }

  public bool AddFirst(T item) { 
    if (first == null) // and thus last == null
      first = last = new Node(item);
    else {
      Node tmp = new Node(item, null, first);
      first.prev = tmp;
      first = tmp;
    }
    size++;
    stamp++;
    return true;
  }

  public bool Add(int i, T item) { 
    if (i == 0) 
      return AddFirst(item);
    else if (i == size)
      return AddLast(item);
    else {
      Node node = get(i);
      // assert node.prev != null;
      Node newnode = new Node(item, node.prev, node);
      node.prev.next = newnode;
      node.prev = newnode;
      size++;
      stamp++;
      return true;
    }
  }

  public bool AddLast(T item) {
    if (last == null) // and thus first = null
      first = last = new Node(item);
    else {
      Node tmp = new Node(item, last, null);
      last.next = tmp;
      last = tmp;
    }
    size++; 
    stamp++;
    return true;
  }

  public T Remove() {
    return RemoveFirst();
  }

  public T RemoveFirst() {
    if (first == null) // and thus last == null
      throw new IndexOutOfRangeException();
    else {
      size--; 
      stamp++;
      T item = first.item;
      first = first.next;
      if (first == null) 
        last = null;
      else 
        first.prev = null;
      return item;
    }
  }

  public T RemoveAt(int i) {
    Node node = get(i);
    if (node.prev == null) 
      first = node.next;
    else
      node.prev.next = node.next;
    if (node.next == null) 
      last = node.prev;
    else
      node.next.prev = node.prev;       
    size--;
    stamp++;
    return node.item;
  }

  public T RemoveLast() {
    if (last == null) // and thus first == null
      throw new IndexOutOfRangeException();
    else {
      size--;
      stamp++;
      T item = last.item;
      last = last.prev;
      if (last == null) 
        first = null;
      else 
        last.next = null;
      return item;
    }
  }

  public T Remove(T item) {
    Node node = first;
    while (node != null) {
      if (item.Equals(node.item)) {
        if (node.prev == null) 
          first = node.next;
        else
          node.prev.next = node.next;
        if (node.next == null) 
          last = node.prev;
        else
          node.next.prev = node.prev;   
        size--;
	stamp++;
        return node.item;
      }
      node = node.next;
    }
    throw new ElementNotFoundException();
  }

  public bool Contains(T item) {
    Node node = first;
    while (node != null) {
      if (item.Equals(node.item)) 
        return true;
      node = node.next;
    }
    return false;
  }

  public override int GetHashCode() {
    int sum = 0;
    Node node = first;
    while (node != null) {
      sum = 31 * sum + node.item.GetHashCode();
      node = node.next;
    }
    return sum;
  }

  public override bool Equals(object that) {
    if (that is IList<T> && this.size == ((IList<T>)that).Count) {
      Node thisnode = this.first;
      IEnumerator<T> thatenm = ((IList<T>)that).GetEnumerator();
      while (thisnode != null) {
	if (!thatenm.MoveNext())
	  throw new Exception("Impossible: LinkedList<T>.Equals");
        // assert MoveNext() was true;	// because of the above size test
        if (!thisnode.item.Equals(thatenm.Current))
          return false;
        thisnode = thisnode.next; 
      }
      // assert !MoveNext(); // because of the size test
      return true;
    } else
      return false;
  }

  public IEnumerator<T> GetEnumerator() {
    return new LinkedListEnumerator(this);
  }

  class LinkedListEnumerator : IEnumerator<T> {
    LinkedList<T> lst;
    Node curr;
    int stamp;
    bool valid;
    T item;

    [Microsoft.Contracts.NotDelayed] public LinkedListEnumerator(LinkedList<T> lst) {
      this.lst = lst; this.stamp = lst.stamp; Reset();
    }
    
    public T Current {
      get { 
	if (valid) 
	  return item; 
	else
	  throw new InvalidOperationException();
      }
    }
    
    public bool MoveNext() {
      if (stamp != lst.stamp)
	throw new InvalidOperationException(); // List modified
      else if (curr != null)  {
        item = curr.item;
        curr = curr.next;
        return valid = true;
      } else 
        return valid = false; 
    }

    public void Reset() {
      curr = lst.first; 
      valid = false;
    }
  }
}

// Array lists --------------------------------------------------
// Add(T) at end, Remove() from end; behaves like a stack, LIFO

public class ArrayList<T> : IList<T> {
  int size;			// Number of elements in list
  int stamp;			// To detect modification during enumeration
  T?[] elems;			

  public ArrayList() {
    size = stamp = 0;
    elems = new T?[10];  // Initial capacity
  }

  private void reallocate(int newsize) {
    T?[] newelems = new T?[newsize];
    for (int i=0; i<size; i++)
      newelems[i] = elems[i];
    elems = newelems;
  }

  public int Count {
    get { return size; }
  }

  public T this[int index] {
    get { return elems[index]; }
    set { elems[index] = value; }
  }      

  public bool Add(T item) {                     
    return AddLast(item);
  }

  public bool AddLast(T item) { // Add at end
    return Add(size, item);
  }

  public bool Add(int i, T item) {      // Add at position i
    if (i<0 || i>size)
      throw new IndexOutOfRangeException();
    else {
      if (size == elems.Length) 
        reallocate(2 * size);
      // assert elems.Length > size;
      for (int j=size; j>i; j--)
        elems[j] = elems[j-1];
      elems[i] = item;
      size++;
      stamp++;
      return true;
    }
  }

  public T Remove() {           // Remove last
    return RemoveAt(size-1);
  }

  public T RemoveAt(int i) {      // Remove at index i
    if (i<0 || i>=size) 
      throw new IndexOutOfRangeException();
    else {
      T item = elems[i];
      for (int j=i+1; j<size; j++)
        elems[j-1] = elems[j];
      elems[--size] = default(T); // To prevent space leaks
      stamp++;
      return item;
    }
  }

  public T Remove(T item) {     // Search 
    for (int i=0; i<size; i++)
      if (item.Equals(elems[i]))
        return RemoveAt(i);
    throw new ElementNotFoundException();
  }

  public bool Contains(T item) {
    for (int i=0; i<size; i++)
      if (item.Equals(elems[i]))
        return true;
    return false;
  }

  public override int GetHashCode() {
    int sum = 0;
    for (int i=0; i<size; i++)
      sum = 31 * sum + elems[i].GetHashCode();
    return sum;
  }

  public override bool Equals(object that) {
    if (that is IList<T> && this.size == ((IList<T>)that).Count) {
      IEnumerator<T> thatenm = ((IList<T>)that).GetEnumerator();
      for (int i=0; i<size; i++) {
	if (!thatenm.MoveNext())
	  throw new Exception("Impossible: LinkedList<T>.Equals");
        // assert MoveNext() returned true;  /// because of the size test
        if (!elems[i].Equals(thatenm.Current))
          return false;
      }
      // assert !MoveNext();  /// because of the size test
      return true;
    } else
      return false;
  }

  public IEnumerator<T> GetEnumerator() {
    return new ArrayListEnumerator(this);
  }

  class ArrayListEnumerator : IEnumerator<T> {
    ArrayList<T> lst;
    bool valid;
    int stamp;
    T item;
    int curr;

    [Microsoft.Contracts.NotDelayed] public ArrayListEnumerator(ArrayList<T> lst) {
      this.lst = lst; stamp = lst.stamp; Reset();
    }
    
    public T Current {
      get { 
	if (valid) 
	  return item; 
	else
	  throw new InvalidOperationException();
      }
    }
    
    public bool MoveNext() {
      if (stamp != lst.stamp)  
	throw new InvalidOperationException();
      else if (curr < lst.size)  {
        item = lst[curr];
        curr++;
        return valid = true;
      } else
        return valid = false; 
    }

    public void Reset() {
      curr = 0;
      valid = false;
    }
  }
}

// ORDERED BINARY TREES (RED-BLACK TREES) -----------------------

// The root node is black
// Leaf nodes (null pointers) are black
// A red node must have a black parent
// All paths from a node to a leaf must have the same number of black nodes

// Much based on Ken Larsen's implementation for Moscow ML, whose
// deletion algorithm is inspired by Stefan Kahrs

// Nodes in binary trees 

internal class Node<K,V> {
  public Node<K,V> left, rght;
  public K key;
  public V val;
  public bool red;            // Color is red or black
  
  public Node(K key, V val) {
    this.key = key; this.val = val; red = true;
  }
  
  public Node(K key, V val, Node<K,V> left, Node<K,V> rght) {
    this.key = key; this.val = val; red = false;
  }

  // Colored rebalancing operations

  public static void lbal(ref Node<K,V> t) {
    // assert t != null;
    t.red = false;
    Node<K,V> d = t.left;
    if (d != null && d.red) {
      if (d.left != null && d.left.red) {
        d.left.red = false;
        t.left = d.rght;
        d.rght = t;
        t = d;
      } else if (d.rght != null && d.rght.red) {
        Node<K,V> bc = d.rght;
        d.red = false;
        t.left = bc.rght;
        bc.rght = t;
        d.rght = bc.left;
        bc.left = d;
        t = bc;
      }
    }
  }

  public static void rbal(ref Node<K,V> t) {
    // assert t != null;
    t.red = false;
    Node<K,V> e = t.rght;
    if (e != null && e.red) {
      if (e.rght != null && e.rght.red) {
        e.rght.red = false;
        t.rght = e.left;
        e.left = t;
        t = e;
      } else if (e.left != null && e.left.red) {
        Node<K,V> bc = e.left;
        e.red = false;
        t.rght = bc.left;
        bc.left = t;
        e.left = bc.rght;
        bc.rght = e;
        t = bc;
      }
    }
  }

  public static void balleft(ref Node<K,V> t) {
    // assert t != null;
    if (t.left != null && t.left.red) {         // (red, ---)
      t.red = true;
      t.left.red = false;
    } else if (t.rght != null)
      if (!t.rght.red) {        // (black, black)
        t.rght.red = true;
        rbal(ref t);
      } else if (t.rght.left != null && !t.rght.left.red) {
        t.red = false;
        Node<K,V> trl = t.rght.left;
        t.rght.left = trl.rght;
        if (t.rght.rght != null)
	  t.rght.rght.red = true;
        rbal(ref t.rght);
        trl.rght = t.rght;
        t.rght = trl.left;
        trl.left = t;
        t = trl;
        t.red = true;
      } else throw new Exception("balleft");
  }

  public static void balrght(ref Node<K,V> t) {
    // assert t != null;
    if (t.rght != null && t.rght.red) {         // (---, red)
      t.red = true;
      t.rght.red = false;
    } else if (t.left != null) 
      if (!t.left.red) {        // (black, black)
        t.left.red = true;
        lbal(ref t);
      } else if (t.left.rght != null && !t.left.rght.red) {
        t.red = false;
        Node<K,V> tlr = t.left.rght;
        t.left.rght = tlr.left;
        if (t.left.left != null) 
	  t.left.left.red = true;
        lbal(ref t.left);
        tlr.left = t.left;
        t.left = tlr.rght;
        tlr.rght = t;
        t = tlr;
        t.red = true;
      } else throw new Exception("balrght");
  }

  public static Node<K,V> append(Node<K,V> left, Node<K,V> rght) {
    if (left == null) 
      return rght;
    else if (rght == null) 
      return left;
    else if (left.red != rght.red) { // different colours
      if (left.red) {           // (red, black)
        left.rght = append(left.rght, rght);
        return left;
      } else {                  // (black, red)
        rght.left = append(left, rght.left);
        return rght;
      }
    } else {                    // same colours
      Node<K,V> bc = append(left.rght, rght.left);
      if (bc != null && bc.red) {
        left.rght = bc.left; 
        bc.left = left;
        rght.left = bc.rght;
        bc.rght = rght;
        return bc;
      } else {
        rght.left = bc;
        left.rght = rght;
        if (!left.red)          // (black, black)
          balleft(ref left);
        return left;
      }
    }
  }
}

// Operations on tree maps

internal interface ITreeOps<K,V> {
  bool contains(Node<K,V> t, K key);
  Node<K,V> get(Node<K,V> t, K key);
  bool add(ref Node<K,V> t, K key, V val);
  Node<K,V> del(ref Node<K,V> t, K key);
}

// Object-based IComparable tree operations ---------------------

// Object-based dynamically typed comparisons using CompareTo(object)

internal class OTreeOps<K, V> : ITreeOps<K,V> 
  where  K : System.IComparable {
  public bool contains(Node<K,V> t, K key) {
    while (t != null) {
      int cmp = key.CompareTo(t.key);
      if (cmp < 0)
        t = t.left;
      else if (cmp > 0) 
        t = t.rght;
      else 
        return true;
    }
    return false;
  }
  
  public Node<K,V> get(Node<K,V> t, K key) {
    while (t != null) {
      int cmp = key.CompareTo(t.key);
      if (cmp < 0)
        t = t.left;
      else if (cmp > 0) 
        t = t.rght;
      else 
        return t;
    }
    throw new ElementNotFoundException();
  }

  public bool add(ref Node<K,V> t, K key, V val) { 
    if (t == null) {
      t = new Node<K,V>(key, val);
      return true;
    } else {
      int cmp = key.CompareTo(t.key);
      if (cmp < 0) {
        bool added = add(ref t.left, key, val);
        if (!t.red)
          Node<K,V>.lbal(ref t); 
        return added;
      } else if (cmp > 0) {
        bool added = add(ref t.rght, key, val);
        if (!t.red) 
          Node<K,V>.rbal(ref t);
        return added;
      } else 
        return false;
    }
  }

  public Node<K,V> del(ref Node<K,V> t, K key) { 
    if (t == null) {
      throw new ElementNotFoundException("TreeMap.Remove: " + key);
    } else {
      int cmp = key.CompareTo(t.key);
      if (cmp < 0) {
        bool tleftblack = !t.left.red;
        Node<K,V> removed = del(ref t.left, key);
        if (tleftblack)  
          Node<K,V>.balleft(ref t);
        else
          t.red = true;
        return removed;
      } else if (cmp > 0) {
        bool trghtblack = !t.rght.red;
        Node<K,V> removed = del(ref t.rght, key);
        if (trghtblack)  
          Node<K,V>.balrght(ref t);
        else
          t.red = true;
        return removed;
      } else {
        Node<K,V> removed = t;
        t = Node<K,V>.append(t.left, t.rght);
        return removed;
      }    
    }
  }
}

// Generic IComparable<K> tree operations ---------------------

// Generic statically typed implicit comparer CompareTo(K).

// The code is textually identical to the above, but will avoid
// all the boxings implied by the above code when K is
// instantiated to a value type.

internal class GTreeOps<K, V> : ITreeOps<K,V> 
  where K : IComparable<K> {
  public bool contains(Node<K,V> t, K key) {
    while (t != null) {
      int cmp = key.CompareTo(t.key);
      if (cmp < 0)
        t = t.left;
      else if (cmp > 0) 
        t = t.rght;
      else 
        return true;
    }
    return false;
  }
  
  public Node<K,V> get(Node<K,V> t, K key) {
    while (t != null) {
      int cmp = key.CompareTo(t.key);
      if (cmp < 0)
        t = t.left;
      else if (cmp > 0) 
        t = t.rght;
      else 
        return t;
    }
    throw new ElementNotFoundException();
  }

  public bool add(ref Node<K,V> t, K key, V val) { 
    if (t == null) {
      t = new Node<K,V>(key, val);
      return true;
    } else {
      int cmp = key.CompareTo(t.key);
      if (cmp < 0) {
        bool added = add(ref t.left, key, val);
        if (!t.red)
          Node<K,V>.lbal(ref t); 
        return added;
      } else if (cmp > 0) {
        bool added = add(ref t.rght, key, val);
        if (!t.red) 
          Node<K,V>.rbal(ref t);
        return added;
      } else 
        return false;
    }
  }

  public Node<K,V> del(ref Node<K,V> t, K key) { 
    if (t == null) {
      throw new ElementNotFoundException("TreeMap.Remove: " + key);
    } else {
      int cmp = key.CompareTo(t.key);
      if (cmp < 0) {
        bool tleftblack = !t.left.red;
        Node<K,V> removed = del(ref t.left, key);
        if (tleftblack)  
          Node<K,V>.balleft(ref t);
        else
          t.red = true;
        return removed;
      } else if (cmp > 0) {
        bool trghtblack = !t.rght.red;
        Node<K,V> removed = del(ref t.rght, key);
        if (trghtblack)  
          Node<K,V>.balrght(ref t);
        else
          t.red = true;
        return removed;
      } else {
        Node<K,V> removed = t;
        t = Node<K,V>.append(t.left, t.rght);
        return removed;
      }    
    }
  }
}

// Separate statically typed comparer: Compare(K,K)

internal class FGTreeOps<K,V> : ITreeOps<K,V> {
  IComparer<K> comparer;

  public FGTreeOps(IComparer<K> comparer) { 
    this.comparer = comparer;
  }

  public bool contains(Node<K,V> t, K key) {
    while (t != null) {
      int cmp = comparer.Compare(key, t.key);
      if (cmp < 0)
        t = t.left;
      else if (cmp > 0) 
        t = t.rght;
      else 
        return true;
    }
    return false;
  }
  
  public Node<K,V> get(Node<K,V> t, K key) {
    while (t != null) {
      int cmp = comparer.Compare(key, t.key);
      if (cmp < 0)
        t = t.left;
      else if (cmp > 0) 
        t = t.rght;
      else 
        return t;
    }
    throw new ElementNotFoundException();
  }

  public bool add(ref Node<K,V> t, K key, V val) { 
    if (t == null) {
      t = new Node<K,V>(key, val);
      return true;
    } else {
      int cmp = comparer.Compare(key, t.key);
      if (cmp < 0) {
        bool added = add(ref t.left, key, val);
        if (!t.red)
          Node<K,V>.lbal(ref t); 
        return added;
      } else if (cmp > 0) {
        bool added = add(ref t.rght, key, val);
        if (!t.red) 
          Node<K,V>.rbal(ref t);
        return added;
      } else 
        return false;
    }
  }

  public Node<K,V> del(ref Node<K,V> t, K key) { 
    if (t == null) {
      throw new ElementNotFoundException("TreeMap.Remove: " + key);
    } else {
      int cmp = comparer.Compare(key, t.key);
      if (cmp < 0) {
        bool tleftblack = !t.left.red;
        Node<K,V> removed = del(ref t.left, key);
        if (tleftblack)  
          Node<K,V>.balleft(ref t);
        else
          t.red = true;
        return removed;
      } else if (cmp > 0) {
        bool trghtblack = !t.rght.red;
        Node<K,V> removed = del(ref t.rght, key);
        if (trghtblack)  
          Node<K,V>.balrght(ref t);
        else
          t.red = true;
        return removed;
      } else {
        Node<K,V> removed = t;
        t = Node<K,V>.append(t.left, t.rght);
        return removed;
      }    
    }
  }
}

// Separate dynamically typed comparer: Compare(object, object) 

internal class FOTreeOps<K,V> : ITreeOps<K,V> {
  System.Collections.IComparer comparer;

  public FOTreeOps(System.Collections.IComparer comparer) { 
    this.comparer = comparer;
  }

  public bool contains(Node<K,V> t, K key) {
    while (t != null) {
      int cmp = comparer.Compare(key, t.key);
      if (cmp < 0)
        t = t.left;
      else if (cmp > 0) 
        t = t.rght;
      else 
        return true;
    }
    return false;
  }
  
  public Node<K,V> get(Node<K,V> t, K key) {
    while (t != null) {
      int cmp = comparer.Compare(key, t.key);
      if (cmp < 0)
        t = t.left;
      else if (cmp > 0) 
        t = t.rght;
      else 
        return t;
    }
    throw new ElementNotFoundException();
  }

  public bool add(ref Node<K,V> t, K key, V val) { 
    if (t == null) {
      t = new Node<K,V>(key, val);
      return true;
    } else {
      int cmp = comparer.Compare(key, t.key);
      if (cmp < 0) {
        bool added = add(ref t.left, key, val);
        if (!t.red)
          Node<K,V>.lbal(ref t); 
        return added;
      } else if (cmp > 0) {
        bool added = add(ref t.rght, key, val);
        if (!t.red) 
          Node<K,V>.rbal(ref t);
        return added;
      } else 
        return false;
    }
  }

  public Node<K,V> del(ref Node<K,V> t, K key) { 
    if (t == null) {
      throw new ElementNotFoundException("TreeMap.Remove: " + key);
    } else {
      int cmp = comparer.Compare(key, t.key);
      if (cmp < 0) {
        bool tleftblack = !t.left.red;
        Node<K,V> removed = del(ref t.left, key);
        if (tleftblack)  
          Node<K,V>.balleft(ref t);
        else
          t.red = true;
        return removed;
      } else if (cmp > 0) {
        bool trghtblack = !t.rght.red;
        Node<K,V> removed = del(ref t.rght, key);
        if (trghtblack)  
          Node<K,V>.balrght(ref t);
        else
          t.red = true;
        return removed;
      } else {
        Node<K,V> removed = t;
        t = Node<K,V>.append(t.left, t.rght);
        return removed;
      }    
    }
  }
}

// The TreeMap class itself, and two subclasses

public class TreeMap<K, V> : ISortedMap<K,V> {
  private int size;		// Number of entries in the tree map
  private int stamp;		// To detect modification during enumeration
  private Node<K,V> root;
  private ITreeOps<K,V> treeops;

  internal TreeMap(ITreeOps<K,V> treeops) {
    size = stamp = 0; 
    root = null; 
    this.treeops = treeops;
  }

  // Object-based dynamically typed explicit comparer

  public TreeMap(System.Collections.IComparer comparer) 
    : this(new FOTreeOps<K,V>(comparer)) { }

  // Generic statically typed explicit comparer

  public TreeMap(IComparer<K> comparer) 
    : this(new FGTreeOps<K,V>(comparer)) { }

  public int Count {
    get { return size; }
  }
  
  public bool Add(K key, V val) {
    bool added = treeops.add(ref root, key, val);
    root.red = false;
    if (added) {
      size++;
      stamp++;
    }
    return added;
  }

  public V this[K key] { 
    get { return treeops.get(root, key).val; }
    set { 
      if (treeops.contains(root, key)) 
	treeops.get(root, key).val = value; 
      else
	treeops.add(ref root, key, value);
    }
  }

  public bool Contains(K key) {
    return treeops.contains(root, key);
  }

  // Remove item from set and return it; or throw ElementNotFoundException

  public MapEntry<K,V> Remove(K key) { 
    Node<K,V> res = treeops.del(ref root, key);
    if (root != null)
      root.red = false;
    size--;
    stamp++;
    return new MapEntry<K,V>(res.key, res.val);
  }

  // Computing the tree depth (for debugging only)

  public int Depth() {
    return depth(root);
  }

  private static int depth(Node<K,V> node) {
    if (node == null) 
      return 0;
    else 
      return 1 + System.Math.Max(depth(node.left), depth(node.rght));
  }

  // Issue: these functions could be optimized to not use the enumerators

  public override int GetHashCode() {
    int sum = 0;
    foreach (MapEntry<K,V> entry in this)
      sum += entry.Key.GetHashCode() ^ entry.Value.GetHashCode();
    return sum;
  }

  public override bool Equals(object that) {
    if (that is IMap<K,V> && Count == ((IMap<K,V>)that).Count) {
      IMap<K,V> thatMap = (IMap<K,V>)that;
      if (thatMap is ISortedMap<K,V>) 
	return equalsSortedMap((ISortedMap<K,V>)thatMap);
      else {
	IEnumerator< MapEntry<K,V> > thisenm = this.GetEnumerator();
	while (thisenm.MoveNext()) {
	  MapEntry<K,V> entry = thisenm.Current;
	  if (!thatMap.Contains(entry.Key) 
	      || !thatMap[entry.Key].Equals(entry.Value))
	    return false;
	}
	return true;
      }
    } else
      return false;
  }

  // More efficient comparison possible when both maps are sorted

  private bool equalsSortedMap(ISortedMap<K,V> thatMap) {
    // assert this.Count == thatMap.Count;
    IEnumerator< MapEntry<K,V> > thisenm = this.GetEnumerator();
    IEnumerator< MapEntry<K,V> > thatenm = thatMap.GetEnumerator();
    while (thisenm.MoveNext() && thatenm.MoveNext()) {
      MapEntry<K,V> tit = thisenm.Current;
      MapEntry<K,V> tat = thatenm.Current;
      if (!tit.Key.Equals(tat.Key) || !tit.Value.Equals(tat.Value))
	return false;
    }
    // assert both thisenm and thatenm are at end, because of the size test
    return true;
  }

  // Do an inorder forwards traversal of the tree

  public IEnumerator<MapEntry<K,V>> GetEnumerator() {
    return new TreeEnumerator(this);
  }

  private class TreeEnumerator : IEnumerator<MapEntry<K,V>> {
    ArrayList< Node<K,V> > stack;
    TreeMap<K,V> tree;
    bool valid;
    int stamp;
    K key;
    V val;

    [Microsoft.Contracts.NotDelayed] public TreeEnumerator(TreeMap<K,V> tree) {
      this.tree = tree; stamp = tree.stamp;
      Reset();
    }
    
    // Issue: should probably not create a new struct on every invocation
    public MapEntry<K,V> Current {
      get { 
	if (valid)
	  return new MapEntry<K,V>(key, val); 
	else
	  throw new InvalidOperationException();
      }
    }
    
    public bool MoveNext() {
      if (stamp != tree.stamp) 
	throw new InvalidOperationException();
      else if (stack.Count > 0) {
        Node<K,V> node = stack.Remove(); 
        // assert node != null;
        while (node.left != null) {
          push(node.rght);				// Push right branch
          stack.Add(new Node<K,V>(node.key, node.val)); // Push node item
          node = node.left;				// Descend left branch
        }
        push(node.rght);
        key = node.key;
        val = node.val;
        return valid = true;
      } else
        return valid = false; 
    }

    private void push(Node<K,V> node) {
      if (node != null)
        stack.Add(node);
    }

    public void Reset() {
      stack = new ArrayList< Node<K,V> >();
      push(tree.root);
      valid = false;
    }
  }
}

// Object-based implicit CompareTo 

public class OTreeMap<K, V> : TreeMap<K,V> 
  where K : System.IComparable {
  public OTreeMap() : base(new OTreeOps<K,V>()) { }
}

// Generic statically typed implicit CompareTo 

public class GTreeMap<K, V> : TreeMap<K,V> 
  where K : IComparable<K> {
  public GTreeMap() : base(new GTreeOps<K,V>()) { }
}

// We cannot do the latter two versions as constructors in TreeMap
// because they need (different) constraints on type parameter K.


// TreeSet (in terms of TreeMap) -----------------------------

public class TreeSet<T> : ISortedSet<T> {
  private TreeMap<T, int> map;	// The int in the treemap is unused

  internal TreeSet(TreeMap<T, int> map) {
    this.map = map;
  }

  // Object-based dynamically typed explicit comparer

  public TreeSet(System.Collections.IComparer comparer) 
    : this(new TreeMap<T,int>(comparer)) { }

  // Generic statically typed explicit comparer

  public TreeSet(IComparer<T> comparer) 
    : this(new TreeMap<T,int>(comparer)) { }

  public int Count {
    get { return map.Count; }
  }

  public bool Add(T item) {
    return map.Add(item, 0);
  }
  
  public T Remove(T item) { 
    return map.Remove(item).Key;  
  }

  public bool Contains(T item) { 
    return map.Contains(item);  
  }

  public IEnumerator<T> GetEnumerator() {
    return new TreeEnumerator(map.GetEnumerator());
  }

  private class TreeEnumerator : IEnumerator<T> {
    private IEnumerator<MapEntry<T,int>> enm;
    
    public TreeEnumerator(IEnumerator< MapEntry<T,int> > enm) {
      this.enm = enm;
    }

    public T Current {
      get { return enm.Current.Key; }
    }
    
    public bool MoveNext() {
      return enm.MoveNext();
    }

    public void Reset() {
      enm.Reset();
    }
  }

  public override int GetHashCode() {
    int sum = 0;
    foreach (T item in this)
      sum += item.GetHashCode();
    return sum;
  }

  public override bool Equals(object that) {
    if (that is ISet<T> && Count == ((ISet<T>)that).Count) {
      ISet<T> thatSet = (ISet<T>)that;
      if (thatSet is ISortedSet<T>) 
	return equalsSortedSet((ISortedSet<T>)thatSet);
      else {
	IEnumerator<T> thisenm = this.GetEnumerator();
	while (thisenm.MoveNext()) {
	  if (!thatSet.Contains(thisenm.Current)) 
	    return false;
	}
	return true;
      }
    } else
      return false;
  }

  // More efficient comparison possible when both sets are sorted

  private bool equalsSortedSet(ISortedSet<T> thatSet) {
    // assert this.Count == thatSet.Count;
    IEnumerator<T> thisenm = this.GetEnumerator();
    IEnumerator<T> thatenm = thatSet.GetEnumerator();
    while (thisenm.MoveNext() && thatenm.MoveNext())
      if (!thisenm.Current.Equals(thatenm.Current))
	return false;
    // assert both thisenm and thatenm are at end, because of the size test
    return true;
  }
}

// Object-based implicit CompareTo 

public class OTreeSet<T> : TreeSet<T> 
  where T : System.IComparable {
  public OTreeSet() : base(new OTreeMap<T,int>()) { }
}

// Generic statically typed implicit CompareTo 

public class GTreeSet<T> : TreeSet<T> 
  where T : IComparable<T> {
  public GTreeSet() : base(new GTreeMap<T,int>()) { }
}

// We cannot do the latter two versions as constructors in TreeSet
// because they need (different) constraints on type parameter T.


// Exceptions ------------------------------------------------

class ElementNotFoundException : Exception { 
  public ElementNotFoundException() : base() { }
  public ElementNotFoundException(string s) : base(s) { }
} 
} // End of namespace GCollections

namespace Test {
	class Program {
	     public static void Main() {
	       System.Console.WriteLine("Ok");
             }
	}
}
`
Ok
`
`/p:v2
// Finding a convex hull in the plane
// This program requires .Net version 2.0.
// Peter Sestoft (sestoft@dina.kvl.dk) * Java 2000-10-07, GC# 2001-10-27

using System;

// ------------------------------------------------------------

// Find the convex hull of a point set in the plane

// An implementation of Graham's (1972) point elimination algorithm,
// as modified by Andrew (1979) to find lower and upper hull separately.

// This implementation correctly handles duplicate points, and
// multiple points with the same x-coordinate.

// 1. Sort the points lexicographically by increasing (x,y), thus 
//    finding also a leftmost point L and a rightmost point R.
// 2. Partition the point set into two lists, upper and lower, according as 
//    point is above or below the segment LR.  The upper list begins with 
//    L and ends with R; the lower list begins with R and ends with L.
// 3. Traverse the point lists clockwise, eliminating all but the extreme
//    points (thus eliminating also duplicate points).
// 4. Eliminate L from lower and R from upper, if necessary.
// 5. Join the point lists (in clockwise order) in an array.

class Convexhull {
  public static Point[] convexhull(Point[] pts) {
    // Sort points lexicographically by increasing (x, y)
    int N = pts.Length;
    Polysort.Quicksort<Point>(pts);
    Point left = pts[0], right = pts[N-1];
    // Partition into lower hull and upper hull
    CDLL<Point> lower = new CDLL<Point>(left), upper = new CDLL<Point>(left);
    for (int i=0; i<N; i++) {
      double det = Point.Area2(left, right, pts[i]);
      if (det > 0) 
        upper = upper.Append(new CDLL<Point>(pts[i])); 
      else if (det < 0) 
        lower = lower.Prepend(new CDLL<Point>(pts[i]));
    }      
    lower = lower.Prepend(new CDLL<Point>(right)); 
    upper = upper.Append(new CDLL<Point>(right)).Next;
    // Eliminate points not on the hull
    eliminate(lower);
    eliminate(upper);
    // Eliminate duplicate endpoints
    if (lower.Prev.val.Equals(upper.val))
      lower.Prev.Delete();
    if (upper.Prev.val.Equals(lower.val))
      upper.Prev.Delete();
    // Join the lower and upper hull
    Point[] res = new Point[lower.Size() + upper.Size()];
    lower.CopyInto(res, 0);
    upper.CopyInto(res, lower.Size());
    return res;
  }

  // Graham's scan
  private static void eliminate(CDLL<Point> start) {
    CDLL<Point> v = start, w = start.Prev;
    bool fwd = false;
    while (v.Next != start || !fwd) {
      if (v.Next == w)
        fwd = true;
      if (Point.Area2(v.val, v.Next.val, v.Next.Next.val) < 0) // right turn
        v = v.Next;
      else {                                       // left turn or straight
        v.Next.Delete();
        v = v.Prev;
      }
    }
  }
}

// ------------------------------------------------------------

// Points in the plane

class Point : Ordered<Point> {
  private static readonly Random rnd = new Random(0); //we fix the seed for repeatable results

  public double x, y;
  
  public Point(double x, double y) { 
    this.x = x; this.y = y; 
  }

  public override string ToString() { 
    return "(" + x + ", " + y + ")"; 
  }

  public static Point Random(int w, int h) { 
    return new Point(rnd.Next(w), rnd.Next(h));
  }

  public bool Equals(Point p2) { 
    return x == p2.x && y == p2.y; 
  }

  public override bool Less(Ordered<Point> o2) { 
    Point p2 = (Point)o2;
    return x < p2.x || x == p2.x && y < p2.y;
  }

  // Twice the signed area of the triangle (p0, p1, p2)
  public static double Area2(Point p0, Point p1, Point p2) { 
    return p0.x * (p1.y-p2.y) + p1.x * (p2.y-p0.y) + p2.x * (p0.y-p1.y); 
  }
}

// ------------------------------------------------------------

// Circular doubly linked lists of T

class CDLL<T> {
  private CDLL<T> prev, next;     // not null, except in deleted elements
  public T val;
  
  // A new CDLL node is a one-element circular list
  public CDLL(T val) { 
    this.val = val; next = prev = this; 
  }

  public CDLL<T> Prev {
    get { return prev; }
  }

  public CDLL<T> Next {
    get { return next; }
  }

  // Delete: adjust the remaining elements, make this one point nowhere
  public void Delete() {
    next.prev = prev; prev.next = next;
    next = prev = null;
  }

  public CDLL<T> Prepend(CDLL<T> elt) {
    elt.next = this; elt.prev = prev; prev.next = elt; prev = elt;
    return elt;
  }

  public CDLL<T> Append(CDLL<T> elt) {
    elt.prev = this; elt.next = next; next.prev = elt; next = elt;
    return elt;
  }

  public int Size() {
    int count = 0;
    CDLL<T> node = this;
    do {
      count++;
      node = node.next;
    } while (node != this);
    return count;
  }

  public void PrintFwd() {
    CDLL<T> node = this;
    do {
      Console.WriteLine(node.val);
      node = node.next;
    } while (node != this);
    Console.WriteLine();
  }

  public void CopyInto(T[] vals, int i) {
    CDLL<T> node = this;
    do {
      vals[i++] = node.val;	// still, implicit checkcasts at runtime 
      node = node.next;
    } while (node != this);
  }
}

// ------------------------------------------------------------

class Polysort {
  private static void swap<T>(T[] arr, int s, int t) {
    T tmp = arr[s];  arr[s] = arr[t];  arr[t] = tmp;    
  }

  // Typed OO-style quicksort a la Hoare/Wirth

  private static void qsort<T>(Ordered<T>[] arr, int a, int b) {
    // sort arr[a..b]
    if (a < b) { 
      int i = a, j = b;
      Ordered<T> x = arr[(i+j) / 2];             
      do {                              
        while (arr[i].Less(x)) i++;     
        while (x.Less(arr[j])) j--;     
        if (i <= j) {                           
          swap< Ordered<T> >(arr, i, j);                
          i++; j--;                     
        }                             
      } while (i <= j);                 
      qsort<T>(arr, a, j);                 
      qsort<T>(arr, i, b);                 
    }                                   
  }

  public static void Quicksort<T>(Ordered<T>[] arr) {
    qsort<T>(arr, 0, arr.Length-1);
  }
}

public abstract class Ordered<T> {
  public abstract bool Less(Ordered<T> that);
}

// ------------------------------------------------------------

class TestCH {
  static void Main(string[] args) {
      int N = 50;
      Point[] pts = new Point[N];
      for (int i=0; i<N; i++)
        pts[i] = Point.Random(500, 500);
      Point[] chpts = Convexhull.convexhull(pts);
      Console.WriteLine("Area is " + area(chpts));
      print(chpts);
    } 

  // The centroid of a point set
  public static Point centroid(Point[] pts) { 
    int N = pts.Length;
    double sumx = 0, sumy = 0;
    for (int i=0; i<N; i++) {
      sumx += pts[i].x;
      sumy += pts[i].y;
    }
    return new Point(sumx/N, sumy/N);
  }

  // The area of a polygon (represented by an array of ordered vertices)
  public static double area(Point[] pts) { 
    int N = pts.Length;
    Point centr = centroid(pts);
    double area2 = 0;
    for (int i=0; i<N; i++) 
      area2 += Point.Area2(centr, pts[i], pts[(i+1)%N]);
    return Math.Abs(area2/2);
  }

  public static void print(Point[] pts) {
    int N = pts.Length;
    for (int i=0; i<N; i++) 
      Console.WriteLine(pts[i]);
  }
}
`
Area is 204092
(499, 240)
(495, 16)
(491, 15)
(93, 34)
(15, 190)
(43, 419)
(62, 452)
(148, 494)
(431, 497)
(447, 448)
`
`/p:v2
// Sorting with Generic C#, and comparisons with dynamically typed sorting
// Revised to use three-way comparisons (IComparable and IGComparable)
// Sorting integers or strings
// This program requires .NET version 2.0.
// Peter Sestoft (sestoft@dina.kvl.dk) * 2001-11-01, 2001-11-22, 2003-08-11

using System;

// Generic sorting routines

public class Polysort {
  // Cannot use this in 
  //   void qsort<T>(IGComparable<T>[] arr, int a, int b)
  // because ref arguments that are array elements of reference
  // type must have the exact element type of the formal parameter

  private static void swap<U>(ref U s, ref U t) {
    U tmp = s;  s = t;  t = tmp;    
  }

  private static void swap<U>(U[] arr, int s, int t) {
    U tmp = arr[s];  arr[s] = arr[t];  arr[t] = tmp;    
  }

  private static void swap(object[] arr, int s, int t) {
    object tmp = arr[s];  arr[s] = arr[t];  arr[t] = tmp;    
  }

  // Polymorphic OO-style quicksort: general, not typesafe
  
  private static void qsort<T>(IGComparable<T>[] arr, int a, int b) {
    // sort arr[a..b]
    if (a < b) { 
      int i = a, j = b;
      IGComparable<T> x = arr[(i+j) / 2];             
      do {                              
        while (arr[i].CompareTo(x) < 0) i++;     
        while (x.CompareTo(arr[j]) < 0) j--;     
        if (i <= j) {                           
	  swap< IGComparable<T> >(arr, i, j);
          i++; j--;                     
        }                             
      } while (i <= j);                 
      qsort<T>(arr, a, j);                 
      qsort<T>(arr, i, b);                 
    }                                   
  }
  
  public static void Quicksort<T>(IGComparable<T>[] arr) {
    qsort<T>(arr, 0, arr.Length-1);
  }

  public static void CheckSorted<T>(IGComparable<T>[] arr) {
    for (int i=1; i<arr.Length; i++)
      if (arr[i].CompareTo(arr[i-1]) < 0)
        throw new Exception("Polysort.CheckSorted");
  }
  
  // Polymorphic functional-style quicksort: general, typesafe
  
  private static void qsort<T>(T[] arr, IGComparer<T> cmp, int a, int b) {
    // sort arr[a..b]
    if (a < b) { 
      int i = a, j = b;
      T x = arr[(i+j) / 2];             
      do {                              
        while (cmp.Compare(arr[i], x) < 0) i++;     
        while (cmp.Compare(x, arr[j]) < 0) j--;     
        if (i <= j) {                           
          swap<T>(ref arr[i], ref arr[j]);           
          // swap<T>(arr, i, j);           
          i++; j--;                     
        }                             
      } while (i <= j);                 
      qsort<T>(arr, cmp, a, j);                 
      qsort<T>(arr, cmp, i, b);                 
    }                                   
  }

  public static void Quicksort<T>(T[] arr, IGComparer<T> cmp) {
    qsort<T>(arr, cmp, 0, arr.Length-1);
  }

  public static void CheckSorted<T>(T[] arr, IGComparer<T> cmp) {
    for (int i=1; i<arr.Length; i++)
      if (cmp.Compare(arr[i], arr[i-1]) < 0)
        throw new Exception("Polysort.CheckSorted");
  }

  // Polymorphic functional-style quicksort using delegates: general, typesafe
  
  public delegate int DGComparer<T>(T v1, T v2);

  private static void qsort<T>(T[] arr, DGComparer<T> cmp, int a, int b) {
    // sort arr[a..b]
    if (a < b) { 
      int i = a, j = b;
      T x = arr[(i+j) / 2];             
      do {                              
        while (cmp(arr[i], x) < 0) i++;     
        while (cmp(x, arr[j]) < 0) j--;     
        if (i <= j) {                           
          swap<T>(ref arr[i], ref arr[j]);           
          // swap<T>(arr, i, j);           
          i++; j--;                     
        }                             
      } while (i <= j);                 
      qsort<T>(arr, cmp, a, j);                 
      qsort<T>(arr, cmp, i, b);                 
    }                                   
  }

  public static void Quicksort<T>(T[] arr, DGComparer<T> cmp) {
    qsort<T>(arr, cmp, 0, arr.Length-1);
  }
}

public class Polyselfsort {
  private static void swap<T>(T[] arr, int s, int t) {
    T tmp = arr[s];  arr[s] = arr[t];  arr[t] = tmp;    
  }
  
  // Polymorphic OO-style quicksort: general, typesafe
  // Note the type parameter bound in the generic method
  
  public static void qsort<T>(T[] arr, int a, int b) 
    where T : IGSelfComparable<T> {
    // sort arr[a..b]
    if (a < b) { 
      int i = a, j = b;
      T x = arr[(i+j) / 2];             
      do {                              
        while (arr[i].CompareTo(x) < 0) i++;     
        while (x.CompareTo(arr[j]) < 0) j--;     
        if (i <= j) {                           
          swap<T>(arr, i, j);                
          i++; j--;                     
        }                             
      } while (i <= j);                 
      qsort<T>(arr, a, j);                 
      qsort<T>(arr, i, b);                 
    }                                   
   }
  
  public static void Quicksort<T>(T[] arr) where T : IGSelfComparable<T> {
    qsort<T>(arr, 0, arr.Length-1);
  }
}

public class Objsort {
  private static void swap(object[] arr, int s, int t) {
    object tmp = arr[s];  arr[s] = arr[t];  arr[t] = tmp;    
  }

  // OO-style IComparable quicksort: general, not typesafe

  private static void qsort(IComparable[] arr, int a, int b) {
    // sort arr[a..b]
    if (a < b) { 
      int i = a, j = b;
      IComparable x = arr[(i+j) / 2];             
      do {                              
        while (arr[i].CompareTo(x) < 0) i++;     
        while (x.CompareTo(arr[j]) < 0) j--;     
        if (i <= j) {                           
          swap(arr, i, j);                
          i++; j--;                     
        }                             
      } while (i <= j);                 
      qsort(arr, a, j);                 
      qsort(arr, i, b);                 
    }
  }

  public static void Quicksort(IComparable[] arr) {
    qsort(arr, 0, arr.Length-1);
  }

  public static void CheckSorted(IComparable[] arr) {
    for (int i=1; i<arr.Length; i++)
      if (arr[i].CompareTo(arr[i-1]) < 0)
        throw new Exception("Objsort.CheckSorted");
  }
}

public class Intsort {
  private static void swap(int[] arr, int s, int t) {
    int tmp = arr[s];  arr[s] = arr[t];  arr[t] = tmp;    
  }

  // Plain monomorphic quicksort: not general, but typesafe

  private static void qsort(int[] arr, int a, int b) {
    // sort arr[a..b]
    if (a < b) { 
      int i = a, j = b;
      int x = arr[(i+j) / 2];             
      do {                              
        while (arr[i] < x) i++;     
        while (x < arr[j]) j--;     
        if (i <= j) {                           
          swap(arr, i, j);                
          i++; j--;                     
        }                             
      } while (i <= j);                 
      qsort(arr, a, j);                 
      qsort(arr, i, b);                 
    }
  }

  public static void Quicksort(int[] arr) {
    qsort(arr, 0, arr.Length-1);
  }

  public static void CheckSorted(int[] arr) {
    for (int i=1; i<arr.Length; i++)
      if (arr[i] < arr[i-1])
        throw new Exception("Intsort.CheckSorted");
  }
}

public class Stringsort {
  private static void swap(string[] arr, int s, int t) {
    string tmp = arr[s];  arr[s] = arr[t];  arr[t] = tmp;    
  }

  // Plain monomorphic quicksort: not general, but typesafe

  private static void qsort(string[] arr, int a, int b) {
    // sort arr[a..b]
    if (a < b) { 
      int i = a, j = b;
      string x = arr[(i+j) / 2];             
      do {                              
        while (string.Compare(arr[i],x) < 0) i++;     
        while (string.Compare(x,arr[j]) < 0) j--;     
        if (i <= j) {                           
          swap(arr, i, j);                
          i++; j--;                     
        }                             
      } while (i <= j);                 
      qsort(arr, a, j);                 
      qsort(arr, i, b);                 
    }
  }

  public static void Quicksort(string[] arr) {
    qsort(arr, 0, arr.Length-1);
  }

  public static void CheckSorted(string[] arr) {
    for (int i=1; i<arr.Length; i++)
      if (string.Compare(arr[i], arr[i-1]) < 0)
        throw new Exception("Stringsort.CheckSorted");
  }
}

public class FunIntsort {
  private static void swap(int[] arr, int s, int t) {
    int tmp = arr[s];  arr[s] = arr[t];  arr[t] = tmp;    
  }

  // Monomorphic quicksort with comparer: not general, but typesafe

  private static void qsort(int[] arr, IIntComparer cmp, int a, int b) {
    // sort arr[a..b]
    if (a < b) { 
      int i = a, j = b;
      int x = arr[(i+j) / 2];             
      do {                              
        while (cmp.Compare(arr[i], x) < 0) i++;     
        while (cmp.Compare(x, arr[j]) < 0) j--;     
        if (i <= j) {                           
          swap(arr, i, j);                
          i++; j--;                     
        }                             
      } while (i <= j);                 
      qsort(arr, cmp, a, j);                 
      qsort(arr, cmp, i, b);                 
    }
  }

  public static void Quicksort(int[] arr, IIntComparer cmp) {
    qsort(arr, cmp, 0, arr.Length-1);
  }
}

public class FunStringsort {
  private static void swap(string[] arr, int s, int t) {
    string tmp = arr[s];  arr[s] = arr[t];  arr[t] = tmp;    
  }

  // Monomorphic quicksort with comparer: not general, but typesafe

  private static void qsort(string[] arr, IStringComparer cmp, int a, int b) {
    // sort arr[a..b]
    if (a < b) { 
      int i = a, j = b;
      string x = arr[(i+j) / 2];             
      do {                              
        while (cmp.Compare(arr[i], x) < 0) i++;     
        while (cmp.Compare(x, arr[j]) < 0) j--;     
        if (i <= j) {                           
          swap(arr, i, j);                
          i++; j--;                     
        }                             
      } while (i <= j);                 
      qsort(arr, cmp, a, j);                 
      qsort(arr, cmp, i, b);                 
    }
  }

  public static void Quicksort(string[] arr, IStringComparer cmp) {
    qsort(arr, cmp, 0, arr.Length-1);
  }
}

// Two generic versions of IComparable

public interface IGComparable<T> {
  int CompareTo(IGComparable<T> that);
}

public interface IGSelfComparable<T> {
  // Actually we could assert a bound on the parameter: 
  //   public interface IGSelfComparable< T : IGSelfComparable<T> >
  // but there seems to be no need for that.

  // Note that the argument type is T itself, not a superclass:
  int CompareTo(T that);
}

// An int wrapper that implements all Comparable interfaces

public class OrderedInt : IComparable,
                          IGComparable<OrderedInt>,
                          IGSelfComparable<OrderedInt> {
  int i;

  public OrderedInt(int i) {
    this.i = i;
  }

  public int Value { 
    get { return i; } 
  }

  // Implements IComparable.CompareTo(object)
  public int CompareTo(object that) {
    int thati = ((OrderedInt)that).i;
    return i < thati ? -1 : i > thati ? +1 : 0;
  }

  // Implements IGComparable<OrderedInt>.CompareTo(IGComparable<OrderedInt>)
  public int CompareTo(IGComparable<OrderedInt> that) {
    int thati = ((OrderedInt)that).i;
    return i < thati ? -1 : i > thati ? +1 : 0;
  }

  // Implements IGSelfComparable<OrderedInt>.CompareTo(T)
  // because with T = OrderedInt we have T : IGSelfComparable<T>
  public int CompareTo(OrderedInt that) {
    // Simple subtraction i-that.i won't do because of possible overflow.
    return i < that.i ? -1 : i > that.i ? +1 : 0;
    // This following is eight times slower, although the compiler 
    // and runtime knows that i and that.i are ints:
    // return i.CompareTo(that.i);
  }
}

// A string wrapper that implements all Comparable interfaces

public class OrderedString : IComparable,
                             IGComparable<OrderedString>,
                             IGSelfComparable<OrderedString> {
  string s;

  public OrderedString(string s) {
    this.s = s;
  }

  public string Value { 
    get { return s; } 
  }

  // Implements IComparable.CompareTo(object)
  public int CompareTo(object that) {
    return string.Compare(this.s, ((OrderedString)that).s);
  }

  // Implements IGComparable<OrderedString>.CompareTo(IGComparable<OrderedString>)
  public int CompareTo(IGComparable<OrderedString> that) {
    return string.Compare(this.s, ((OrderedString)that).s);
  }

  // Implements IGSelfComparable<OrderedString>.CompareTo(T)
  // because with T = OrderedString we have T : IGSelfComparable<T>
  public int CompareTo(OrderedString that) {
    return string.Compare(this.s, that.s);
  }
}

// A generic version of IComparer

public interface IGComparer<T> {
  int Compare(T v1, T v2);
}

public interface IIntComparer {
  int Compare(int v1, int v2);
}

public class IntComparer : IGComparer<int>, IIntComparer {
  public int Compare(int v1, int v2) {
    return v1 < v2 ? -1 : v1 > v2 ? +1 : 0;
  }
}

public interface IStringComparer {
  int Compare(string v1, string v2);
}

public class StringComparer : IGComparer<string>, IStringComparer {
  public int Compare(string v1, string v2) {
    return string.Compare(v1, v2);
  }
}

// Try it on integers

public class Gsort {
  static readonly Random rnd = new Random();

  static void Main(string[] args) {
      int N = 100;
      int k = 1;
      const string hdfmt = "{0,9:0.00}";
      const string fmt =   "(ran)     ";
      {
	Console.Out.WriteLine(" Sorting {0} ints", N);
	headers(hdfmt);
	for (int i=0; i<k; i++) {
	  int[] arr = mkRandomInts(N);
          Console.Out.Write(fmt, ObjComparable(arr));
          Console.Out.Write(fmt, ObjOrderedInt(arr));
          Console.Out.Write(fmt, MonoIntPrimitive(arr));
          Console.Out.Write(fmt, MonoIntComparer(arr));
          Console.Out.Write(fmt, PolyIGComparable(arr));
          Console.Out.Write(fmt, PolyIGSelfComparable(arr));
          Console.Out.Write(fmt, PolyIGComparer(arr));
          Console.Out.Write(fmt, PolyDGComparer(arr));
	  Console.Out.WriteLine();
	} 
      { Console.Out.WriteLine(" Sorting {0} strings", N);
	headers(hdfmt);
	for (int i=0; i<k; i++) {
	  string[] arr = mkRandomStrings(N);
	  Console.Out.Write(fmt, ObjComparable(arr));
	  Console.Out.Write(fmt, ObjOrderedString(arr));
	  Console.Out.Write(fmt, MonoStringPrimitive(arr));
	  Console.Out.Write(fmt, MonoStringComparer(arr));
	  Console.Out.Write(fmt, PolyIGComparable(arr));
	  Console.Out.Write(fmt, PolyIGSelfComparable(arr));
	  Console.Out.Write(fmt, PolyIGComparer(arr));
	  Console.Out.Write(fmt, PolyDGComparer(arr));
	  Console.Out.WriteLine();
	}
      }
    }
  }

  static void headers(string fmt) {
      Console.Out.Write(fmt, "general");
      Console.Out.Write(fmt, "general");
      Console.Out.Write(fmt, "not genl");
      Console.Out.Write(fmt, "not genl");
      Console.Out.Write(fmt, "general");
      Console.Out.Write(fmt, "general");
      Console.Out.Write(fmt, "general");
      Console.Out.Write(fmt, "general");
      Console.Out.WriteLine();
      Console.Out.Write(fmt, "not safe");
      Console.Out.Write(fmt, "not safe");
      Console.Out.Write(fmt, "typesafe");
      Console.Out.Write(fmt, "typesafe");
      Console.Out.Write(fmt, "not safe");
      Console.Out.Write(fmt, "typesafe");
      Console.Out.Write(fmt, "typesafe");
      Console.Out.Write(fmt, "typesafe");
      Console.Out.WriteLine();
      Console.Out.Write(fmt, "Comparab");
      Console.Out.Write(fmt, "OrderedI");
      Console.Out.Write(fmt, "Primitiv");
      Console.Out.Write(fmt, "Comparer");
      Console.Out.Write(fmt, "GCompara");
      Console.Out.Write(fmt, "GSelfCom");
      Console.Out.Write(fmt, "IGCompar");
      Console.Out.Write(fmt, "DGCompar");
      Console.Out.WriteLine();
  }

  // The standard OO thing to do, given that int : IComparable
  static double ObjComparable(int[] arr) {
    int n = arr.Length;
    // Objsort.Quicksort(arr) would be illegal since int[] cannot be
    // converted to IComparable[], even though int : IComparable.
    IComparable[] oarr = new IComparable[n];
    for (int i=0; i<n; i++)
      oarr[i] = arr[i];  // using that int : IComparable
    Timer t = new Timer();
    Objsort.Quicksort(oarr);
    //    print(oarr);
    return t.Check();
  }

  // Here we're using our own int wrapper, instead of IComparable (faster)
  static double ObjOrderedInt(int[] arr) {
    int n = arr.Length;
    OrderedInt[] oarr = new OrderedInt[n];
    for (int i=0; i<n; i++)
      oarr[i] = new OrderedInt(arr[i]); 
    Timer t = new Timer();
    Objsort.Quicksort(oarr);
    //    print(oarr);
    return t.Check();
  }

  static double MonoIntPrimitive(int[] arr) {
    int n = arr.Length;
    int[] narr = new int[n];
    for (int i=0; i<n; i++)
      narr[i] = arr[i]; 
    Timer t = new Timer();
    Intsort.Quicksort(narr);
    //    print(narr);
    return t.Check();
  }

  static double MonoIntComparer(int[] arr) {
    int n = arr.Length;
    int[] narr = new int[n];
    for (int i=0; i<n; i++)
      narr[i] = arr[i]; 
    Timer t = new Timer();
    FunIntsort.Quicksort(narr, new IntComparer());
    //    print(narr);
    return t.Check();
  }

  static double PolyIGComparable(int[] arr) {
    int n = arr.Length;
    OrderedInt[] oarr = new OrderedInt[n];
    for (int i=0; i<n; i++)
      oarr[i] = new OrderedInt(arr[i]); 
    Timer t = new Timer();
    Polysort.Quicksort<OrderedInt>(oarr);
    //    print(oarr);
    return t.Check();
  }

  static double PolyIGSelfComparable(int[] arr) {
    int n = arr.Length;
    OrderedInt[] oarr = new OrderedInt[n];
    for (int i=0; i<n; i++)
      oarr[i] = new OrderedInt(arr[i]); 
    Timer t = new Timer();
    Polyselfsort.Quicksort<OrderedInt>(oarr);
    //    print(oarr);
    return t.Check();
  }

  static double PolyIGComparer(int[] arr) {
    int n = arr.Length;
    int[] narr = new int[n];
    for (int i=0; i<n; i++)
      narr[i] = arr[i]; 
    Timer t = new Timer();
    Polysort.Quicksort<int>(narr, new IntComparer());
    //    print(narr);
    return t.Check();
  }

  static int intCompare(int v1, int v2) {
    return v1 < v2 ? -1 : v1 > v2 ? +1 : 0;
  }

  static double PolyDGComparer(int[] arr) {
    int n = arr.Length;
    int[] narr = new int[n];
    for (int i=0; i<n; i++)
      narr[i] = arr[i]; 
    Timer t = new Timer();
    Polysort.Quicksort<int>(narr, new Polysort.DGComparer<int>(intCompare));
    //    print(narr);
    return t.Check();
  }

  // Eight ways to sort strings

  // The standard OO thing to do, given that string : IComparable
  static double ObjComparable(string[] arr) {
    int n = arr.Length;
    // Objsort.Quicksort(arr) would be illegal since string[] cannot be
    // converted to IComparable[], even though string : IComparable.
    IComparable[] oarr = new IComparable[n];
    for (int i=0; i<n; i++)
      oarr[i] = arr[i];  // using that string : IComparable
    Timer t = new Timer();
    Objsort.Quicksort(oarr);
    //    print(oarr);
    return t.Check();
  }

  // Here we're using our own string wrapper, instead of IComparable (faster)
  static double ObjOrderedString(string[] arr) {
    int n = arr.Length;
    OrderedString[] oarr = new OrderedString[n];
    for (int i=0; i<n; i++)
      oarr[i] = new OrderedString(arr[i]); 
    Timer t = new Timer();
    Objsort.Quicksort(oarr);
    //    print(oarr);
    return t.Check();
  }

  static double MonoStringPrimitive(string[] arr) {
    int n = arr.Length;
    string[] narr = new string[n];
    for (int i=0; i<n; i++)
      narr[i] = arr[i]; 
    Timer t = new Timer();
    Stringsort.Quicksort(narr);
    //    print(narr);
    return t.Check();
  }

  static double MonoStringComparer(string[] arr) {
    int n = arr.Length;
    string[] narr = new string[n];
    for (int i=0; i<n; i++)
      narr[i] = arr[i]; 
    Timer t = new Timer();
    FunStringsort.Quicksort(narr, new StringComparer());
    //    print(narr);
    return t.Check();
  }

  static double PolyIGComparable(string[] arr) {
    int n = arr.Length;
    OrderedString[] oarr = new OrderedString[n];
    for (int i=0; i<n; i++)
      oarr[i] = new OrderedString(arr[i]); 
    Timer t = new Timer();
    Polysort.Quicksort<OrderedString>(oarr);
    //    print(oarr);
    return t.Check();
  }

  static double PolyIGSelfComparable(string[] arr) {
    int n = arr.Length;
    OrderedString[] oarr = new OrderedString[n];
    for (int i=0; i<n; i++)
      oarr[i] = new OrderedString(arr[i]); 
    Timer t = new Timer();
    Polyselfsort.Quicksort<OrderedString>(oarr);
    //    print(oarr);
    return t.Check();
  }

  static double PolyIGComparer(string[] arr) {
    int n = arr.Length;
    string[] narr = new string[n];
    for (int i=0; i<n; i++)
      narr[i] = arr[i]; 
    Timer t = new Timer();
    Polysort.Quicksort<string>(narr, new StringComparer());
    //    print(narr);
    return t.Check();
  }

  static double PolyDGComparer(string[] arr) {
    int n = arr.Length;
    string[] narr = new string[n];
    for (int i=0; i<n; i++)
      narr[i] = arr[i]; 
    Timer t = new Timer();
    // Note that string.Compare plugs right into the delegate:
    Polysort.Quicksort<string>(narr, new Polysort.DGComparer<string>(string.Compare));
    //    print(narr);
    return t.Check();
  }

  // Create arrays of random ints

  static int[] mkRandomInts(int n) {
    int[] arr = new int[n];
    for (int i=0; i<n; i++) 
      arr[i] = rnd.Next(100000000);
    return arr;
  }

  // Create arrays of random strings

  static string[] mkRandomStrings(int n) {
    string[] arr = new string[n];
    for (int i=0; i<n; i++) 
      arr[i] = mkRandomString(5 + rnd.Next(15));
    return arr;
  }

  static string mkRandomString(int n) {
    System.Text.StringBuilder sb = new System.Text.StringBuilder();
    for (int i=0; i<n; i++) 
      sb.Append((char)(65 + rnd.Next(26) + 32 * rnd.Next(2)));
    return sb.ToString();
  }

  static void print(int[] arr) {
    for (int i=0; i<arr.Length; i++)
      Console.Write("{0} ", arr[i]);
    Console.WriteLine();
  }

  static void print(IComparable[] arr) {
    for (int i=0; i<arr.Length; i++)
      Console.Write("{0} ", (int)arr[i]);
    Console.WriteLine();
  }

  static void print(OrderedInt[] arr) {
    for (int i=0; i<arr.Length; i++)
      Console.Write("{0} ", arr[i].Value);
    Console.WriteLine();
  }
}

public class Timer {
  private DateTime start;

  public Timer() {
    start = DateTime.Now;
  }

  public double Check() {
    TimeSpan dur = DateTime.Now - start;
    return dur.TotalSeconds;
  }
}
` Sorting 100 ints
  general  general not genl not genl  general  general  general  general
 not safe not safe typesafe typesafe not safe typesafe typesafe typesafe
 Comparab OrderedI Primitiv Comparer GCompara GSelfCom IGCompar DGCompar
(ran)     (ran)     (ran)     (ran)     (ran)     (ran)     (ran)     (ran)     
 Sorting 100 strings
  general  general not genl not genl  general  general  general  general
 not safe not safe typesafe typesafe not safe typesafe typesafe typesafe
 Comparab OrderedI Primitiv Comparer GCompara GSelfCom IGCompar DGCompar
(ran)     (ran)     (ran)     (ran)     (ran)     (ran)     (ran)     (ran)     
`
`/p:v2 /r:GCollections.dll
// Typed memoization in Generic C# 
// This program requires .Net version 2.0
// Peter Sestoft (sestoft@dina.kvl.dk) * 2001-12-04

// Compile this file with 
//   csc /addmodule:GCollections.netmodule Memoization.cs

using GCollections;
using System;

public interface Method<R, A> {
  R call(A a);
}

// Functional-style memoization
// ----------------------------
// A Method<R,A> is a function of type A -> R.
// A ProtoMethod<R,A> is a function transformer (uncurried),
// of type (A -> R) * A -> R.
// A Memoize<R,A> is a memoizer for recursive functions of type A -> R, in
// fact, a fixed-point combinator, of type: ((A -> R) * A -> R) -> A -> R
//
// This uses delegates because that will permit mutually
// recursive memoized methods, and memoization of static as well
// as non-static methods.

public delegate R ProtoMethod<R, A>(Method<R, A> method, A a);

class Memoize<R, A> : Method<R, A> {
  private HashMap<A, R> table;
  private ProtoMethod<R, A> protomethod;
  
  public Memoize(ProtoMethod<R, A> protomethod) {
    this.protomethod = protomethod;
    table = new HashMap<A, R>();
  }

  public R call(A a) {
    if (table.Contains(a))
      return table[a];
    else 
      return table[a] = protomethod(this, a);
  }
}

// Object-oriented memoization
// ---------------------------
// Looks simpler, but does not permit mutually recursive memoized 
// methods (I think).

abstract class OOMemoize<R, A> : Method<R, A> {
  private HashMap<A, R> table = new HashMap<A, R>();

  public R call(A a) {
    if (table.Contains(a))
      return table[a];
    else 
      return table[a] = protomethod(a);
  }

  public abstract R protomethod(A a);	// To be implemented by subclass
}

// The Fibonacci function

class OFib : OOMemoize<double, int> {
  public override double protomethod(int n) {
    if (n <= 1)
      return 1.0;
    else 
      return call(n-1) + call(n-2);
  }
}

// Memoizing and calling the Fibonacci function

class TestMemo {
  // The Fibonacci function as a transformer
  static double Fib(Method<double, int> fib, int n) {
    if (n <= 1)
      return 1.0;
    else 
      return fib.call(n-1) + fib.call(n-2);
  }

  // The memoized Fibonacci function
  static Method<double,int> ffib = 
    new Memoize<double,int>(new ProtoMethod<double,int>(Fib));
  
  static Method<double,int> ofib = new OFib();

  static void Main(string[] args) {
    int max = 20;
    for (int i=0; i<= max; i++)
      Console.WriteLine(i + " " + ffib.call(i));
    for (int i=0; i<= max; i++)
      Console.WriteLine(i + " " + ofib.call(i));
  }
}
`0 1
1 1
2 2
3 3
4 5
5 8
6 13
7 21
8 34
9 55
10 89
11 144
12 233
13 377
14 610
15 987
16 1597
17 2584
18 4181
19 6765
20 10946
0 1
1 1
2 2
3 3
4 5
5 8
6 13
7 21
8 34
9 55
10 89
11 144
12 233
13 377
14 610
15 987
16 1597
17 2584
18 4181
19 6765
20 10946
`
`/p:v2 /r:GCollections.dll
// Parser combinators in Generic C# 
// This program requires .Net version 2.0
// Peter Sestoft (sestoft@dina.kvl.dk) * 2001-11-13, 2001-11-19

// Compile GCollections.cs with 
//   csc /t:module GCollections.cs
// Then compile this file with 
//   csc /addmodule:GCollections.netmodule Parsers.cs

// No backtracking in alternatives (Alt) so far.  

// A parser is a function that reads from a source (a stream).  It
// either succeeds in parsing a prefix of the stream and then returns
// a result together with the rest of the stream, or fails.

// A parser returning a result of type T is an object of type
// Parser<T>, which has a function Parse(ISource) that returns a
// Result<T>.  A result is either Succ(result, rest of source) or Fail.

using System;
using System.Text;		// For StringBuilder
using GCollections;		// For LinkedList<T>

// Parser results --------------------------------------------------

interface Result<T> { 
  bool Success { get; }
  T Value { get; }
  ISource Source { get; }
}

class Succ<T> : Result<T> {
  T t;
  ISource src;

  public Succ(T t, ISource src) { 
    this.t = t; this.src = src;
  }

  public bool Success { 
    get { return true; }
  }

  public T Value { 
    get { return t; }
  }

  public ISource Source { 
    get { return src; }
  }
}

class Fail<T> : Result<T> {
 public bool Success { 
    get { return false; }
  }

  public T Value { 
    get { throw new InvalidOperationException(); }
  }

  public ISource Source { 
    get { throw new InvalidOperationException(); }
  }
}

// Results: pairs  -------------------------------------------------

class Pair<T,U> {
  T t;
  U u;
  
  public Pair(T t, U u) { 
    this.t = t; this.u = u;
  }

  public T Fst { 
    get { return t; } 
  }

  public U Snd { 
    get { return u; } 
  }
}

// Results: option type --------------------------------------------

class Option<T> {
  T val;
  bool ok;

  public Option() { 
    this.ok = false; 
  }

  public Option(T val) { 
    this.ok = true; this.val = val;
  }

  public bool Ok { 
    get { return ok; }
  }
  
  public T Value { 
    get { 
      if (ok)
	return val; 
      else 
	throw new InvalidOperationException();
    }
  }
}

// Sources: functional streams -------------------------------------

interface ISource {		
  ISource MoveNext();		// returns null if at end
  char Current { get; }
}

struct StringSource : ISource {
  // invariant: i < s.Length
  readonly string s;
  readonly int i;

  public StringSource(string s) {
    this.s = s; this.i = -1;
  }

  private StringSource(string s, int i) {
    this.s = s; this.i = i;
  }

  public char Current {
    get {
      if (i < 0) 
	throw new InvalidOperationException();
      else
	return s[i]; 
    }
  }

  public ISource MoveNext() {
    if (i+1 < s.Length) 
      return new StringSource(s, i+1);
    else 
      return null;
  }
}

// Parsers ---------------------------------------------------------

interface Parser<T> {
  Result<T> Parse(ISource src);
}

// Always succeeds

class Success<T> : Parser<T> {
  T result;

  public Success(T result) { 
    this.result = result; 
  }

  public Result<T> Parse(ISource src) {
    return new Succ<T>(result, src);
  }
}

// Always fails

class Failure<T> : Parser<T> {
  public Failure() { }

  public Result<T> Parse(ISource src) {
    return new Fail<T>();
  }
}

// Parse a T, then a U, and return the pair (T,U)

class Seq<T,U> : Parser<Pair<T,U> > {
  Parser<T> tp;
  Parser<U> up;

  public Seq(Parser<T> tp, Parser<U> up) { 
    this.tp = tp; this.up = up; 
  }

  public Result<Pair<T,U> > Parse(ISource src) {
    Result<T> tr = tp.Parse(src);
    if (tr.Success) {
      Result<U> ur = up.Parse(tr.Source);
      if (ur.Success) 
	return new Succ<Pair<T,U> >(new Pair<T,U>(tr.Value, ur.Value), 
				    ur.Source);
    }
    return new Fail<Pair<T,U> >();
  }
}

// Parse a T, then a U, and return the T

class SeqFst<T,U> : Parser<T> {
  Parser<T> tp;
  Parser<U> up;

  public SeqFst(Parser<T> tp, Parser<U> up) { 
    this.tp = tp; this.up = up; 
  }

  public Result<T> Parse(ISource src) {
    Result<T> tr = tp.Parse(src);
    if (tr.Success) {
      Result<U> ur = up.Parse(tr.Source);
      if (ur.Success) 
	return new Succ<T>(tr.Value, ur.Source);
    }
    return new Fail<T>();
  }
}

// Parse a T, then U, and return the U

class SeqSnd<T,U> : Parser<U> {
  Parser<T> tp;
  Parser<U> up;

  public SeqSnd(Parser<T> tp, Parser<U> up) { 
    this.tp = tp; this.up = up; 
  }

  public Result<U> Parse(ISource src) {
    Result<T> tr = tp.Parse(src);
    if (tr.Success) {
      Result<U> ur = up.Parse(tr.Source);
      if (ur.Success) 
	return new Succ<U>(ur.Value, ur.Source);
    }
    return new Fail<U>();
  }
}

// Parse a T and succeed with result, or else succeed without

class Opt<T> : Parser< Option<T> > {
  Parser<T> tp;

  public Opt(Parser<T> tp) {
    this.tp = tp;
  }

  public Result< Option<T> > Parse(ISource src) {
    Result<T> tr = tp.Parse(src);
    if (tr.Success) 
      return new Succ< Option<T> >(new Option<T>(tr.Value), tr.Source);
    else
      return new Succ< Option<T> >(new Option<T>(), src);
  }
}

// Parse a T in one of several ways

class Alt<T> : Parser<T> {
  Parser<T>[] ps;

  public Alt(Parser<T> tp, Parser<T> up) { 
    this.ps = new Parser<T>[] { tp, up };
  }

  public Alt(Parser<T>[] ps) { 
    this.ps = ps;
  }

  public Result<T> Parse(ISource src) {
    foreach (Parser<T> p in ps) {
      Result<T> res = p.Parse(src);
      if (res.Success)
	return new Succ<T>(res.Value, res.Source);
    }
    return new Fail<T>();
  }
}

// Parse zero or more T's, return list

class Star<T> : Parser<LinkedList<T> > {
  Parser<T> tp;

  public Star(Parser<T> tp) { 
    this.tp = tp; 
  }

  public Result<LinkedList<T> > Parse(ISource src) {
    LinkedList<T> res = new LinkedList<T>();
    Result<T> tr = tp.Parse(src);
    while (tr.Success) {
      res.AddLast(tr.Value);
      src = tr.Source;
      tr = tp.Parse(src);
    }
    return new Succ<LinkedList<T> >(res, src);
  }
}

// Parse one or more T's, return list

class Plus<T> : Star<T> {
  public Plus(Parser<T> tp) : base(tp) { }

  public new Result<LinkedList<T> > Parse(ISource src) {
    Result<LinkedList<T> > res = base.Parse(src);
    if (res is Succ<LinkedList<T> > && res.Value.Count >= 1)
      return res;
    else
      return new Fail<LinkedList<T> >();
  }
}

// Parse a character satisfying Ok(c)

abstract class ParseTestChar : Parser<char> { 
  public Result<char> Parse(ISource src) {
    ISource src1 = src.MoveNext(); 
    if (src1 != null) 
      if (Ok(src1.Current)) 
	return new Succ<char>(src1.Current, src1);
    return new Fail<char>();
  }
  
  public abstract bool Ok(char c);
}

// Parse a digit / parse a comma

class Digit : ParseTestChar { 
  public override bool Ok(char c) {
    return System.Char.IsDigit(c);
  }
}

class Comma : ParseTestChar { 
  public override bool Ok(char c) {
    return c == ',';
  }
}

// Check for a particular character

class ParseChar : ParseTestChar {
  char c;

  public ParseChar(char c) {
    this.c = c;
  }

  public override bool Ok(char c) {
    return this.c == c;
  }
}

// Parse the longest (possibly empty) prefix of characters satisfying Ok

abstract class ParseChars0 : Parser<string> { 
  public virtual Result<string> Parse(ISource src) {
    StringBuilder sb = new StringBuilder();
    ISource src1 = src;
    ISource src2 = src1.MoveNext();
    while (src2 != null && Ok(src2.Current)) {
      sb.Append(src2.Current);
      src1 = src2;
      src2 = src1.MoveNext();
    }
    return new Succ<string>(sb.ToString(), src1);
  }
  
  public abstract bool Ok(char c);
}

// Parse zero or more whitespace characters

class ParseWS : ParseChars0 { 
  public override bool Ok(char c) {
    return System.Char.IsWhiteSpace(c);
  }
}

// Skip initial whitespace, then parse a T

class SkipWS<T> : SeqSnd<string,T> {
  static readonly Parser<string> parseWS = new ParseWS();

  public SkipWS(Parser<T> tp) : base(parseWS, tp) { } 
}

// Parse the longest non-empty prefix of characters satisfying Ok

abstract class ParseChars1 : ParseChars0 { 
  public override Result<string> Parse(ISource src) {
    Result<string> res = base.Parse(src);
    if (res.Success && res.Value.Length > 0)
      return res;
    else
      return new Fail<string>();
  }
}

// Parse an integer; note the combination of ParseChars1 and Transform

class ParseInt : Transform<string, int> /* , Parser<int> */ {
  public ParseInt() : base(new ParseIntString()) { }

  public override int Trans(string s) {
    return int.Parse(s);
  }

  private class ParseIntString : ParseChars1 { 
    public override bool Ok(char c) {
      return System.Char.IsDigit(c);
    }
  }
}

// Parse the given string lit

class ParseLit : Parser<string> { 
  string lit;

  public ParseLit(string lit) {
    this.lit = lit;
  }

  public Result<string> Parse(ISource src) {
    ISource src1 = src;
    ISource src2 = src1.MoveNext(); 
    int i=0;
    while (i < lit.Length && src2 != null && src2.Current == lit[i]) {
      src1 = src2;
      src2 = src1.MoveNext();
      i++;
    }
    if (i >= lit.Length) 
      return new Succ<string>(lit, src1);
    else
      return new Fail<string>();
  }
}

// Parse a T and transform it to a U

abstract class Transform<T,U> : Parser<U> {
  Parser<T> tp;

  public Transform(Parser<T> tp) {
    this.tp = tp;
  }
  
  public Result<U> Parse(ISource src) {
    Result<T> tr = tp.Parse(src);
    if (tr.Success) 
      return new Succ<U>(Trans(tr.Value), tr.Source);
    return new Fail<U>();
  }
  
  public abstract U Trans(T t);
}

// A protoparser, or recursive parser builder

interface IProtoParser<T> {
  Parser<T> Build(Parser<T> parser);
} 

// Create a recursive parser from a protoparser by tying the knot

class ParseRec<T> : Parser<T> {
  Parser<T> tp;
  
  [Microsoft.Contracts.NotDelayed] public ParseRec(IProtoParser<T> pp) {
    tp = pp.Build(this);
  }

  public Result<T> Parse(ISource src) {
    return tp.Parse(src);
  }
}

// Parse an int as a pair (digit, list of digits), and transform to int
// Possible, but not the right way to do it.

class ToInt : Transform<Pair<char, LinkedList<char> >, int> {
  public ToInt(Parser<Pair<char, LinkedList<char> > > p) : base(p) { }

  public override int Trans(Pair<char, LinkedList<char> > p) {
    int res = p.Fst - '0';
    IEnumerator<char> rest = p.Snd.GetEnumerator();
    while (rest.MoveNext()) 
      res = 10 * res + rest.Current - '0';
    return res;
  }
}

// ----------------------------------------------------------------------

public class TestParser {
  static void Main(string[] args) {
    TestTree("(Tree (Tree (Atom foo) (Int 1)) (Leaf foo))");
  }

  static void IntParse(string[] args) {
    // Seq(Digit, Star(Digit)) --> int
    Parser<int> intparser = 
      new ToInt(new Seq<char, LinkedList<char> >
		(new Digit(), new Star<char>(new Digit())));
    ISource src1 = new StringSource(args[0]);
    Console.WriteLine(2 * intparser.Parse(src1).Value);
    Console.WriteLine(2 * new ParseInt().Parse(src1).Value);
    
    Parser<LinkedList<int> > commaintparser = 
      new Star<int>(new SeqSnd<char,int>(new Comma(), intparser));
    ISource src2 = new StringSource(args[1]);
    LinkedList<int> ints = commaintparser.Parse(src2).Value;
    int sum = 0;
    foreach (int i in ints)
      sum += i;
    Console.WriteLine(sum);
  }

  // Parsing Lisp trees:    tree ::= atom | number | ( tree * )

  static void TestTree(string s) {
    ISource src = new StringSource(s);
    Parser<Tree> tparse = new ParseRec<Tree>(new TreeProtoParser());
    Result<Tree> res = tparse.Parse(src);
    if (res.Success) 
      Console.WriteLine(res.Value);
    else
      Console.WriteLine("Parse failure");
  }
}

// Tree protoparser; we use ParseRec to make it recursive (in fact, to
// find its fixed-point)

class TreeProtoParser : IProtoParser<Tree> {
  public Parser<Tree> Build(Parser<Tree> tparse) {
    Parser<Tree> parseList = 
      new SeqSnd<char,Tree>(
	  new ParseChar('('), 
	      new SeqFst<Tree,char>(new ParseList(tparse),
				    new SkipWS<char>(new ParseChar(')'))));
    return 
      new SkipWS<Tree>(
	new Alt<Tree>(
	  new Parser<Tree>[] { new ParseNumber(), 
			       new ParseAtom(), 
			       parseList }));
  }
}

// Parsing the three kinds of trees

class ParseNumber : Transform<int, Tree> { 
  public ParseNumber() : base(new ParseInt()) { }
  
  public override Tree Trans(int i) {
    return new Number(i);
  }
}

class ParseAtom : Transform<string, Tree> { 
  public ParseAtom() : base(new ParseSymbol()) { }
  
  public override Tree Trans(string s) {
    return new Atom(s);
  }

  private class ParseSymbol : ParseChars1 { 
    public override bool Ok(char c) {
      return System.Char.IsLetterOrDigit(c);
    }
  }
}

class ParseList : Transform<LinkedList<Tree>, Tree> { 
  public ParseList(Parser<Tree> tparser) : base(new Star<Tree>(tparser)) { }
  
  public override Tree Trans(LinkedList<Tree> trees) {
    return new List(trees);
  }
}

// Representing trees

abstract class Tree { }

class Number : Tree {
  private readonly int v;

  public Number(int v) {
    this.v = v;
  }

  public override string ToString() {
    return v.ToString();
  }
}

class Atom : Tree { 
  private string atom;
  
  public Atom(string atom) {
    this.atom = atom;
  }

  public override string ToString() {
    return atom;
  }
}

class List : Tree {
  protected readonly LinkedList<Tree> elems;

  public List(LinkedList<Tree> elems) {
    this.elems = elems;
  }

  public override string ToString() {
    StringBuilder sb = new StringBuilder();
    sb.Append("(");
    bool first = true;
    foreach (Tree t in elems) {
      if (!first)
	sb.Append(" ");
      first = false;
      sb.Append(t);
    }
    sb.Append(")");
    return sb.ToString();
  }
}
`
(Tree (Tree (Atom foo) (Int 1)) (Leaf foo))
`
`/p:v2
// Using phantom types in GC#
// This program requires .Net version 2.0
// Peter Sestoft (sestoft@dina.kvl.dk) * 2001-10-26 v 0.2

// A typed (int, bool) embedding of object expressions as in
// Leijen and Meijer 1999 section 5.1.

// The phantom types parameters are actually used in the types of
// methods in the objects representing the expressions; not phantom.

// Representing object language *variables* in a typed manner seems
// much harder, unless variables of different types are distinguished,
// and we have distinct environments for every type of variable when
// evaluating the expression.

using System;

abstract class E<R> {		// R = result type
  abstract public R eval(); 
}

class Lit<R> : E<R> {
  private readonly R v;

  public Lit(R v) {
    this.v = v;
  }

  public override R eval() {
    return v;
  }
}

abstract class Bin<S,R> : E<R> { // S = subexpr type; R = result type
  protected readonly E<S> e1, e2;

  public Bin(E<S> e1, E<S> e2) {
    this.e1 = e1; this.e2 = e2;
  }
}

class Add : Bin<int,int> {
  public Add(E<int> e1, E<int> e2) : base(e1, e2) { }

  public override int eval() {
    return e1.eval() + e2.eval();
  }
}

class Eq<S> : Bin<S,bool> {	// S = subexpr type
  public Eq(E<S> e1, E<S> e2) : base(e1, e2) { }

  public override bool eval() {
    return e1.eval().Equals(e2.eval());
  }
}

class And : Bin<bool,bool> {
  public And(E<bool> e1, E<bool> e2) : base(e1, e2) { } 

  public override bool eval() {
    return e1.eval() && e2.eval();
  }
}

// Exercising the encoding

class Phantom {
  // Build the expression n + ... + 1 + 0
  static E<int> sum(int n) {
    if (n == 0)
      return new Lit<int>(0);
    else 
      return new Add(new Lit<int>(n), sum(n-1));
  }

  static void Main() {
    E<int> e1 = sum(40);
    E<bool> e1Eq55 = new Eq<int>(new Lit<int>(55), e1);
    E<bool> e1Ne55 = new Eq<bool>(new Lit<bool>(false), e1Eq55);
    Console.WriteLine(e1.eval() + " " + e1Eq55.eval() + " " + e1Ne55.eval());
    E<string> e2 = new Lit<string>("foo");  // typesafe, no confusion possible
    e2 = e2;
  }
}
`
820 False True
`
`/p:v2
// Ring, Complex, Polynomial
// This program requires .NET version 2.0
// Peter Sestoft (sestoft@dina.kvl.dk) * 2001-12-12

// Using an abstract class as constraint, recursive constraints
// involving the class itself, a class as a constraint on a struct,
// etc.

// Alas, operators are static, and therefore cannot be specified in
// interfaces or abstract classes.

using System;

interface Ring<E> 
  where E : Ring<E>
 {
  E Zero();	// Lack of constructor or static specification
  E Plus(E e);
  E Times(E e);
  E Negate();
  E Minus(E e);
}

// A Ring adapter that saves us from defining Minus in subclasses

abstract class RingC<E> : Ring<E> 
  where E : Ring<E> 
  {
  public abstract E Zero();
  public abstract E Plus(E e);
  public abstract E Times(E e);
  public abstract E Negate();
  public E Minus(E e) {
    return this.Plus(e.Negate());
  }
}

// The complex numbers

struct Complex : Ring<Complex> { 
  private double re, im;

  public Complex(double re, double im) {
    System.Console.WriteLine("re =" + re + "im =" + im); 
    this.re = re; this.im = im;
  }

  public Complex Zero() {
    return new Complex(0.0, 0.0);
  }

  public Complex Plus(Complex that) {
    return new Complex(re + that.re, im + that.im);
  }

  public Complex Negate() {
    return new Complex(-re, -im);
  }

  public Complex Minus(Complex that) {
    return new Complex(re - that.re, im - that.im);
  }

  public Complex Conjugate() {
    return new Complex(re, -im);
  }

  public Complex Times(Complex that) {
    return new Complex(re * that.re - im * that.im, 
		       im * that.re + re * that.im); 
  }

  public static Complex operator +(Complex z1, Complex z2) {
    return z1.Plus(z2);
  }

  public static Complex operator *(Complex z1, Complex z2) {
    return z1.Times(z2);
  }

  public static Complex operator *(Complex z, double r) {
    return new Complex(z.re * r, z.im * r);
  }

  public static Complex operator *(double r, Complex z) {
    return new Complex(z.re * r, z.im * r);
  }

  public static Complex operator -(Complex z1) {
    return z1.Negate();
  }

  public static Complex operator ~(Complex z1) {
    return z1.Conjugate();
  }
}

// The ring of polynomials

class Polynomial<E> : RingC< Polynomial<E>> 
  where E : Ring<E> { 
  // Coefficients of x^0, x^1, ...; absent coefficients are zero.
  // Invariant: cs != null && cs.Length >= 1, so cs[0].Zero() is a zero for E.
  private readonly E[] cs;  
  
  public Polynomial(E[] cs) {	
    this.cs = cs;
  }

  public Polynomial(E s) : this(new E[] { s }) { }	// Constant s

  public override Polynomial<E> Zero() {
    return new Polynomial<E>(cs[0].Zero());
  }

  public override Polynomial<E> Plus(Polynomial<E> that) {
    int newlen = Math.Max(this.cs.Length, that.cs.Length);
    int minlen = Math.Min(this.cs.Length, that.cs.Length);
    E[] newcs = new E[newlen];
    if (this.cs.Length <= that.cs.Length) {
      for (int i=0; i<minlen; i++)
	newcs[i] = this.cs[i].Plus(that.cs[i]);
      for (int i=minlen; i<newlen; i++)
	newcs[i] = that.cs[i];
    } else {
      for (int i=0; i<minlen; i++)
	newcs[i] = this.cs[i].Plus(that.cs[i]);
      for (int i=minlen; i<newlen; i++)
	newcs[i] = this.cs[i];
    }
    Microsoft.Contracts.NonNullType.AssertInitialized<E>(newcs);
    return new Polynomial<E>(newcs);
  }

  public override Polynomial<E> Times(Polynomial<E> that) {
    int newlen = Math.Max(1, this.cs.Length + that.cs.Length - 1);
    E[] newcs = new E[newlen];
    E zero = cs[0].Zero();
    for (int i=0; i<newlen; i++) {
      E sum = zero.Zero();
      int start = Math.Max(0, i-that.cs.Length+1);
      int stop  = Math.Min(i, this.cs.Length-1);
      for (int j=start; j<=stop; j++) {
	// assert 0<=j && j<this.cs.Length && 0<=i-j && i-j<that.cs.Length;
	sum = sum.Plus(this.cs[j].Times(that.cs[i-j]));
      }
      newcs[i] = sum;
    }
    Microsoft.Contracts.NonNullType.AssertInitialized<E>(newcs);
    return new Polynomial<E>(newcs);
  }

  public override Polynomial<E> Negate() {
    int newlen = cs.Length;
    E[] newcs = new E[newlen];
    for (int i=0; i<newlen; i++)
      newcs[i] = cs[i].Negate();
    Microsoft.Contracts.NonNullType.AssertInitialized<E>(newcs);  
    return new Polynomial<E>(newcs);
  }

  public static Polynomial<E> operator + (Polynomial<E> p1, 
					  Polynomial<E> p2) {
    return p1.Plus(p2);
  }

  public static Polynomial<E> operator + (Polynomial<E> p1, E s) {
    return p1 + new Polynomial<E>(s);
  }

  public static Polynomial<E> operator * (Polynomial<E> p1, 
					  Polynomial<E> p2) {
    return p1.Times(p2);
  }

  public static Polynomial<E> operator * (Polynomial<E> p1, E s) {
    return p1.Times(new Polynomial<E>(s));
  }

  public static Polynomial<E> operator * (E s, Polynomial<E> p1) {
    return new Polynomial<E>(s).Times(p1);
  }

  public static Polynomial<E> operator - (Polynomial<E> p1) {
    return p1.Negate();
  }

  public E Evaluate(E x) {
    E res = x.Zero();
    for (int i=cs.Length-1; i>=0; i--)
      res = res.Times(x).Plus(cs[i]);
    return res;
  }

  public E this[E e] {
    get { return Evaluate(e); }
  }
}

// Trying it

class TestRing { 
  static void Main(string[] args) {
    Complex one = new Complex(1.0, 0.0);
    Complex i = new Complex(0.0, 1.0);
    Polynomial<Complex> p1 = 
      new Polynomial<Complex>(new Complex[] { one, i * 2.0, i });
    Polynomial<Complex> p2, p3;
    p2 = p1 * new Complex(7.0, 0.0) + p1 * p1;
    p3 = new Polynomial<Complex>(new Complex(0, 0));
    p3 += p2;
    p3 += new Complex(6.0, 0.0) * p2;
  }
}
`
re =1im =0
re =0im =1
re =0im =2
re =7im =0
re =0im =0
re =0im =0
re =7im =0
re =7im =0
re =0im =0
re =0im =14
re =0im =14
re =0im =0
re =0im =7
re =0im =7
re =0im =0
re =0im =0
re =1im =0
re =1im =0
re =0im =0
re =0im =2
re =0im =2
re =0im =2
re =0im =4
re =0im =0
re =0im =1
re =0im =1
re =-4im =0
re =-4im =1
re =0im =1
re =-4im =2
re =0im =0
re =-2im =0
re =-2im =0
re =-2im =0
re =-4im =0
re =0im =0
re =-1im =0
re =-1im =0
re =8im =0
re =0im =18
re =-4im =9
re =0im =0
re =8im =0
re =6im =0
re =0im =0
re =0im =0
re =48im =0
re =48im =0
re =0im =0
re =0im =108
re =0im =108
re =0im =0
re =-24im =54
re =-24im =54
re =0im =0
re =-24im =0
re =-24im =0
re =0im =0
re =-6im =0
re =-6im =0
re =56im =0
re =0im =126
re =-28im =63
re =-28im =0
re =-7im =0
`
`/p:v2 /r:System.dll
// RegExp -> NFA -> DFA -> Graph in Generic C#
// This program requires .Net version 2.0.
// Peter Sestoft (sestoft@dina.kvl.dk) 
// Java 2000-10-07, GC# 2001-10-23, 2003-09-03, 2004-07-26

// This file contains, in order:
//   * A class Nfa for representing an NFA (a nondeterministic finite 
//     automaton), and for converting it to a DFA (a deterministic 
//     finite automaton).  Most complexity is in this class.
//   * A class Dfa for representing a DFA, a deterministic finite 
//     automaton, and for writing a dot input file representing the DFA.
//   * Classes for representing regular expressions, and for building an 
//     NFA from a regular expression
//   * A test class that creates an NFA, a DFA, and a dot input file 
//     for a number of small regular expressions.  The DFAs are 
//     not minimized.

using System;
using System.Text;
using System.Collections.Generic;
using System.Collections;
using System.IO;
using Microsoft.Contracts;

// A set represented as the collection of keys of a Dictionary

class Set<T> : ICollection<T> {
  // Only the keys matter; the type bool used for the value is arbitrary
  private Dictionary<T,bool> dict;
  public Set() { 
    dict = new Dictionary<T,bool>();
  }

  [NotDelayed]
  public Set(T x) : this() { 
    Add(x);
  }

  [NotDelayed]
  public Set(IEnumerable<T> coll) : this() {
    foreach (T x in coll) 
      Add(x);
  }

  [NotDelayed]
  public Set(T[] arr) : this() {
    foreach (T x in arr) 
      Add(x);
  }

  public bool Contains(T x) {
    return dict.ContainsKey(x);
  }

  public void Add(T x) {
    if (!Contains(x))
      dict.Add(x, false);
  }

  public bool Remove(T x) {
    return dict.Remove(x);
  }

  public void Clear() {
    dict.Clear();
  }

  public bool IsReadOnly {
    get { return false; } 
  }


  IEnumerator IEnumerable.GetEnumerator() {
   return dict.Keys.GetEnumerator();

  } 

  IEnumerator<T> IEnumerable<T>.GetEnumerator() {
   return dict.Keys.GetEnumerator();
  }

  public int Count {
    get { return dict.Count; }
  }
  
  public void CopyTo(T[] arr, int i) {
    dict.Keys.CopyTo(arr, i);
  }

  // Is this set a subset of that?
  public bool Subset(Set<T> that) { 
    foreach (T x in this)
      if (!that.Contains(x))
        return false;
    return true;            
  }

  // Create new set as intersection of this and that
  public Set<T> Intersection(Set<T> that) { 
    Set<T> res = new Set<T>();
    foreach (T x in this)
      if (that.Contains(x))
        res.Add(x);
    return res;
  }

  // Create new set as union of this and that
  public Set<T> Union(Set<T> that) { 
    Set<T> res = new Set<T>(this);
    foreach (T x in that)
      res.Add(x);
    return res;
  }

  // Compute hash code -- should be cached for efficiency
  public override int GetHashCode() { 
    int res = 0;
    foreach (T x in this)
      res ^= x.GetHashCode();
    return res;
  }

  public override bool Equals(Object that) { 
    if (that is Set<T>) {
      Set<T> thatSet = (Set<T>)that;
      return thatSet.Count == this.Count 
        && thatSet.Subset(this) && this.Subset(thatSet);
    } else
      return false;
  }

  public override String ToString() {
    StringBuilder res = new StringBuilder();
    res.Append("{ ");
    bool first = true;
    foreach (T x in this) {
      if (!first) 
        res.Append(", ");
      res.Append(x);
      first = false;
    }
    res.Append(" }");
    return res.ToString();
  }
}

// ----------------------------------------------------------------------

// Regular expressions, NFAs, DFAs, and dot graphs
// sestoft@dina.kvl.dk * 
// Java 2001-07-10 * C# 2001-10-22 * Gen C# 2001-10-23, 2003-09-03

// In the Generic C# 2.0 version we 
//  use Queue<int> and Queue<Set<int>> for worklists
//  use Set<int> for pre-DFA states
//  use List<Transition> for NFA transition relations
//  use Dictionary<Set<int>, Dictionary<String, Set<int>>>
//  and Dictionary<int, Dictionary<String, int>> for DFA transition relations

/* Class Nfa and conversion from NFA to DFA ---------------------------

  A nondeterministic finite automaton (NFA) is represented as a
  Map from state number (int) to a List of Transitions, a
  Transition being a pair of a label lab (a String, null meaning
  epsilon) and a target state (an int).

  A DFA is created from an NFA in two steps:

    (1) Construct a DFA whose each of whose states is composite,
        namely a set of NFA states (Set of int).  This is done by
        methods CompositeDfaTrans and EpsilonClose.

    (2) Replace composite states (Set of int) by simple states
        (int).  This is done by methods Rename and MkRenamer.

  Method CompositeDfaTrans works as follows: 

    Create the epsilon-closure S0 (a Set of ints) of the start
    state s0, and put it in a worklist (a Queue).  Create an
    empty DFA transition relation, which is a Map from a
    composite state (an epsilon-closed Set of ints) to a Map
    from a label (a non-null String) to a composite state.

    Repeatedly choose a composite state S from the worklist.  If it is
    not already in the keyset of the DFA transition relation, compute
    for every non-epsilon label lab the set T of states reachable by
    that label from some state s in S.  Compute the epsilon-closure
    Tclose of every such state T and put it on the worklist.  Then add
    the transition S -lab-> Tclose to the DFA transition relation, for
    every lab.

  Method EpsilonClose works as follows: 

    Given a set S of states.  Put the states of S in a worklist.
    Repeatedly choose a state s from the worklist, and consider all
    epsilon-transitions s -eps-> s' from s.  If s' is in S already,
    then do nothing; otherwise add s' to S and the worklist.  When the
    worklist is empty, S is epsilon-closed; return S.

  Method MkRenamer works as follows: 

    Given a Map from Set of int to something, create an
    injective Map from Set of int to int, by choosing a fresh
    int for every value of the map.

  Method Rename works as follows:

    Given a Map from Set of int to Map from String to Set of
    int, use the result of MkRenamer to replace all Sets of ints
    by ints.

*/


class Nfa {
  private readonly int startState;
  private readonly int exitState;    // This is the unique accept state
  private readonly IDictionary<int,List<Transition>> trans;

  public Nfa(int startState, int exitState) {
    this.startState = startState; this.exitState = exitState;
    IDictionary<int,List<Transition>> dict = trans = new Dictionary<int,List<Transition>>();
    if (!startState.Equals(exitState))
      dict.Add(exitState, new List<Transition>());
  }

  public int Start { get { return startState; } }

  public int Exit { get { return exitState; } }

  public IDictionary<int, List<Transition>> Trans { 
    get { return trans; }
  }

  public void AddTrans(int s1, String lab, int s2) {
    List<Transition> s1Trans;
    if (trans.ContainsKey(s1)) 
      s1Trans = trans[s1];
    else {
      s1Trans = new List<Transition>();
      trans.Add(s1, s1Trans);
    }
    s1Trans.Add(new Transition(lab, s2));
  }

  public void AddTrans(KeyValuePair<int, List<Transition>> tr) {
    // Assumption: if tr is in trans, it maps to an empty list (end state)
    trans.Remove(tr.Key);
    trans.Add(tr.Key, tr.Value);
  }

  public override String ToString() {
    return "NFA start=" + startState + " exit=" + exitState;
  }

  // Construct the transition relation of a composite-state DFA
  // from an NFA with start state s0 and transition relation
  // trans (a Map from int to List of Transition).  The start
  // state of the constructed DFA is the epsilon closure of s0,
  // and its transition relation is a Map from a composite state
  // (a Set of ints) to a Map from label (a String) to a
  // composite state (a Set of ints).

  static IDictionary<Set<int>, IDictionary<String, Set<int>>>
    CompositeDfaTrans(int s0, IDictionary<int, List<Transition>> trans) {
    Set<int> S0 = EpsilonClose(new Set<int>(s0), trans);
    Queue<Set<int>> worklist = new Queue<Set<int>>();
    worklist.Enqueue(S0);
    // The transition relation of the DFA
    IDictionary<Set<int>, IDictionary<String, Set<int>>> res = 
      new Dictionary<Set<int>, IDictionary<String, Set<int>>>(); 
    while (worklist.Count != 0) {
      Set<int> S = worklist.Dequeue();
      if (!res.ContainsKey(S)) {
        // The S -lab-> T transition relation being constructed for a given S
        IDictionary<String, Set<int>> STrans = 
	  new Dictionary<String, Set<int>>(); 
        // For all s in S, consider all transitions s -lab-> t
	foreach (int s in S) {
          // For all non-epsilon transitions s -lab-> t, add t to T
	  foreach (Transition tr in trans[s]) {
            if (tr.lab != null) {       // Already a transition on lab
              Set<int> toState; 
              if (STrans.ContainsKey(tr.lab)) 
                toState = STrans[tr.lab];
              else {                    // No transitions on lab yet
                toState = new Set<int>();
                STrans.Add(tr.lab, toState);
              }
              toState.Add(tr.target);
            }
          }
        }
        // Epsilon-close all T such that S -lab-> T, and put on worklist
        Dictionary<String, Set<int>> STransClosed = 
          new Dictionary<String, Set<int> >();
	foreach (KeyValuePair<String, Set<int>> entry in STrans) {
          Set<int> Tclose = EpsilonClose(entry.Value, trans);
          STransClosed.Add(entry.Key, Tclose);
          worklist.Enqueue(Tclose);
        }
        res.Add(S, STransClosed);
      }
    }
    return res;
  }  

  // Compute epsilon-closure of state set S in transition relation trans.  

  static Set<int> 
    EpsilonClose(Set<int> S, IDictionary<int, List<Transition>> trans) {
    // The worklist initially contains all S members
    Queue<int> worklist = new Queue<int>(S);
    Set<int> res = new Set<int>(S);
    while (worklist.Count != 0) {
      int s = worklist.Dequeue();
      foreach (Transition tr in trans[s]) {
        if (tr.lab == null && !res.Contains(tr.target)) {
          res.Add(tr.target);
          worklist.Enqueue(tr.target);
        }
      }
    }
    return res;
  }

  // Compute a renamer, which is a Map from Set of int to int

  static IDictionary<Set<int>, int> MkRenamer(ICollection<Set<int>> states) {
    IDictionary<Set<int>, int> renamer = new Dictionary<Set<int>, int>();
    int count = 0;
    foreach (Set<int> k in states) 
      renamer.Add(k, count++);
    return renamer;
  }

  // Using a renamer (a Map from Set of int to int), replace
  // composite (Set of int) states with simple (int) states in
  // the transition relation trans, which is assumed to be a Map
  // from Set of int to Map from String to Set of int.  The
  // result is a Map from int to Map from String to int.

  static IDictionary<int, IDictionary<String, int>>
    Rename(IDictionary<Set<int>, int> renamer, 
           IDictionary<Set<int>, IDictionary<String, Set<int>>> trans) {
    IDictionary<int, IDictionary<String, int>> newtrans = 
      new Dictionary<int, IDictionary<String, int>>();
    foreach (KeyValuePair<Set<int>, IDictionary<String, Set<int>>> entry 
	     in trans) {
      Set<int> k = entry.Key;
      IDictionary<String, int> newktrans = new Dictionary<String, int>();
      foreach (KeyValuePair<String, Set<int>> tr in entry.Value) 
        newktrans.Add(tr.Key, renamer[tr.Value]);
      newtrans.Add(renamer[k], newktrans);
    }
    return newtrans;
  }

  static Set<int> AcceptStates(ICollection<Set<int>> states, 
			       IDictionary<Set<int>, int> renamer,
			       int exit) {
    Set<int> acceptStates = new Set<int>();
    foreach (Set<int> state in states) 
      if (state.Contains(exit)) 
        acceptStates.Add(renamer[state]);
    return acceptStates;
  }

  public Dfa ToDfa() {
    IDictionary<Set<int>, IDictionary<String, Set<int>>> 
      cDfaTrans = CompositeDfaTrans(startState, trans);
    Set<int> cDfaStart = EpsilonClose(new Set<int>(startState), trans);
    ICollection<Set<int>> cDfaStates = cDfaTrans.Keys;
    IDictionary<Set<int>, int> renamer = MkRenamer(cDfaStates);
    IDictionary<int, IDictionary<String, int>> simpleDfaTrans = 
      Rename(renamer, cDfaTrans);
    int simpleDfaStart = renamer[cDfaStart];
    Set<int> simpleDfaAccept = AcceptStates(cDfaStates, renamer, exitState);
    return new Dfa(simpleDfaStart, simpleDfaAccept, simpleDfaTrans);
  }

  // Nested class for creating distinctly named states when constructing NFAs

  public class NameSource {
    private static int nextName = 0;

    public int next() { 
      return nextName++; 
    }
  }
}

// Class Transition, a transition from one state to another ----------

  public class Transition {
    public String lab;
    public int target;
    
    public Transition(String lab, int target) { 
      this.lab = lab; this.target = target; 
    }
    
    public override String ToString() {
      return "-" + lab + "-> " + target;
    }
  }

// Class Dfa, deterministic finite automata --------------------------

/*
  A deterministic finite automaton (DFA) is represented as a Map
  from state number (int) to a Map from label (a String,
  non-null) to a target state (an int).  
*/

class Dfa {
  private readonly int startState;
  private readonly Set<int> acceptStates;
  private readonly IDictionary<int, IDictionary<String,int>> trans;

  public Dfa(int startState, Set<int> acceptStates, 
	     IDictionary<int, IDictionary<String,int>> trans) {
    this.startState = startState; 
    this.acceptStates = acceptStates;
    this.trans = trans;
  }
  
  public int Start { get { return startState; } }

  public Set<int> Accept { get { return acceptStates; } }

  public IDictionary<int, IDictionary<String,int>> Trans { 
    get { return trans; }
  }

  public override String ToString() {
    return "DFA start=" + startState + "\r\naccept=" + acceptStates;
  }

  // Write an input file for the dot program.  You can find dot at
  // http://www.research.att.com/sw/tools/graphviz/

  public void WriteDot(String filename) {
    TextWriter wr = 
      new StreamWriter(new FileStream(filename, FileMode.Create, 
                                      FileAccess.Write));
    wr.WriteLine("// Format this file as a Postscript file with ");
    wr.WriteLine("//    dot " + filename + " -Tps -o out.ps\n");
    wr.WriteLine("digraph dfa {");
    wr.WriteLine("size=\"11,8.25\";");
    wr.WriteLine("rotate=90;");
    wr.WriteLine("rankdir=LR;");
    wr.WriteLine("n999999 [style=invis];");    // Invisible start node
    wr.WriteLine("n999999 -> n" + startState); // Edge into start state
    
    // Accept states are double circles
    foreach (int state in trans.Keys) 
      if (acceptStates.Contains(state))
        wr.WriteLine("n" + state + " [peripheries=2];");

    // The transitions 
    foreach (KeyValuePair<int, IDictionary<String, int>> entry in trans) {
      int s1 = entry.Key;
      foreach (KeyValuePair<String, int> s1Trans in entry.Value) {
        String lab = s1Trans.Key;
        int s2 = s1Trans.Value;
        wr.WriteLine("n" + s1 + " -> n" + s2 + " [label=\"" + lab + "\"];");
      }
    }
    wr.WriteLine("}");
    wr.Close();
  }
}

// Regular expressions ----------------------------------------------
//
// Abstract syntax of regular expressions
//    r ::= A | r1 r2 | (r1|r2) | r*
//

abstract class Regex { 
  abstract public Nfa MkNfa(Nfa.NameSource names);
}

class Eps : Regex {
  // The resulting nfa0 has form s0s -eps-> s0e

  public override Nfa MkNfa(Nfa.NameSource names) {
    int s0s = names.next();
    int s0e = names.next();
    Nfa nfa0 = new Nfa(s0s, s0e);
    nfa0.AddTrans(s0s, null, s0e);
    return nfa0;
  }
}

class Sym : Regex {
  String sym;

  public Sym(String sym) { 
    this.sym = sym; 
  }

  // The resulting nfa0 has form s0s -sym-> s0e

  public override Nfa MkNfa(Nfa.NameSource names) {
    int s0s = names.next();
    int s0e = names.next();
    Nfa nfa0 = new Nfa(s0s, s0e);
    nfa0.AddTrans(s0s, sym, s0e);
    return nfa0;
  }
}

class Seq : Regex {
  Regex r1, r2;

  public Seq(Regex r1, Regex r2) {
    this.r1 = r1; this.r2 = r2;
  }

  // If   nfa1 has form s1s ----> s1e 
  // and  nfa2 has form s2s ----> s2e 
  // then nfa0 has form s1s ----> s1e -eps-> s2s ----> s2e

  public override Nfa MkNfa(Nfa.NameSource names) {
    Nfa nfa1 = r1.MkNfa(names);
    Nfa nfa2 = r2.MkNfa(names);
    Nfa nfa0 = new Nfa(nfa1.Start, nfa2.Exit);
    foreach (KeyValuePair<int, List<Transition>> entry in nfa1.Trans) 
      nfa0.AddTrans(entry);
    foreach (KeyValuePair<int, List<Transition>> entry in nfa2.Trans) 
      nfa0.AddTrans(entry);
    nfa0.AddTrans(nfa1.Exit, null, nfa2.Start);
    return nfa0;
  }
}

class Alt : Regex {
  Regex r1, r2;

  public Alt(Regex r1, Regex r2) {
    this.r1 = r1; this.r2 = r2;
  }

  // If   nfa1 has form s1s ----> s1e 
  // and  nfa2 has form s2s ----> s2e 
  // then nfa0 has form s0s -eps-> s1s ----> s1e -eps-> s0e
  //                    s0s -eps-> s2s ----> s2e -eps-> s0e

  public override Nfa MkNfa(Nfa.NameSource names) {
    Nfa nfa1 = r1.MkNfa(names);
    Nfa nfa2 = r2.MkNfa(names);
    int s0s = names.next();
    int s0e = names.next();
    Nfa nfa0 = new Nfa(s0s, s0e);
    foreach (KeyValuePair<int, List<Transition>> entry in nfa1.Trans) 
      nfa0.AddTrans(entry);
    foreach (KeyValuePair<int, List<Transition>> entry in nfa2.Trans) 
      nfa0.AddTrans(entry);
    nfa0.AddTrans(s0s, null, nfa1.Start);
    nfa0.AddTrans(s0s, null, nfa2.Start);
    nfa0.AddTrans(nfa1.Exit, null, s0e);
    nfa0.AddTrans(nfa2.Exit, null, s0e);
    return nfa0;
  }
}

class Star : Regex {
  Regex r;

  public Star(Regex r) {
    this.r = r; 
  }

  // If   nfa1 has form s1s ----> s1e 
  // then nfa0 has form s0s ----> s0s
  //                    s0s -eps-> s1s
  //                    s1e -eps-> s0s

  public override Nfa MkNfa(Nfa.NameSource names) {
    Nfa nfa1 = r.MkNfa(names);
    int s0s = names.next();
    Nfa nfa0 = new Nfa(s0s, s0s);
    foreach (KeyValuePair<int, List<Transition>> entry in nfa1.Trans) 
      nfa0.AddTrans(entry);
    nfa0.AddTrans(s0s, null, nfa1.Start);
    nfa0.AddTrans(nfa1.Exit, null, s0s);
    return nfa0;
  }
}

// Trying the RE->NFA->DFA translation on three regular expressions

class TestNFA {
  public static void Main(String[] args) {
    Regex a = new Sym("A");
    Regex b = new Sym("B");
    Regex c = new Sym("C");
    Regex abStar = new Star(new Alt(a, b));
    Regex bb = new Seq(b, b);
    Regex r = new Seq(abStar, new Seq(a, b));
    // The regular expression (a|b)*ab
    BuildAndShow("dfa1.dot", r);
    // The regular expression ((a|b)*ab)*
    BuildAndShow("dfa2.dot", new Star(r));
    // The regular expression ((a|b)*ab)((a|b)*ab)
    BuildAndShow("dfa3.dot", new Seq(r, r));
    // The regular expression (a|b)*abb, from ASU 1986 p 136
    BuildAndShow("dfa4.dot", new Seq(abStar, new Seq(a, bb)));
    // SML reals: sign?((digit+(\.digit+)?))([eE]sign?digit+)?
    Regex d = new Sym("digit");
    Regex dPlus = new Seq(d, new Star(d));
    Regex s = new Sym("sign");
    Regex sOpt = new Alt(s, new Eps());
    Regex dot = new Sym(".");
    Regex dotDigOpt = new Alt(new Eps(), new Seq(dot, dPlus));
    Regex mant = new Seq(sOpt, new Seq(dPlus, dotDigOpt));
    Regex e = new Sym("e");
    Regex exp = new Alt(new Eps(), new Seq(e, new Seq(sOpt, dPlus)));
    Regex smlReal = new Seq(mant, exp);
    BuildAndShow("dfa5.dot", smlReal);
    Console.WriteLine("done");
  }

  public static void BuildAndShow(String filename, Regex r) {
    Nfa nfa = r.MkNfa(new Nfa.NameSource());
    Console.WriteLine(nfa);
    Console.WriteLine("---");
    Dfa dfa = nfa.ToDfa();
    Console.WriteLine(dfa);
/* crusso: disabled
    Console.WriteLine("Writing DFA graph to file " + filename);
    dfa.WriteDot(filename);
*/
    Console.WriteLine();

  }
}
`
(599,11): warning CS0219: The variable 'c' is assigned but its value is never used
NFA start=6 exit=10
---
DFA start=0
accept={ 3 }

NFA start=22 exit=22
---
DFA start=0
accept={ 0, 3 }

NFA start=29 exit=44
---
DFA start=0
accept={ 6 }

NFA start=51 exit=57
---
DFA start=0
accept={ 4 }

NFA start=62 exit=96
---
DFA start=0
accept={ 2, 3, 6, 8, 9, 10 }

done
`
using System;
using System.Collections.Generic;

public class C {
  private static int BinarySearch<T>(KeyValuePair<int, T>[] array, int line) {
    return Array.BinarySearch(array, new KeyValuePair<int, T>(line, default(T)), new KeyComparer<T>()); // error
  }
  public static void Main(){}
}

class KeyComparer<T1> : IComparer<KeyValuePair<int, T1>> {
  public int Compare(KeyValuePair<int, T1> x, KeyValuePair<int, T1> y) {
    return x.Key - y.Key;
  }
}
`
`