``/d:NONONNULLTYPECHECK
public class C
{
    public const double xx = (double)-1.0 / (double)(0.0);

    public static int Main()
    {
        if (xx != double.NegativeInfinity)
        {
            return 1;
        }

        return 0;
    }
}
`
`
using System;
using System.Collections;
using System.Collections.Generic;

public class Test
{


	public IEnumerator<T> Iter<T,U>(T t, U u) 
	{ 
		countT++;
		yield return t; 
		countT++;
		yield return (T)(object)u; 
	}

	static int countT = 0;

	static void Verify<T>(IEnumerator<T> e)
	{
	  if (e == null) return;
		while (e.MoveNext())
		{
			countT++;
		}
	}

	public static int Main()
	{
		Test t = new Test();
		Verify(t.Iter(10,10));
		Console.WriteLine(Test.countT);
		return 0;

	}
}
`
4
`
using System;

class Program
{
    public static void Main()
    {
        UInt16Be x = 42;
        
        ushort y = (ushort)(x << 5);
        
        Console.WriteLine("y = " + y);        
    }
}



public struct UInt16Be
{
    // This contains the value in the swapped (LE or BE) format, not host format.
    private UInt16 m_value;

    // if big_Endian, no need to swap values
    public UInt16Be(UInt16 host_value) { m_value = host_value; }
    public static implicit operator UInt16Be(UInt16 host_value) { return new UInt16Be(host_value); }
    public static implicit operator UInt16(UInt16Be value) { return value.m_value; }

    public override string ToString() { return ((UInt16)this).ToString(); }
    public override int GetHashCode() { return ((UInt16)this).GetHashCode(); }
    public override bool Equals(object value) {
        if (value is UInt16) {
            UInt16 hval = (UInt16)value;
            return hval == ((UInt16)this);
        } else if (value is UInt16Be) {
            UInt16Be sval = (UInt16Be)value;
            return sval.m_value == this.m_value;
        } else {
            return false;
        }
    }
}
`
y = 1344
`
using System;

class Program
{
    public static void Main()
    {
        UInt16Be x = 42;
        
        ushort y = x << 5;
        
        Console.WriteLine("y = " + y);        
    }
}



public struct UInt16Be
{
    // This contains the value in the swapped (LE or BE) format, not host format.
    private UInt16 m_value;

    // if big_Endian, no need to swap values
    public UInt16Be(UInt16 host_value) { m_value = host_value; }
    public static implicit operator UInt16Be(UInt16 host_value) { return new UInt16Be(host_value); }
    public static implicit operator UInt16(UInt16Be value) { return value.m_value; }

    public override string ToString() { return ((UInt16)this).ToString(); }
    public override int GetHashCode() { return ((UInt16)this).GetHashCode(); }
    public override bool Equals(object value) {
        if (value is UInt16) {
            UInt16 hval = (UInt16)value;
            return hval == ((UInt16)this);
        } else if (value is UInt16Be) {
            UInt16Be sval = (UInt16Be)value;
            return sval.m_value == this.m_value;
        } else {
            return false;
        }
    }
}
`
(9,20): error CS0029: Cannot implicitly convert type 'int' to 'ushort'
`
`/unsafe
class Test {
    unsafe public void M(byte* /*in ExHeap*/ ptr) {

        byte x = ptr[0];

        byte* data = &ptr[0];
        CallUnsafePtr(data, x);
    }

    unsafe public void N(byte* /*in ExHeap*/ ptr) {

        byte x = ptr[0];

        byte* data = &ptr[0];
        CallUnsafePtr(data, x);
    }

    public static void Main() {}

    unsafe void CallUnsafePtr(byte* ptr, byte data) {}
}
`
`
`/unsafe
public struct A { 
 int x;
}

public struct B { public A a; }


public class Test {

  public static void Main() {}

  unsafe public static void m(B* b) {
    A* a = &b->a;
  }

  unsafe public static void m(B[] b) {

    B* bp = &b[4];

  }
}
`
(18,14): error CS0212: You can only take the address of unfixed expression inside of a fixed statement initializer
`
using System;
using System.Collections;
using System.Collections.Generic;

public delegate void D();

public class Test<T>
    where T : IComparable
{

    // static iter block
    public static IEnumerable<T> Iter2<V>()
    {
        T localT = default(T);

        D d = delegate
        {
            localT = default(T);
        };
        yield return localT;

    }
}
public class EntryPoint
{
    // entry point
    static int Main(string[] args)
    {
        return 0;
    }
}
`
`
using System.Collections.Generic;

  public static class IteratorHelper {

    public static IEnumerable<TargetType> GetFilterEnumerable<SourceType, TargetType>(IEnumerable<SourceType> sourceEnumeration)
      where SourceType : class
      where TargetType : class {
      foreach (SourceType s in sourceEnumeration) {
        TargetType/*?*/ t = s as TargetType;
        if (t != null)
          yield return t;
      }
    }
    
    public static void Main(){
      List<object> source = new List<object>(2);
      source.Add("bar");
      source.Add(1);
      foreach (object s in IteratorHelper.GetFilterEnumerable<object, string>(source)){
        System.Console.WriteLine(s);
      }
    }

  }
`
bar
`  
using System;

public delegate T GenDlg<T>(T t);

public class TestDriver{
	public static GenDlg<T> GenMeth<T>(T t){
		return delegate(T x){return t;};
	}
}
public class Test{
	public static int Main(){
	  return TestDriver.GenMeth(0)(1);
	}
}
`
`
using System;

//public delegate T GenDlg<T>(T t);

public class TestDriver{
	public static object GenMeth<T>(){
		return delegate(T x){return x;};
	}
}
public class Test{
	public static void Main(){
	}
}
`
(7,10): error CS1660: Cannot convert anonymous method block to type 'object' because it is not a delegate type
`
using System;

public struct Gen1<T>
{
    public Gen1<T> RecursiveFld;
}

public struct Gen2<T>
{
    public T recursiveFld;
}

public class Test
{
	public static int Main()
	{
        	return 1;	
	}
}
`
(5,20): error CS0523: Struct member 'Gen1<T>.RecursiveFld' of type 'Gen1<T>' causes a cycle in the struct layout
`
`/unsafe
public class Test
{
    public unsafe static int Main() 
    {
	      int result = 1;
        int[] arr = null;

	      int* ptrCopy= &result;
        try
        {
            	fixed (int* ptr = arr) // This syntax is allowed only in fixed.  If you declared ptr outside the try, then you'd have to do fixed(ptr=&arr[0])
		          {
			          ptrCopy = ptr;
		          }
        } 
        catch (System.NullReferenceException)
        {
              System.Console.WriteLine("Got exception!");
        }
	      catch
	      {
              System.Console.WriteLine("Got something weird!");
	      }
	      finally
	      {
		        if (ptrCopy == null)
			          result = 0;
		        else
		        {
			          System.Console.WriteLine("failed");
		        }
	      }

	      return result;

    }
}
`
`
using System;
using System.Collections.Generic;
using Microsoft.Singularity;

namespace Singularity.Fat {

    using DirectoryContract = DirectoryServiceContract;


    public class Test {
    
        public void M(DirectoryContract.Exp exp) {
        }

        public static void Main() {
            List<DirectoryContract.Exp> l = new List<DirectoryContract.Exp>();
            if (l != null) l = null;
        }
    }
}


namespace Microsoft.Singularity {
    public class DirectoryServiceContract {

        public struct Exp {
        }
    }
}
`
`
using System;
using System.Collections.Generic;

public class DirectoryServiceContract {

    public struct Exp {
    }
}


namespace Singularity.Fat {

    using DirectoryContract = DirectoryServiceContract;


    public class Test {
    
        public void M(DirectoryContract.Exp exp) {
        }

        public static void Main() {
            List<DirectoryContract.Exp> l = new List<DirectoryContract.Exp>();
            if (l != null) l = null;

        }
    }
}
`
`
namespace MyNS {
  class MyClass {

    public static int Main() {
      if ((MyClass1.intI == 1) && (TestNS.MyClass2.intI == 2)) {
        return 0;
      }
      else {
        return 1;
      }
    }
  }
}

namespace MyNS {
  class MyClass1 {public static int intI = 1;
  }

  namespace TestNS {
    class MyClass2 {
      public static int intI = 2;
    }
  }
}
`
`
namespace MyNS {
  namespace MyNS2 {
    class MyClass {
  
      public static int Main() {
        if ((MyClass1.intI == 1) && (TestNS.MyClass2.intI == 2)) {
          return 0;
        }
        else {
          return 1;
        }
      }
    }
  }
}

namespace MyNS.MyNS2 {
  class MyClass1 {
    public static int intI = 1;
  }

  namespace TestNS {
    class MyClass2 {
      public static int intI = 2;
    }
  }
}
`
`
namespace MyNS {

  class MyClass1 {
    public static int intI = 1;
  }

  namespace TestNS {
    class MyClass2 {
      public static int intI = 2;
    }
  }

  namespace MyNS2 {
    class MyClass {
  
      public static int Main() {
        if ((MyClass1.intI == 1) && (TestNS.MyClass2.intI == 2)) {
          return 0;
        }
        else {
          return 1;
        }
      }
    }
  }
}
`
`
namespace MyNS {
  namespace MyNS2 {
    class MyClass {
  
      public static int Main() {
        if ((MyClass1.intI == 1) && (TestNS.MyClass2.intI == 2)) {
          return 0;
        }
        else {
          return 1;
        }
      }
    }
  }
}

namespace MyNS {
  class MyClass1 {
    public static int intI = 1;
  }

  namespace TestNS {
    class MyClass2 {
      public static int intI = 2;
    }
  }
}
`
`
class MyClass {

  public static int intTest = 1;

  class TestClass {
    public void TestMeth() {
      int intI = intTest;
    }
  }
  public static void Main(){}
}
`
(7,11): warning CS0219: The variable 'intI' is assigned but its value is never used
`
class MyClass 
{

  public static int Main() 
  {
  {
  L1: int i = 0;
    goto L4;
  } 
  {
  L2: int i = 0;
    goto L1;
  }
  {
  L3: int i = 0;
    goto L2;
  }
  {
  L4: int i = 0;
    goto L1;
  }
    
    return 1;  
  }
}
`
(7,3): warning CS0164: This label has not been referenced
(8,10): error CS0159: No such label 'L4' within the scope of the goto statement
(11,3): warning CS0164: This label has not been referenced
(12,10): error CS0159: No such label 'L1' within the scope of the goto statement
(15,3): warning CS0164: This label has not been referenced
(16,10): error CS0159: No such label 'L2' within the scope of the goto statement
(19,3): warning CS0164: This label has not been referenced
(20,10): error CS0159: No such label 'L1' within the scope of the goto statement
`
class Test {
  public class TestClass {
    public static int intI = 1;
  }
}

namespace MyNS
{
  namespace Test {
    class TestClass {
      public static int intI = 2;
    }
  }

  class MyClass {
    public static int Main() {
      if (Test.TestClass.intI == 2) {
        return 0;
      }
      else {
        return 1;
      }
    }
  }

}
`
`
struct Test {
  public class TestClass {
    public static int intI = 1;
  }
}

namespace MyNS
{
  namespace Test {
    class TestClass {
      public static int intI = 2;
    }
  }

  class MyClass {
    public static int Main() {
      if (Test.TestClass.intI == 2) {
        return 0;
      }
      else {
        return 1;
      }
    }
  }

}
`
`
interface Test {}

namespace MyNS
{
  namespace Test {
    class TestClass {
      public static int intI = 2;
    }
  }

  class MyClass {
    public static int Main() {
      if (Test.TestClass.intI == 2) {
        return 0;
      }
      else {
        return 1;
      }
    }
  }

}
`
`
interface MyInter {
  void bogus();  
}

namespace MyNS
{
  interface MyInter {
    void test();
  }

  class MyClass : MyInter{

    public void test() {}

    public static int Main() {
      return 0;
    }
  }

}
`
`
enum MyEnum {test = 1}

namespace MyNS
{
  enum MyEnum {test = 2}

  class MyClass {

    public static int Main() {
      if ((int)MyEnum.test == 2) {
        return 0;
      }
      else {
        return 1;
      }
    }
  }

}
`
`
delegate void TestDel();

namespace MyNS
{
  delegate int TestDel(int intI);

  class MyClass {

    int TestMeth(int intI) {
      return 1;
    }    

    public static int Main() {
      MyClass test = new MyClass();
      TestDel td = new TestDel(test.TestMeth);
      return 0;
    }
  }

}
`
(15,15): warning CS0219: The variable 'td' is assigned but its value is never used
`
enum MyEnum {test = 1}

class MyTopClass
{
  enum MyEnum {test = 2}

  class MyClass {

    public static int Main() {
      if ((int)MyEnum.test == 2) {
        return 0;
      }
      else {
        return 1;
      }
    }
  }

}
`
`
delegate void TestDel();

class MyTopClass
{
  delegate int TestDel(int intI);

  class MyClass {

    int TestMeth(int intI) {
      return 1;
    }    

    public static int Main() {
      MyClass test = new MyClass();
      TestDel td = new TestDel(test.TestMeth);
      return 0;
    }
  }

}
`
(15,15): warning CS0219: The variable 'td' is assigned but its value is never used
`
delegate void TestDel();

struct MyTopStruct
{
  delegate int TestDel(int intI);

  class MyClass {

    int TestMeth(int intI) {
      return 1;
    }    

    public static int Main() {
      MyClass test = new MyClass();
      TestDel td = new TestDel(test.TestMeth);
      return 0;
    }
  }

}
`
(15,15): warning CS0219: The variable 'td' is assigned but its value is never used
`
class TestClass {
  public class Inner {
    public static int intI = 1;
  }
}

struct MyTopStruct
{
  class TestClass {
    public class Inner {
      public static int intI = 2;
    }
  }

  class MyClass {
    public static int Main() {
      if (TestClass.Inner.intI == 2) {
        return 0;
      }
      else {
        return 1;
      }
    }
  }

}
`
`
enum MyEnum {test = 1}

struct MyTopStruct
{
  enum MyEnum {test = 2}

  class MyClass {

    public static int Main() {
      if ((int)MyEnum.test == 2) {
        return 0;
      }
      else {
        return 1;
      }
    }
  }

}
`
`
class Outer {

  static void Test(int intI) {}
  static void Test(string s) {}

  class Inner {
    static void Test(int intI) {}
    public static int Main() {
      Test("bogus");
      return 1;
    }
  }
}
`
(9,12): error CS0029: Cannot implicitly convert type 'string' to 'int'
`
class Outer {

  static int Test() {
    return 1;
  }

  class Inner {

    static int Test = 2;
  
    public static int Main() {
      int intJ = Test();  
      return 1;
    }
  }
}
`
(12,18): error CS0118: 'Outer.Inner.Test' is a 'field' but is used like a method
`
class AnotherClass {
  public int intRet(int intI) {
    return 2;
  }
}

class Outer {

  class Test {
    public static int intRet() {
      return 1;
    }
  }

  class Inner {

    static AnotherClass Test = new AnotherClass();

    public static int Main() {
      int i = Test.intRet();
      return 1;
    }
  }
}
`
(20,15): error CS1501: No overload for method 'intRet' takes '0' arguments
(2,14): (Location of symbol related to previous error)
`
class BaseClass {
  public const int intI = 1;
}

class MyClass : BaseClass {

  int intI = 2;

  public static int Main() {
    int i = intI;
    return 1;
  }  
}
`
(7,7): warning CS0108: The keyword new is required on 'MyClass.intI' because it hides inherited member 'BaseClass.intI'
(2,20): (Location of symbol related to previous warning)
(10,13): error CS0120: An object reference is required for the nonstatic field, method, or property 'MyClass.intI'
`
class BaseClass {
  public int intI = 2;
}

class MyClass : BaseClass {

  public int intI {
    set {}
  }

  public static int Main() {
    MyClass test = new MyClass();
    int i = test.intI;
    return 1;
  }  
}
`
(7,14): warning CS0108: The keyword new is required on 'MyClass.intI' because it hides inherited member 'BaseClass.intI'
(2,14): (Location of symbol related to previous warning)
(13,13): error CS0154: The property or indexer 'MyClass.intI' cannot be used in this context because it lacks the get accessor
`
class BaseClass {
  public class intI {
    public int i = 2;
  }
}

class MyClass : BaseClass {

  const int intI = 3;

  public static int Main() {
    intI test = new intI();
    if ((test.i == 2) && (intI == 3)) {
      return 0;
    }
    else {
      return 1;
    }
  }  
}
`
(9,13): warning CS0108: The keyword new is required on 'MyClass.intI' because it hides inherited member 'BaseClass.intI'
(2,16): (Location of symbol related to previous warning)
`
class BaseClass {
  public void intI() {}
}

class MyClass : BaseClass {

  int intI = 3;

  public static int Main() {
    MyClass test = new MyClass();
    test.intI();
    return 1;
  }  
}
`
(7,7): warning CS0108: The keyword new is required on 'MyClass.intI' because it hides inherited member 'BaseClass.intI()'
(2,15): (Location of symbol related to previous warning)
(11,10): error CS0118: 'MyClass.intI' is a 'field' but is used like a method
`
class BaseClass {
  public int MyMeth = 1;
}

class MyClass : BaseClass {

  public int MyMeth() {
    return 2;
  }

  public static int Main() {
    MyClass test = new MyClass();
    int i = test.MyMeth;
    return 1;
  }  
}
`
(7,14): warning CS0108: The keyword new is required on 'MyClass.MyMeth()' because it hides inherited member 'BaseClass.MyMeth'
(2,14): (Location of symbol related to previous warning)
(13,18): error CS0654: Method 'MyClass.MyMeth()' referenced without parentheses
`
class BaseClass {
  public int MyMeth(int intI) {
    return intI;
  }
}

class MyClass : BaseClass {

  public static int MyMeth(int intI) {
    return intI + 1;
  }

  public static int Main() {
    MyClass test = new MyClass();
    int i = test.MyMeth(2);
    return 1;
  }  
}
`
(9,21): warning CS0108: The keyword new is required on 'MyClass.MyMeth(int)' because it hides inherited member 'BaseClass.MyMeth(int)'
(2,14): (Location of symbol related to previous warning)
(15,13): error CS0176: Static member 'MyClass.MyMeth(int)' cannot be accessed with an instance reference; qualify it with a type name instead
`
public class MyBase {
  public static int F() {
    return 2;
  }
}

public class MyDerived : MyBase {
  new private static int F() {
    return 3;
  }
}

public class MyClass : MyDerived {

  public static int Main() {
    if (F() == 2) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
public class Top {
  private class Outer {
    public class Inner {}
  }
}
public class MyClass {
  public static int Main() {
    Top.Outer.Inner test = new Top.OUter.Inner();
    return 1;
  }
}
`
(8,5): error CS0122: 'Top.Outer' is inaccessible due to its protection level
(8,36): error CS0426: The type name 'OUter' does not exist in the type 'Top'
`
public class Outer {
  protected static internal int intI = 2;
}
public class MyClass {
  public static int Main() {
    if (Outer.intI == 2) {    
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
public class MyClass {
  public static int Main() {
    bogus test = new bogus();
    return 1;
  }
}
`
(3,5): error CS0246: The type or namespace name 'bogus' could not be found (are you missing a using directive or an assembly reference?)
`
public class MyBase {
  protected internal virtual void OnSetComponentDefaults() {}
}
public class MyClass : MyBase {

  public override void OnSetComponentDefaults() {}

  public static int Main() {
    return 0;
  }
}
`
(6,24): error CS0507: 'MyClass.OnSetComponentDefaults()': cannot change access modifiers when overriding 'protected internal' inherited member 'MyBase.OnSetComponentDefaults()'
(2,35): (Location of symbol related to previous error)
`
public class Outer {
  protected internal class MyBase {}
  protected class MyClass : MyBase {
    public static int Main() {
      return 0;
    }
  }
}
`
`
internal interface MyBase {}
public interface MyInter : MyBase {}

public class MyClass {
  public static int Main() {
    return 1;
  }
}
`
(2,18): error CS0061: Inconsistent accessibility: base interface 'MyBase' is less accessible than interface 'MyInter'
(1,20): (Location of symbol related to previous error)
`
public class Outer {

  protected class Test {}

  public delegate Test MyDelegate();

  public class MyClass {
    public static int Main() {
      return 1;
    }
  }

}
`
(5,24): error CS0058: Inconsistent accessibility: return type 'Outer.Test' is less accessible than delegate 'Outer.MyDelegate'
(3,19): (Location of symbol related to previous error)
`
public class Outer {

  internal class Test {}

  public delegate void MyDelegate(Test T);

  public class MyClass {
    public static int Main() {
      return 1;
    }
  }

}
`
(5,24): error CS0059: Inconsistent accessibility: parameter type 'Outer.Test' is less accessible than delegate 'Outer.MyDelegate'
(3,18): (Location of symbol related to previous error)
`
public class Outer {

  internal enum Test {aa = 1}

  public const Test MyTest = Test.aa;

  public class MyClass {
    public static int Main() {
      return 0;
    }
  }

}
`
(5,21): error CS0052: Inconsistent accessibility: field type 'Outer.Test' is less accessible than field 'Outer.MyTest'
(3,17): (Location of symbol related to previous error)
`
public class Outer {

  private class Test {}

  public Test MyMeth() {
    return new Test();
  }  

  public class MyClass {
    public static int Main() {
      return 1;
    }
  }

}
`
(5,15): error CS0050: Inconsistent accessibility: return type 'Outer.Test' is less accessible than method 'Outer.MyMeth()'
(3,17): (Location of symbol related to previous error)
`
public class Outer {

  private class Test {}

  public void MyMeth(Test t) {}  

  public class MyClass {
    public static int Main() {
      return 1;
    }
  }

}
`
(5,15): error CS0051: Inconsistent accessibility: parameter type 'Outer.Test' is less accessible than method 'Outer.MyMeth(Outer.Test)'
(3,17): (Location of symbol related to previous error)
`
public class Outer {

  protected class Test {}

  public Test MyTest {
    get {
      return new Test();
    }
  }  

  public class MyClass {
    public static int Main() {
      return 1;
    }
  }

}
`
(5,15): error CS0053: Inconsistent accessibility: property type 'Outer.Test' is less accessible than property 'Outer.MyTest'
(3,19): (Location of symbol related to previous error)
`
public class Outer {

  internal class Test {}

  public Test this[int intI] {
    get {
      return new Test();
    }
  }  

  public class MyClass {
    public static int Main() {
      return 1;
    }
  }

}
`
(5,15): error CS0054: Inconsistent accessibility: indexer return type 'Outer.Test' is less accessible than indexer 'Outer.this[int]'
(3,18): (Location of symbol related to previous error)
`
public class Outer {

  internal class Test {}

  public int this[Test T] {
    get {
      return 1;
    }
  }  

  public class MyClass {
    public static int Main() {
      return 1;
    }
  }

}
`
(5,14): error CS0055: Inconsistent accessibility: parameter type 'Outer.Test' is less accessible than indexer 'Outer.this[Outer.Test]'
(3,18): (Location of symbol related to previous error)
`
class Test {}
public class MyClass {

  public static Test operator + (MyClass MyInt, MyClass MyInt2) {
    return new Test();
  }

  public static int Main() {
    return 1;
  }
  
}
`
(4,22): error CS0056: Inconsistent accessibility: return type 'Test' is less accessible than operator 'MyClass.operator +(MyClass, MyClass)'
(1,7): (Location of symbol related to previous error)
`
class Test {}
public class MyClass {

  public static int operator + (MyClass MyInt, Test MyInt2) {
    return 1;
  }

  public static int Main() {
    return 1;
  }
  
}
`
(4,21): error CS0057: Inconsistent accessibility: parameter type 'Test' is less accessible than operator 'MyClass.operator +(MyClass, Test)'
(1,7): (Location of symbol related to previous error)
`
class Test {}
public class MyClass {

  public MyClass(Test T) {
    
  }

  public static int Main() {
    return 0;
  }
  
}
`
(4,10): error CS0051: Inconsistent accessibility: parameter type 'Test' is less accessible than method 'MyClass.MyClass(Test)'
(1,7): (Location of symbol related to previous error)
`
class MyClass { 
  internal protected class MyInner { 
    public int MyMeth(MyInner2 arg) 
    {
      return arg.intI;
    }
  }
  internal protected class MyInner2 
  {
    public int intI = 2;
  }

  public static int Main()  
  {
    MyInner MI = new MyInner();
    if (MI.MyMeth(new MyInner2()) == 2)
    {
      return 0;
    }
    else 
    {
      return 1;
    }
  }
}
`
`
class BaseClass {
  public const int intI = 1;
}

class MyClass : BaseClass {

  public const int intI = 2;

  public static int Main() {
    if (intI == 2) {
      return 0;
    }
    else {
      return 1;
    }
  }  
}
`
(7,20): warning CS0108: The keyword new is required on 'MyClass.intI' because it hides inherited member 'BaseClass.intI'
(2,20): (Location of symbol related to previous warning)
`
class BaseClass {
  public int MyMeth = 1;
}

class MyClass : BaseClass {

  public int MyMeth() {
    return 2;
  }

  public static int Main() {
    MyClass test = new MyClass();
    if (test.MyMeth() == 2) {
      return 0;
    }
    else {
      return 1;
    }
  }  
}
`
(7,14): warning CS0108: The keyword new is required on 'MyClass.MyMeth()' because it hides inherited member 'BaseClass.MyMeth'
(2,14): (Location of symbol related to previous warning)
`
class MyClass {

  public int MyMeth(int intI) {
    return intI + 1;
  }

  public static int Main() {
    int i = MyMeth(2);
    return 1;
  }  
}
`
(8,13): error CS0120: An object reference is required for the nonstatic field, method, or property 'MyClass.MyMeth(int)'
`
public class Top {
  private class Outer {
    public static int intI = 2;
  }
}

public class MyClass {
  public static int Main() {
    int intJ = Top.Outer.intI;
    return 1;
  }
}
`
(9,16): error CS0122: 'Top.Outer' is inaccessible due to its protection level
`
public class Outer {
  internal class MyBase {}
  protected class MyClass : MyBase {
    public static int Main() {
      return 0;
    }
  }
}
`
(3,19): error CS0060: Inconsistent accessibility: base class 'Outer.MyBase' is less accessible than class 'Outer.MyClass'
(2,18): (Location of symbol related to previous error)
`
class MyClass {

  public static int Main() {
    int intI = MyClass1.intI;
    return 1;
  }
}

namespace MyNS {
  class MyClass1 {
    public static int intI = 1;
  }
}
`
(4,16): error CS0246: The type or namespace name 'MyClass1' could not be found (are you missing a using directive or an assembly reference?)
`
namespace MyNS {
  class MyClass {

    public static int Main() {
      int intI = TestNS.MyClass2.intI;
      return 1;
    }
  }

  namespace MyNS2 {
    namespace TestNS {
      class MyClass2 {
        public static int intI = 2;
      }
    }
  }
}
`
(5,18): error CS0246: The type or namespace name 'TestNS' could not be found (are you missing a using directive or an assembly reference?)
`
class MyClass 
{

  public static int Main() 
  {
    
    int i = 1;
    int j = 1;

    switch (i)
    {
      case 1:  
        switch (j)
        {
          case 1:
            goto foo;
            break;
          default:
            break;
          foo:  
            j = 2;
            break;
        }
        i = 2;
        goto foo;

        break;
      default:
        break;
      foo:
        return i-j;
        break;
    }

    return 1;
  }
}
`
`
class MyClass 
{

  public static int Main() 
  {
    
    int i = 1;

    switch (i)
    {
      case 1:    
        int a = 1;
        long a = 1;
        break;
      default:
        break;
    }

    return 1;
  }
}
`
(13,14): error CS0128: A local variable named 'a' is already defined in this scope
`
class MyClass {
  static int i;
  public static int Main() {
    i = 1;
    int i = 2;
    return i++;    
  }

}
`
(4,5): error CS2513: Use of 'i' precedes declaration
`
public class Top {
  protected class Outer {
    public class Inner {}
  }
}

public class MyClass {
  public static int Main() {
    Top.Outer.Inner test = new Top.Outer.Inner();
    return 1;
  }
}
`
(9,5): error CS0122: 'Top.Outer' is inaccessible due to its protection level
`
class MyClass {

  public int intI = 1;

  public bool Test(ref int intI) {
    if (intI == 2) {
      return true;
    }
    return false;
  }

  public static int Main() {
    int intJ = 2;
    MyClass test = new MyClass();
    if (test.Test(ref intJ)) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
enum MyEnum {AA = BB, BB = 1}

public class MyClass {
  public static int Main() {
    if ((int)MyEnum.AA == 1) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
using System;
 
namespace Microsoft.Svg 
{

  class Image {
    public int cx;
    
    public Image() {
    }
  }

  class Test  { 
    static void Main() {
      Microsoft.Svg.Image e = new Microsoft.Svg.Image();
      Console.WriteLine(e.cx); 
    }
  }

}
`
0
`
using System; 
using System;

class Test {
  static void Main() {
    Console.WriteLine("...");
  }
}
`
(2,7): warning CS0105: The using directive for 'System' appeared previously in this namespace
...
`
public struct MyStruct {}

public class MyClass : MyStruct {
  public static void Main() {}
}
`
(3,24): error CS0509: 'MyClass' : cannot inherit from sealed class 'MyStruct'
(1,15): (Location of symbol related to previous error)
`
public struct MyStruct {}

public class MyClass {
  
  MyStruct MS = null;

  public static void Main() {}
}
`
(5,17): error CS0037: Cannot convert null to 'MyStruct' because it is a value type
`
public struct MyStruct {
  public int MyInt;
}

public class MyClass {
  public static int Main() {
    MyStruct MS = new MyStruct();
    MyStruct MS2;
    
    MS.MyInt = 3;
    MS2 = MS;
    MS.MyInt = 4;
    
    if (MS2.MyInt == 3) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
public class MyClass 
{
  public static int Main()
  {
    int i;
    System.Type type = typeof(i);
    return 1;
  }
}
`
(6,31): error CS0246: The type or namespace name 'i' could not be found (are you missing a using directive or an assembly reference?)
`
public class A
{
   public int static Main(string[] args)   // CS1585
   {
  return 1;
   }
}
`
(3,15): error CS1585: Member modifier 'static' must precede the member type and name
`
public abstract class B
{
        abstract public string Prop { get; set; }
}

public class A : B
{
   public static int Main() { return 1; }

   sealed del override public Prop
   {
        get
        {
                return "test";
        }
        set {}
   }
}
`
(10,15): error CS1585: Member modifier 'override' must precede the member type and name
(10,4): error CS0238: 'A.Prop' cannot be sealed because it is not an override
(10,11): error CS0246: The type or namespace name 'del' could not be found (are you missing a using directive or an assembly reference?)
(6,14): error CS0534: 'A' does not implement inherited abstract member 'B.Prop.get'
(3,39): (Location of symbol related to previous error)
(6,14): error CS0534: 'A' does not implement inherited abstract member 'B.Prop.set'
(3,44): (Location of symbol related to previous error)
`
using System;

namespace Microsoft.Conformance.Types {

  enum E {a = 1, b = 2};

  public class defco011 {

    public static int Main()
    {
      E e = new E();
      if (e == ((E)0)) {
        return 0;
      }
      else {
        return 1;
      }
    }
  }
}
`
`
public class MyClass {
  public static int Main() {

    short s1 = 2;
    short s2 = -s1; //promotes to int
      
    return 1;
  }
}
`
(5,16): error CS0029: Cannot implicitly convert type 'int' to 'short'
`
using System;

public class MyClass {
  public static int Main() {

    char c = (uint)1;

    return 1;
  }
}
`
(6,14): error CS0031: Constant value '(uint)1' cannot be converted to a 'char'
`
public class MyClass {
  public static int Main() {

    short s1 = 2;
    short s2 = (short)~s1; 
    byte b1 = 3;
    int b2 = ~b1;
    int i1 = 4;
    int i2 = ~i1;
    long l1 = 5l;
    long l2 = ~l1;
    char c1 = (char)6;
    int c2 = ~c1;
      
    if ((s2 == (short)-3) && (b2 == -4) && (i2 == -5) && (l2 == -6l) && (c2 == -7)) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
(10,16): warning CS0078: The 'l' suffix is easily confused with the digit '1' -- use 'L' for clarity
(15,67): warning CS0078: The 'l' suffix is easily confused with the digit '1' -- use 'L' for clarity
`
using System;

public class MyClass {
  public static int Main() {

    int intRet = 0;

    ushort s1 = 2;
    sbyte b1 = 3;
    uint i1 = 4;
    ulong l1 = 5L;

    int i = 1;
    

    if ((s1 >> 1).GetType() != i.GetType()) {
      intRet = 1;
    }
    if ((b1 >> 1).GetType() != i.GetType()) {
      intRet = 1;
    }
    if ((i1 >> 1).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((l1 >> 1).GetType() != l1.GetType()) {
      intRet = 1;
    }

    return intRet;
  }
}
`
`
public class MyClass {
  public static int Main() {

    ushort s1 = 2;
    ushort s2 = (ushort)+s1;
    sbyte b1 = 3;
    int b2 = +b1;
    uint i1 = 4;
    uint i2 = +i1;
    ulong l1 = 5ul;
    ulong l2 = +l1;
      
    if ((s2 == (ushort)2) && (b2 == 3) && (i2 == 4) && (l2 == 5ul)) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
public class MyClass {
  public static int Main() {

    ulong l1 = 2;
    ulong l2 = (ulong)-l1;
      
    return 1;
  }
}
`
(5,23): error CS0023: Operator '-' cannot be applied to operand of type 'ulong'
`
using System;

public class MyClass {
  public static int Main() {

    int RetVal = 0;

    float f1 = 0.0f/0.0f;
    double d1 = 0.0d/0.0d;
    
    Console.WriteLine(f1.ToString(System.Globalization.CultureInfo.InvariantCulture));
    Console.WriteLine(f1 != float.NaN);

    if (float.IsNaN(f1) != true) {
      RetVal = 1;
    }
    if (double.IsNaN(d1) != true) {
      RetVal = 1;
    }

    return RetVal;        
  }
}
`
NaN
True
`
using System;

public class MyClass {
  public static int Main() {

    double d1 = double.NaN;
    double d2 = 12.0d;
    
    if ((d1==d1) != false) return 1;
    if ((d1==d2) != false) return 1;
    if ((d2==d1) != false) return 1;
    if ((d1!=d1) != true) return 1;
    if ((d1!=d2) != true) return 1;
    if ((d2!=d1) != true) return 1;
    if ((d1>d1) != false) return 1;
    if ((d1>d2) != false) return 1;
    if ((d2>d1) != false) return 1;
    if ((d1<d1) != false) return 1;
    if ((d1<d2) != false) return 1;
    if ((d2<d1) != false) return 1;
    if ((d1>=d1) != false) return 1;
    if ((d1>=d2) != false) return 1;
    if ((d2>=d1) != false) return 1;
    if ((d1<=d1) != false) return 1;
    if ((d1<=d2) != false) return 1;
    if ((d2<=d1) != false) return 1;

    return 0;        
  }
}
`
`
using System;

public class MyClass {
  public static int Main() {
    decimal m1 = 1.0f;
  }
}
`
(5,18): error CS0029: Cannot implicitly convert type 'float' to 'decimal'
`
public class foo {
  
  public static void Main() {

    decimal m1 = 0.000000000000000000000000000001m;
  }
}
`
(5,13): warning CS0219: The variable 'm1' is assigned but its value is never used
`
public class MyClass {

  public static int Main() {
    byte b = true;
    return 1;
  }

}
`
(4,14): error CS0029: Cannot implicitly convert type 'bool' to 'byte'
`
using System;

struct MyStruct {
  public int MyInt;
}

public class MyClass {
  public static int Main() {

    MyStruct MS = new MyStruct();
    MS.MyInt = 3;

    object box = MS;  

    MS.MyInt = 4;
    
    if (((MyStruct)box).MyInt != 3) {
      return 1;
    }
    else {
      return 0;
    }      
  }
}
`
`
using System;

enum MyEnum {a = 2, b=3}

struct MyStruct {
  public int MyInt;
}

public class MyClass {
  public static int Main() {

    byte b1 = (byte)2;
    short s1 = (short)3;
    int i1 = 4;
    long l1 = 5L;
    char c1 = (char) 6;
    float f1 = 7.0f;
    double d1 = 8.0d;
    decimal m1 = 9.0m;
    bool bl1 = false;
    //variant v1 = 10;
    MyEnum e1 = MyEnum.a;
    MyStruct t1 = new MyStruct();     

    object box1 = b1;  
    object box2 = s1;
    object box3 = i1;  
    object box4 = l1;
    object box5 = c1;  
    object box6 = f1;
    object box7 = d1;  
    object box8 = m1;
    object box9 = bl1;  
    //object box10 = v1;
    object box11 = e1;  
    object box12 = t1;

    if ((box1 is byte) && (box2 is short) && (box3 is int) &&
    (box4 is long) && (box5 is char) && (box6 is float) &&
    (box7 is double) && (box8 is decimal) &&(box9 is bool) &&
    (box11 is MyEnum) && (box12 is MyStruct)) {
      return 0;
    }
    else {
      return 1;
    }  

      
  }
}
`
`
using System;

public class MyClass {
  public static int Main() {

    sbyte b1 = 2;
    ushort s1 = 3;
    uint i1 = 4;
    ulong l1 = 5;  

    object box1 = b1;  
    object box2 = s1;
    object box3 = i1;  
    object box4 = l1;

    if ((box1 is sbyte) && (box2 is ushort) && (box3 is uint) && (box4 is ulong)) {
      return 0;
    }
    else {
      return 1;
    }  
      
  }
}
`
`
using System;

public class MyClass {
  public static int Main() {

    int intRet = 0;

    short s1 = 2;
    byte b1 = 3;
    int i1 = 4;
    long l1 = 5L;
    char c1 = (char)6;

    if ((s1 << 1).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((b1 << 1).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((i1 << 1).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((l1 << 1).GetType() != l1.GetType()) {
      intRet = 1;
    }
    if ((c1 << 1).GetType() != i1.GetType()) {
      intRet = 1;
    }
  
    return intRet;
  }
}
`
`
using System;

public class MyClass {
  public static int Main() {

    int intRet = 0;

    short s1 = 2;
    byte b1 = 3;
    int i1 = 4;
    long l1 = 5L;
    char c1 = (char)6;
    ushort s2 = 7;
    sbyte b2 = 8;
    uint i2 = 9;
    ulong l2 = 10;

    //ushort
    if ((s2 + s1).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((s2 + b1).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((s2 + i1).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((s2 + l1).GetType() != l1.GetType()) {
      intRet = 1;
    }
    if ((s2 + c1).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((s2 + s2).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((s2 + b2).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((s2 + i2).GetType() != i2.GetType()) {
      intRet = 1;
    }
    if ((s2 + l2).GetType() != l2.GetType()) {
      intRet = 1;
    }
  
    //sbyte
    if ((b2 + s1).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((b2 + b1).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((b2 + i1).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((b2 + l1).GetType() != l1.GetType()) {
      intRet = 1;
    }
    if ((b2 + c1).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((b2 + s2).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((b2 + b2).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((b2 + i2).GetType() != l1.GetType()) {
      intRet = 1;
    }
    //if ((b2 + l2).GetType() != l2.GetType()) {
    //  intRet = 1;
    //}

    //uint
    if ((i2 + s1).GetType() != l1.GetType()) {
      intRet = 1;
    }
    if ((i2 + b1).GetType() != i2.GetType()) {
      intRet = 1;
    }
    if ((i2 + i1).GetType() != l1.GetType()) {
      intRet = 1;
    }
    if ((i2 + l1).GetType() != l1.GetType()) {
      intRet = 1;
    }
    if ((i2 + c1).GetType() != i2.GetType()) {
      intRet = 1;
    }
    if ((i2 + s2).GetType() != i2.GetType()) {
      intRet = 1;
    }
    if ((i2 + b2).GetType() != l1.GetType()) {
      intRet = 1;
    }
    if ((i2 + i2).GetType() != i2.GetType()) {
      intRet = 1;
    }
    if ((i2 + l2).GetType() != l2.GetType()) {
      intRet = 1;
    }

    //ulong
    //if ((l2 + s1).GetType() != l2.GetType()) {
    //  intRet = 1;
    //}
    if ((l2 + b1).GetType() != l2.GetType()) {
      intRet = 1;
    }
    //if ((l2 + i1).GetType() != l2.GetType()) {
    //  intRet = 1;
    //}
    //if ((l2 + l1).GetType() != l2.GetType()) {
    //  intRet = 1;
    //}
    if ((l2 + c1).GetType() != l2.GetType()) {
      intRet = 1;
    }
    if ((l2 + s2).GetType() != l2.GetType()) {
      intRet = 1;
    }
    //if ((l2 + b2).GetType() != l2.GetType()) {
    //  intRet = 1;
    //}
    if ((l2 + i2).GetType() != l2.GetType()) {
      intRet = 1;
    }
    if ((l2 + l2).GetType() != l2.GetType()) {
      intRet = 1;
    }
  
    return intRet;
  }
}
`
`
`
using System;

public class MyClass {
  public static int Main() {

    int RetVal = 0;

    float f1 = 1.0f/0.0f;
    float f2 = -1.0f/0.0f;
    double d1 = 1.0d/0.0d;
    double d2 = -1.0d/0.0d;

    if (f1 != float.PositiveInfinity) {
      RetVal = 1;
    }
    if (f2 != float.NegativeInfinity) {
      RetVal = 1;
    }
    if (d1 != double.PositiveInfinity) {
      RetVal = 1;
    }
    if (d2 != double.NegativeInfinity) {
      RetVal = 1;
    }    

    return RetVal;        
  }
}
`
`
using System;

public class MyClass {
  public static int Main() {

    int intRet = 0;

    float f1 = 11.0f;
    short s1 = 2;
    byte b1 = 3;
    int i1 = 4;
    long l1 = 5L;
    char c1 = (char)6;
    
    if ((f1 + s1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((s1 + f1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((f1 + b1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((b1 + f1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((f1 + i1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((i1 + f1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((f1 + l1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((l1 + f1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((f1 + c1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((c1 + f1).GetType() != f1.GetType()) {
      intRet = 1;
    }    

    return intRet;        
  }
}
`
`
using System;

public class MyClass {
  public static int Main() {

    int intRet = 0;

    float f1 = 11.0f;
    short s1 = 2;
    byte b1 = 3;
    int i1 = 4;
    long l1 = 5L;
    char c1 = (char)6;
    
    if ((f1 - s1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((s1 - f1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((f1 - b1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((b1 - f1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((f1 - i1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((i1 - f1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((f1 - l1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((l1 - f1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((f1 - c1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((c1 - f1).GetType() != f1.GetType()) {
      intRet = 1;
    }    

    return intRet;        
  }
}
`
`
using System;

public class MyClass {
  public static int Main() {

    int intRet = 0;

    float f1 = 11.0f;
    short s1 = 2;
    byte b1 = 3;
    int i1 = 4;
    long l1 = 5L;
    char c1 = (char)6;
    
    if ((f1 % s1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((s1 % f1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((f1 % b1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((b1 % f1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((f1 % i1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((i1 % f1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((f1 % l1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((l1 % f1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((f1 % c1).GetType() != f1.GetType()) {
      intRet = 1;
    }    
    if ((c1 % f1).GetType() != f1.GetType()) {
      intRet = 1;
    }    

    return intRet;        
  }
}
`
`
using System;

interface Interface1 {
  void f();
}

struct MyStruct : Interface1 {
  public int MyInt;
  public void f(){}
}

public class MyClass {
  public static int Main() {

    MyStruct MS = new MyStruct();
    MS.MyInt = 3;

    Interface1 box = MS;  

    MS.MyInt = 4;
    
    if (((MyStruct)box).MyInt != 3) {
      return 1;
    }
    else {
      return 0;
    }    
  }
}
`
`
public class MyClass {
  public static int Main() {

    short s1 = 2;
    short s2 = (short)-s1; 
    byte b1 = 3;
    int b2 = -b1;
    int i1 = 4;
    int i2 = -i1;
    long l1 = 5L;
    long l2 = -l1;
    char c1 = (char)6;
    int c2 = -c1;
      
    if ((s2 == (short)-2) && (b2 == -3) && (i2 == -4) && (l2 == -5L) && (c2 == -6)) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
using System;

public class MyClass {
  public static int Main() {

    int intRet = 0;

    short s1 = 2;
    byte b1 = 3;
    int i1 = 4;
    long l1 = 5L;
    char c1 = (char)6;

    //short
    if ((s1 + s1).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((s1 + b1).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((s1 + i1).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((s1 + l1).GetType() != l1.GetType()) {
      intRet = 1;
    }
    if ((s1 + c1).GetType() != i1.GetType()) {
      intRet = 1;
    }
  
    //byte
    if ((b1 + b1).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((b1 + i1).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((b1 + l1).GetType() != l1.GetType()) {
      intRet = 1;
    }
    if ((b1 + c1).GetType() != i1.GetType()) {
      intRet = 1;
    }

    //int
    if ((i1 + i1).GetType() != i1.GetType()) {
      intRet = 1;
    }
    if ((i1 + l1).GetType() != l1.GetType()) {
      intRet = 1;
    }
    if ((i1 + c1).GetType() != i1.GetType()) {
      intRet = 1;
    }

    //long
    if ((l1 + l1).GetType() != l1.GetType()) {
      intRet = 1;
    }
    if ((l1 + c1).GetType() != l1.GetType()) {
      intRet = 1;
    }

    //char
    if ((c1 + c1).GetType() != i1.GetType()) {
      intRet = 1;
    }
  
    return intRet;
  }
}
`
`
using System;

public class MyClass {
  public static int Main() {

    float f1 = float.MaxValue;
    float f2 = float.PositiveInfinity;
    float f3 = float.NegativeInfinity;

    if ((float)(f1 + (f1 * 1.0e-7f)) != f2) {
      return 1;
    }
    if ((float)(f1 - (-f1 * 1.0e-7f)) != f2) {
      return 1;
    }
    if ((float)(f1 * (1.0f + 1.0e-7f)) != f2) {
      return 1;
    }
    if ((float)(f1 / (1.0f - 1.0e-7f)) != f2) {
      return 1;
    }    
    if ((float)(-f1 + (-(f1 * 1.0e-7f))) != f3) {
      return 1;
    }
    if ((float)(-f1 - (f1 * 1.0e-7f)) != f3) {
      return 1;
    }
    if ((float)(-f1 * (1.0f + 1.0e-7f)) != f3) {
      return 1;
    }
    if ((float)(-f1 / (1.0f - 1.0e-7f)) != f3) {
      return 1;
    }  

    return 0;        
  }
}
`
`
public class MyClass {
  public static int Main() {

    ushort s1 = 2;
    int s2 = -s1;
    sbyte b1 = 3;
    int b2 = -b1;
    uint i1 = 4;
    long i2 = -i1;
      
    if ((s2 == -2) && (b2 == -3) && (i2 == -4)) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
using System;

public class MyClass {
  public static int Main() {
    decimal m1 = 1.0d;
  }
}
`
(5,18): error CS0664: Literal of type double cannot be implicitly converted to type 'decimal'; use an 'M' suffix to create a literal of this type
`
public class MyClass {

  public byte b1 = 2;

  public static int Main() {  
    byte b2 = MyClass.b1;
    return 1;
  }
}
`
(6,15): error CS0120: An object reference is required for the nonstatic field, method, or property 'MyClass.b1'
`
class C
{
   public class Inner
   {
      public static int v = 9;
   }
}

class D
{
   public static int Main()
   {
      C cValue = new C();
      cValue.Inner.v = 5;   // CS0572
      return 1;
   }
}
`
(14,14): error CS0572: 'Inner': cannot reference a type through an expression; try 'C.Inner' instead
`
public class MyClass {
  public static int Main() {  
    void v;
    return 1;
  }
}
`
(3,5): error CS1547: Keyword 'void' cannot be used in this context
`
public class MyClass {
  public static int Main() {  
    void[] v = new void[10];
    return 1;
  }
}
`
(3,5): error CS1547: Keyword 'void' cannot be used in this context
(3,20): error CS1547: Keyword 'void' cannot be used in this context
`
using System;

namespace Tests {

  public class Driver{
    public static void Main(){
        byte  source;
        ulong  dest;
        source = 1;
        dest =  source;
        if (dest == 1)
          Console.WriteLine("Pass");
        else
          Console.WriteLine("Fail");
        return;
    } 
  }
}
`
Pass
`
using System;

namespace Tests {

public class Driver 
{
    public static void Main() 
    {

        decimal  source;
        byte  dest;
        source = -1;
        try {
          checked {
          dest = (byte) source;
          }
        }
        catch {
          Console.WriteLine("Exception caught");
        }
        return;
    } 
}

}
`
(15,11): warning CS0219: The variable 'dest' is assigned but its value is never used
Exception caught
`
using System;

delegate void MyDelegate();

class Test
{
  public static void DoNothing() { }
  public static void Main()
  {
    MyDelegate src = new MyDelegate(Test.DoNothing);
    System.Delegate dst = src;
    src();
  }
}
`
(11,21): warning CS0219: The variable 'dst' is assigned but its value is never used
`
using System;

namespace Tests {

public class Test
{
  public int func() {return(1);}
}

public class Driver 
{
    public static void Main() 
    {
    Test  test = new Test();

    object  obj;

    obj = test;    // implicit setup

    test = obj;
    } 
}

}
`
(20,12): error CS0029: Cannot implicitly convert type 'object' to 'Tests.Test'
`
using System;
namespace Tests
{
    enum _DestinationEnumType : byte{ValOne = 1}

    public class Driver
    {
        public static void Main()
        {
            _DestinationEnumType Destination;
            byte Source = 1;
            Destination = (_DestinationEnumType)Source;
            if (Destination == _DestinationEnumType.ValOne)
            Console.WriteLine("Pass");
        else
            Console.WriteLine("Fail");
        }
    }
}
`
Pass
`
public struct MyStruct1{
  public MyStruct1(variant v2){
    v1 = v2;
  }
  public variant v1;
}
public struct MyStruct2 {
  public MyStruct2(variant v2) {
    v1 = v2;
  }
  public variant v1;
  public static int Main(){
    MyStruct1 Test1 = new MyStruct1((byte)1);
    MyStruct2 Test2 = new MyStruct2(2f);
    if(Test1.v1 != (byte)1) {
      return 1;
    }    
    if(Test2.v1 != 2f) {
      return 1;
    }  
    return 0;
  }
}
`
(2,20): error CS0246: The type or namespace name 'variant' could not be found (are you missing a using directive or an assembly reference?)
`
using System;

namespace Tests {

public class Driver 
{
    public static void Main() 
    {

  decimal  source;
  int  dest;
  source = -2147483649;
  try {
    checked {
    dest = (int) source;
    }
  }
  catch {
    Console.WriteLine("Exception caught");
  }
        return;
    } 
}

}
`
(15,5): warning CS0219: The variable 'dest' is assigned but its value is never used
Exception caught
`
public struct C
{
        public class B
        {
                public class D
                {
                        public delegate void del();

                        public event del ev;
                }
                public D d;
        }
        public B b;
}

class A
{
        static void f1() {}

        public static int Main()
        {
                C c = new C();
                c.b = new C.B();
                c.b.d = new C.B.D();

                c.B.d.ev += new C.B.D.del(f1);  // CS0572
                C.b.D.ev += new C.B.D.del(f1);  // CS0572
                c.b.D.ev += new C.B.D.del(f1);  // CS0572
                c.B.D.ev += new C.B.D.del(f1);  // CS0572
                c.b.d.del = f1;  // CS0572

                return 1;
        }

}
`
(26,19): error CS0572: 'B': cannot reference a type through an expression; try 'C.B' instead
(27,17): error CS0120: An object reference is required for the nonstatic field, method, or property 'C.b'
(28,21): error CS0572: 'D': cannot reference a type through an expression; try 'C.B.D' instead
(29,19): error CS0572: 'B': cannot reference a type through an expression; try 'C.B' instead
(30,23): error CS0572: 'del': cannot reference a type through an expression; try 'C.B.D.del' instead
`
using System;

namespace Tests {

public class Driver 
{
    public static void Main() 
    {

  sbyte  source;
  byte  dest;
  source = -1;
  dest = (byte) source;

  if (dest == 255)
    Console.WriteLine("Pass");
  else
    Console.WriteLine("Fail");
        return;
    } 
}

}
`
Pass
`
using System;

interface MyInterface
{
  void myFunc();

  public static implicit operator int(MyInterface i) {}
}
`
(7,17): error CS0567: Interfaces cannot contain operators
`
using System;

class Conv
{

  private byte  value_byte;
  static public implicit operator byte(Conv test) {Console.WriteLine("To byte");return test.value_byte;}
  static public implicit operator Conv(byte val) {Console.WriteLine("From byte");Conv temp = new Conv(); temp.value_byte = val; return(temp);}
  public byte GetValuebyte() {return(value_byte);}
  public void SetValuebyte(byte val) {value_byte = val;}

  private char  value_char;
  static public implicit operator char(Conv test) {Console.WriteLine("To char");return test.value_char;}
  static public implicit operator Conv(char val) {Console.WriteLine("From char");Conv temp = new Conv(); temp.value_char = val; return(temp);}
  public char GetValuechar() {return(value_char);}
  public void SetValuechar(char val) {value_char = val;}

  private decimal  value_decimal;
  static public implicit operator decimal(Conv test) {Console.WriteLine("To decimal");return test.value_decimal;}
  static public implicit operator Conv(decimal val) {Console.WriteLine("From decimal");Conv temp = new Conv(); temp.value_decimal = val; return(temp);}
  public decimal GetValuedecimal() {return(value_decimal);}
  public void SetValuedecimal(decimal val) {value_decimal = val;}

  private double  value_double;
  static public implicit operator double(Conv test) {Console.WriteLine("To double");return test.value_double;}
  static public implicit operator Conv(double val) {Console.WriteLine("From double");Conv temp = new Conv(); temp.value_double = val; return(temp);}
  public double GetValuedouble() {return(value_double);}
  public void SetValuedouble(double val) {value_double = val;}

  private float  value_float;
  static public implicit operator float(Conv test) {Console.WriteLine("To float");return test.value_float;}
  static public implicit operator Conv(float val) {Console.WriteLine("From float");Conv temp = new Conv(); temp.value_float = val; return(temp);}
  public float GetValuefloat() {return(value_float);}
  public void SetValuefloat(float val) {value_float = val;}

  private int  value_int;
  static public implicit operator int(Conv test) {Console.WriteLine("To int");return test.value_int;}
  static public implicit operator Conv(int val) {Console.WriteLine("From int");Conv temp = new Conv(); temp.value_int = val; return(temp);}
  public int GetValueint() {return(value_int);}
  public void SetValueint(int val) {value_int = val;}

  private long  value_long;
  static public implicit operator long(Conv test) {Console.WriteLine("To long");return test.value_long;}
  static public implicit operator Conv(long val) {Console.WriteLine("From long");Conv temp = new Conv(); temp.value_long = val; return(temp);}
  public long GetValuelong() {return(value_long);}
  public void SetValuelong(long val) {value_long = val;}

  private sbyte  value_sbyte;
  static public implicit operator sbyte(Conv test) {Console.WriteLine("To sbyte");return test.value_sbyte;}
  static public implicit operator Conv(sbyte val) {Console.WriteLine("From sbyte");Conv temp = new Conv(); temp.value_sbyte = val; return(temp);}
  public sbyte GetValuesbyte() {return(value_sbyte);}
  public void SetValuesbyte(sbyte val) {value_sbyte = val;}

  private short  value_short;
  static public implicit operator short(Conv test) {Console.WriteLine("To short");return test.value_short;}
  static public implicit operator Conv(short val) {Console.WriteLine("From short");Conv temp = new Conv(); temp.value_short = val; return(temp);}
  public short GetValueshort() {return(value_short);}
  public void SetValueshort(short val) {value_short = val;}

  private uint  value_uint;
  static public implicit operator uint(Conv test) {Console.WriteLine("To uint");return test.value_uint;}
  static public implicit operator Conv(uint val) {Console.WriteLine("From uint");Conv temp = new Conv(); temp.value_uint = val; return(temp);}
  public uint GetValueuint() {return(value_uint);}
  public void SetValueuint(uint val) {value_uint = val;}

  private ulong  value_ulong;
  static public implicit operator ulong(Conv test) {Console.WriteLine("To ulong");return test.value_ulong;}
  static public implicit operator Conv(ulong val) {Console.WriteLine("From ulong");Conv temp = new Conv(); temp.value_ulong = val; return(temp);}
  public ulong GetValueulong() {return(value_ulong);}
  public void SetValueulong(ulong val) {value_ulong = val;}

  private ushort  value_ushort;
  static public implicit operator ushort(Conv test) {Console.WriteLine("To ushort");return test.value_ushort;}
  static public implicit operator Conv(ushort val) {Console.WriteLine("From ushort");Conv temp = new Conv(); temp.value_ushort = val; return(temp);}
  public ushort GetValueushort() {return(value_ushort);}
  public void SetValueushort(ushort val) {value_ushort = val;}
}
class Test
{
  public static void Main()
  {
    Conv cl = new Conv();
    byte val = 1;
    cl =  val;
    if (cl.GetValuebyte() != 1)
      Console.WriteLine("Fail");
    else
      Console.WriteLine("Pass");
  }
}
`
From byte
Pass
`
public class A
{
        public class B
        {
                public static implicit operator en(B aa)
                {
                        return (en)0;
                }

                public static implicit operator en(B aa)   // CS0557
                {
                        return (en)0;
                }
        }

        public enum en {}

        public static int Main() { return 1; }
}
`
(10,31): error CS0557: Duplicate user-defined conversion in class 'A.B'
(5,31): (Location of symbol related to previous error)
`
using System;
namespace Tests
{
    enum _DestinationEnumType : byte{ValOne = 1}

    public class Driver
    {
        public static void Main()
        {
            _DestinationEnumType Destination;
            decimal Source = 1;
            Destination = (_DestinationEnumType)Source;
            if (Destination == _DestinationEnumType.ValOne)
            Console.WriteLine("Pass");
        else
            Console.WriteLine("Fail");
        }
    }
}
`
Pass
`
using System;

class SBase 
{
}

class S : SBase
{
}

class SDer : S
{
}

class TBase 
{
}

class T : TBase
{
  static public explicit operator T(SDer foo)
  {
    Console.WriteLine("SDer to T <Dest> explicit");
    return new T();
  }
}

class TDer : T
{
}

class Convert
{
  public static void Main()
  {
    S s = new S();
    T t;

    try
    {
      t = (T) s;
    }
    catch (System.InvalidCastException)
    {
      Console.WriteLine("Exception Caught");
    }
  }
}
`
(41,7): warning CS0219: The variable 't' is assigned but its value is never used
Exception Caught
`
enum en {}

class test
{
   public static int Main()
   {
      en i = (en)-10.0;
      return 1;
   }
}
`
(7,15): error CS0118: 'en' is a 'class' but is used like a variable
(7,14): error CS0075: To cast a negative value, you must enclose the value in parentheses
`
using System;
namespace Tests
{
    enum _DestinationEnumType : long{ValOne = 1}

    public class Driver
    {
        public static void Main()
        {
            _DestinationEnumType Destination;
            double Source = 1;
            Destination = (_DestinationEnumType)Source;
            if (Destination == _DestinationEnumType.ValOne)
                Console.WriteLine("Pass");
            else
                Console.WriteLine("Fail");
        }
    }
}
`
Pass
`
public class A
{
        public class B
        {
                public static implicit operator int(B aa)
                {
                        return 0;
                }

                public static explicit operator int(B aa)   // CS0557
                {
                        return 0;
                }
      }

      public static int Main() { return 1; }
}
`
(10,31): error CS0557: Duplicate user-defined conversion in class 'A.B'
(5,31): (Location of symbol related to previous error)
`
using System;
enum ebyte : byte {}
public class Driver{
  public static void Main(){

    byte  source;
    ebyte  dest;
    source = (byte) (1);
    dest = (ebyte) source;

    if (dest.ToString().Equals(((object)(1)).ToString()))
      Console.WriteLine("Pass");
    else
      Console.WriteLine("Fail");
    return;
  } 
}
`
Pass
`
using System;

class SBase 
{
}

class S : SBase
{
}

class SDer : S
{
}

class TBase 
{
  static public implicit operator TBase(SBase foo)
  {
    Console.WriteLine("SBase to TBase <Dest> implicit");
    return new TBase();
  }
}

class T : TBase
{
}

class TDer : T
{
}

class Convert
{
  public static void Main()
  {
    S s = new S();
    T t;

    try
    {
      t = (T) s;
    }
    catch (System.InvalidCastException)
    {
      Console.WriteLine("Exception Caught");
    }
  }
}
`
(41,7): warning CS0219: The variable 't' is assigned but its value is never used
SBase to TBase <Dest> implicit
Exception Caught
`
using System;

public class Conv
{
  private byte  value;
  static public implicit operator byte(Conv test) {return test.value;}
  static public implicit operator Conv(byte val) {Conv temp = new Conv(); temp.value = val; return(temp);}
  public byte GetValue() {return(value);}
  public void SetValue(byte val) {value = val;}
}
class Test
{
  public static void Main()
  {
    Conv cl = new Conv();
    cl =  1;
    if (cl.GetValue() != 1)
      Console.WriteLine("Fail");
    else
      Console.WriteLine("Pass");
  }
}
`
Pass
`
using System;

enum ebyte : byte {}
enum esbyte : sbyte {}
enum eshort : short {}
enum eushort : ushort {}
enum eint : int {}
enum euint : uint {}
enum elong : long {}
enum eulong : ulong {}

namespace Tests {

public class Driver 
{
    public static void Main() 
    {

  decimal  source;
  esbyte  dest;
  source = (decimal) (-128);
  dest = (esbyte) source;

  if (dest.ToString().Equals(((object)(-128)).ToString()))
    Console.WriteLine("Pass");
  else
    Console.WriteLine("Fail");
        return;
    } 
}

}
`
Pass
`
using System;


namespace Tests {

  interface  I1
  {
    void  i();
  }

  sealed class C1
  {
  }

  class C2: I1
  {
    public void  i() {Console.WriteLine("C2.i");}
  }


  public class Driver 
  {
      public static void Main() 
      {
      I1  inter = new C2();

      try
      {
        C1  c1 = (C1) inter;
      }

      catch (System.InvalidCastException e)
      {
        Console.WriteLine("Exception Caught");
      }
      } 
  }
}
`
(29,18): error CS0030: Cannot convert type 'Tests.I1' to 'Tests.C1'
`
using System;

public class Conv
{
  private decimal  value;
  static public implicit operator decimal(Conv test) {return test.value;}
  static public implicit operator Conv(decimal val) {Conv temp = new Conv(); temp.value = val; return(temp);}
  public decimal GetValue() {return(value);}
  public void SetValue(decimal val) {value = val;}
}
class Test
{
  public static void Main()
  {
    Conv cl = new Conv();
    cl =  1;
    if (cl.GetValue() != 1)
      Console.WriteLine("Fail");
    else
      Console.WriteLine("Pass");
  }
}
`
Pass
`
using System;

public class Conv
{
  private decimal  value;
  static public implicit operator decimal(Conv test) {return test.value;}
  static public implicit operator Conv(decimal val) {Conv temp = new Conv(); temp.value = val; return(temp);}
  public decimal GetValue() {return(value);}
  public void SetValue(decimal val) {value = val;}
}
class Test
{
  public static void Main()
  {
    Conv cl = new Conv();
    cl = (Conv) 1;
    if (cl.GetValue() != 1)
      Console.WriteLine("Fail");
    else
      Console.WriteLine("Pass");
  }
}
`
Pass
`
using System;

class MyClass {

  public static int Main() {

    int test1 = 2;
    int test2 = ++test1++;
    
    return 1;
  }
}
`
(8,19): error CS0131: The left-hand side of an assignment must be a variable, property or indexer
`
public class MyClass {
  
  int intI;
  string strS;

  public string this[int i, string s] {
    get {
      return s + i;
    }
    set {
      intI = i;
      strS = s;
    }
  } 

  public static int Main() {
    MyClass test = new MyClass();
    test[2, "test"] = "?";
    if ((test[2, "test"] == "test2") && (test.intI == 2) && (test.strS == "test")) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
using System;

namespace Tests {

public class Driver 
{
    public static void Main() 
    {
      byte  source;
      decimal  dest;
      source = 1;
      dest = (decimal) source;

      if (dest == 1)
        Console.WriteLine("Pass");
      else
        Console.WriteLine("Fail");
      return;
   } 
}

}
`
Pass
`
namespace Microsoft.Conformance.Expressions {
  public class arith0015 {
    public static void Main()
    {
      int i1 = 1/0;
    }
  }
}
`
(5,16): error CS0020: Division by constant zero
`
using System;

public class MyClass {
  public static int Main() {

    ulong ul1 = 2;

    if ((ul1 * 0) == 0) {
      return 0;
    }
    else {
      return 1;
    }
  }  
}
`
`
using System;

public class MyClass {

  public static int Main() {
      
    checked{
      int intI = int.MinValue/-1;
    }
    
    return 1;
  }  
}
`
(8,18): error CS0220: The operation overflows at compile time
`
using System;

namespace Microsoft.Conformance.Expressions {

  namespace Test {
    public class TestClass {
      public int TestInt = 1;
    }
  }

  namespace Ident {

    using Test; //testing namespace identifier in enclosing namespace

    public class ident031 {
      public static int Main()
      {
        TestClass TC = new TestClass();
        if (TC.TestInt == 1) {
          return 0;
        }
        else {
          return 1;
        }
      }
    }    
  }
}
`
`
using System;

namespace Microsoft.Conformance.Expressions {

  public class TestClass {
    public int IntRet() {
      return 1;
    }
  }

  public class mem009 {

    public static void Main()
    {
      int MyInt = TestClass.IntRet(); //non static call should fail    
    }
  }
}
`
(15,19): error CS0120: An object reference is required for the nonstatic field, method, or property 'Microsoft.Conformance.Expressions.TestClass.IntRet()'
`
using System;

namespace Microsoft.Conformance.Expressions {

  public class TestClass {
    public int IntRet() {
      return 2;
    }
    public int IntRet(int IntI) {
      return IntI;
    }
  }

  public class mem023 {

    public static int Main()
    {
      int MyRet = 0;
      TestClass TC = new TestClass();
      if (new TestClass().IntRet() != 2) { //testing E.I
        MyRet = 1;
      }
      if (new TestClass().IntRet(3) != 3) { //testing E.I
        MyRet = 1;
      }
      return MyRet;
    }
  }
}
`
(19,17): warning CS0219: The variable 'TC' is assigned but its value is never used
`
using System;

namespace Microsoft.Conformance.Expressions {

  public struct TestClass {
    public TestClass(int intI){
      IntI = 0;
    }

    public readonly int IntI;
  }

  public class mem052 {

    public static int Main()
    {
      int RetInt = 1;

      RetInt = new TestClass(3).IntI; //testing E.I

      return RetInt;
    }
  }
}
`
`
using System;

namespace Microsoft.Conformance.Expressions {

  public struct TestClass {
    public TestClass(int intI) {
      IntI = 0;
    }

    public readonly int IntI;
  }

  public class mem041 {

    public static int Main()
    {
      int RetInt = 1;

      new TestClass(3).IntI = 3; //testing E.I

      return RetInt;
    }
  }
}
`
(19,7): error CS0191: A readonly field cannot be assigned to (except in a constructor or a variable initializer)
`
using System;

namespace Microsoft.Conformance.Expressions {

  public struct TestClass {
    public TestClass(int intI) {
      IntI = 0;
    }

    public int IntI;
  }

  public class mem057 {

    static TestClass TC = new TestClass(3);

    public static TestClass getTC {
      get {
        return TC;
      }
    }


    public static int Main()
    {
      TestClass TC = new TestClass(3);
      getTC.IntI = 3; //testing E.I

      if (TC.IntI == 3) { //shouldn't compile
        return 0;
      }
      else {
        return 1;
      }
    }
  }
}
`
(27,7): error CS1612: Cannot modify the return value of 'Microsoft.Conformance.Expressions.mem057.getTC' because it is not a variable
`
using System;

namespace Microsoft.Conformance.Expressions {

  public struct TestClass {
    public TestClass(int intI) {
      IntI = 0;
    }

    public int IntI;
  }

  public class mem059 {

    public static int Main()
    {
      new TestClass().IntI = 3; //shouldn't compile
      return 0;
    }
  }
}
`
(17,7): error CS0131: The left-hand side of an assignment must be a variable, property or indexer
`
using System;

namespace Microsoft.Conformance.Expressions {

  public class BaseClass {
    public int intI() {
      return 1;
    }
  }

  public class base001 : BaseClass {

    public static int Main()
    {
      int RetInt = 1;

      int intJ = base.intI(); //expecting error here

      return RetInt;
    }
  }
}
`
(17,18): error CS1511: Keyword base is not available in a static method
`
using System;

namespace Microsoft.Conformance.Expressions {

  public class BaseClass {
    public static int intI() {
      return 1;
    }
  }

  public class base002 : BaseClass {

    int intJ = base.intI(); //expecting error here

    public static int Main()
    {
      int RetInt = 1;

      return RetInt;
    }
  }
}
`
(13,16): error CS1512: Keyword base is not available in the current context
`
using System;

namespace Microsoft.Conformance.Expressions {

  public class BaseClass {
    private int intI() {
      return 1;
    }
  }

  public class base008 : BaseClass {

    public int TestInt() {
      return base.intI();
    }

    public static int Main()
    {
      return 1;    
    }
  }
}
`
(14,14): error CS0122: 'Microsoft.Conformance.Expressions.BaseClass.intI()' is inaccessible due to its protection level
`
using System;

namespace Microsoft.Conformance.Expressions {

  public class BaseClass {
    private int intI() {
      return 1;
    }
  }

  public class base008 : BaseClass {

    new public int intI() {
      return 2;
    }
    
    public static int Main()
    {
      return 0;    
    }
  }
}
`
(13,20): warning CS0109: The member 'Microsoft.Conformance.Expressions.base008.intI()' does not hide an inherited member. The new keyword is not required.
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
    char bits = (char)8;
    bits = (char)(bits << 1);
    if (bits != 16)
      return(1);
    bits = (char)(bits >> 1);
    if (bits != 8)
      return(1);

    return(0);
    }
}
`
`
using System;

public class Test
{
  public byte ub;
  public ushort ush;
  public uint uin;
  public ulong ulo;
  public char ch;
  

   public static int Main(string [] args)
      {

    Test T = new Test();
    
    T.ub = 0x01;
    T.ub <<= 7;
    if (T.ub != 0x80)
      return(1);
    T.ub >>= 7;
    if (T.ub != 0x01)
      return(1);

    T.ush = 0x01;
    T.ush <<= 15;
    if (T.ush != 0x8000) 
      return(1);
    T.ush >>= 15;
    if (T.ush != 0x01)
      return(1);

    T.uin = 0x01;
    T.uin <<= 31;
    if (T.uin != 0x80000000)
      return(1);
    T.uin >>= 31;
    if (T.uin != 0x01)
      return(1);

    T.ulo = 0x01;
    T.ulo <<= 63;
    if (T.ulo != 0x8000000000000000)
      return(1);
    T.ulo >>= 63;
    if (T.ulo != 0x01) {
      return(1);
    }

    T.ch = (char)0x01;
    T.ch <<= 15;
    if (T.ch != 0x8000) 
      return(1);
    T.ch >>= 15;
    if (T.ch != 0x01)
      return(1);

    return(0);
   }
}
`
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
    float bits = (float)8;
    bits = (float)(bits << 1);
    if (bits != 16)
      return(1);
    bits = (float)(bits >> 1);
    if (bits != 8)
      return(1);

    return(0);
    }
}
`
(8,20): error CS0019: Operator '<<' cannot be applied to operands of type 'float' and 'int'
(11,20): error CS0019: Operator '>>' cannot be applied to operands of type 'float' and 'int'
`
using System;

class MyClass {

  int intI = 2;

  public int this [int intJ] {
    get {
      return intI;
    }
    set {
      intI = value;      
    }
  }


  public static int Main() {

    MyClass MC1 = new MyClass();
    MyClass MC2 = new MyClass();

    ++MC1[0];
    --MC2[0];

    if ((MC1[0] == 3) && (MC2[0] == 1)) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
using System;

class MyClass {

  int intI;

  public int MyInt {
    get {
      return intI;
    }

  }


  public static int Main() {

    MyClass MC1 = new MyClass();
    ++MC1.MyInt;
    return 1;
  }
}
`
(18,7): error CS0200: Property or indexer 'MyClass.MyInt' cannot be assigned to -- it is read only
`
using System;

class MyClass {

  int intI = 2;

  public int this [int intJ] {
    set {
      intI = value;      
    }
  }


  public static int Main() {

    MyClass MC1 = new MyClass();
    ++MC1[0];

    return 1;
  }
}
`
(17,7): error CS0154: The property or indexer 'MyClass.this[int]' cannot be used in this context because it lacks the get accessor
`
using System;

class MyClass {

  public static int Main() {

    string s = "MyString";
    s++;
    
    return 1;
  }
}
`
(8,5): error CS0187: No such operator '++' defined for type 'string'
`
public class MyClass {

  public static implicit operator string(MyClass MC) {
    return "MyClass1";
  }

  public static int Main() {

    MyClass MC = new MyClass();
    string TestString1 = "MyClass1";
    string TestString2 = "MyClass2";

    if ((MC == TestString1) && (MC != TestString2)) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
class MyClass {

  public static int Main() {
    bool b1 = true;
    bool b2 = true;
    bool b3 = false;
    bool b4 = false;
    if (!(b1 ^ b2) && (b1 ^ b3) && (b4 ^ b2) && !(b3 ^ b4)) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
class MyClass {

  static int i1 = 2;
  static int i2 = 3;

  public static int Main() {
    int i = (i1 && i2);
    return 1;
  }
}
`
(7,14): error CS0019: Operator '&&' cannot be applied to operands of type 'int' and 'int'
`
using System;

namespace Microsoft.Conformance.Expressions {

  enum AA {a = 1, b = 2}

  public class arith023 {
    public static int Main()
    {
      int MyInt = AA.a - AA.b; //E-E

      if (MyInt == -1) {
        return 0;
      }
      else {
        return 1;
      }      
    }
  }
}
`
`
using System;

public class MyClass {

  public static int Main() {
    object o = 5 as object;
    if ((int)o == 5)
    {
      return 0;
    }
    else 
    {
      return 1;
    }
  }

}
`
`
using System;

enum MyEnum : byte {}

public class MyClass {
  public static int Main() {

    byte b1 = 2;
    byte b2 = 3;

    bool b = (b1 == (MyEnum)b2);

    return 1;
  }
}
`
(11,15): error CS0019: Operator '==' cannot be applied to operands of type 'byte' and 'MyEnum'
`
using System;
public class MyClass 
{
  public static int Main() 
  {
  {
    sbyte a = 0x01; sbyte b = 0x02;
    if(( a^b & a|b) != ( a | b & a^b))
      return 1;
    if((a ^ a ^ a | a ^ b) != 0x03)
      return 1;
  }
  {
    short a = 0x01; short b = 0x02;
    if(( a^b & a|b) != ( a | b & a^b))
      return 1;
    if((a ^ a ^ a | a ^ b) != 0x03)
      return 1;
  }
  {
    int a = 0x01; int b = 0x02;
    if(( a^b & a|b) != ( a | b & a^b))
      return 1;
    if((a ^ a ^ a | a ^ b) != 0x03)
      return 1;
  }
  {
    long a = 0x01; long b = 0x02;
    if(( a^b & a|b) != ( a | b & a^b))
      return 1;
    if((a ^ a ^ a | a ^ b) != 0x03)
      return 1;
  }
  {
    byte a = 0x01; byte b = 0x02;
    if(( a^b & a|b) != ( a | b & a^b))
      return 1;
    if((a ^ a ^ a | a ^ b) != 0x03)
      return 1;
  }
  {
    ushort a = 0x01; ushort b = 0x02;
    if(( a^b & a|b) != ( a | b & a^b))
      return 1;
    if((a ^ a ^ a | a ^ b) != 0x03)
      return 1;
  }
  {
    uint a = 0x01; uint b = 0x02;
    if(( a^b & a|b) != ( a | b & a^b))
      return 1;
    if((a ^ a ^ a | a ^ b) != 0x03)
      return 1;
  }
  {
    ulong a = 0x01; ulong b = 0x02;
    if(( a^b & a|b) != ( a | b & a^b))
      return 1;
    if((a ^ a ^ a | a ^ b) != 0x03)
      return 1;
  }

  {
    char a = (char)0x01; char b = (char)0x02;
    if(( a^b & a|b) != ( a | b & a^b))
      return 1;
    if((a ^ a ^ a | a ^ b) != 0x03)
      return 1;
  }


    return 0;
  }
}
`
(8,10): warning CS0675: Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first
(8,26): warning CS0675: Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first
(15,10): warning CS0675: Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first
(15,26): warning CS0675: Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first
`
using System;

public class MyClass 
{
  public static int Main() 
  {
  {
    float a = 0x01; float b = 0x02;
    if(( a^b & a|b) != ( a | b & a^b))
      return 1;
    if((a ^ a ^ a | a ^ b) != 0x03)
      return 1;
  }
  {
    double a = 0x01; double b = 0x02;
    if(( a^b & a|b) != ( a | b & a^b))
      return 1;
    if((a ^ a ^ a | a ^ b) != 0x03)
      return 1;
  }

  {
    decimal a = 0x01; decimal b = 0x02;
    if(( a^b & a|b) != ( a | b & a^b))
      return 1;
    if((a ^ a ^ a | a ^ b) != 0x03)
      return 1;
  }

    return 1;
  }  
}
`
(9,12): error CS0019: Operator '&' cannot be applied to operands of type 'float' and 'float'
(9,30): error CS0019: Operator '&' cannot be applied to operands of type 'float' and 'float'
(11,9): error CS0019: Operator '^' cannot be applied to operands of type 'float' and 'float'
(11,21): error CS0019: Operator '^' cannot be applied to operands of type 'float' and 'float'
(16,12): error CS0019: Operator '&' cannot be applied to operands of type 'double' and 'double'
(16,30): error CS0019: Operator '&' cannot be applied to operands of type 'double' and 'double'
(18,9): error CS0019: Operator '^' cannot be applied to operands of type 'double' and 'double'
(18,21): error CS0019: Operator '^' cannot be applied to operands of type 'double' and 'double'
(24,12): error CS0019: Operator '&' cannot be applied to operands of type 'decimal' and 'decimal'
(24,30): error CS0019: Operator '&' cannot be applied to operands of type 'decimal' and 'decimal'
(26,9): error CS0019: Operator '^' cannot be applied to operands of type 'decimal' and 'decimal'
(26,21): error CS0019: Operator '^' cannot be applied to operands of type 'decimal' and 'decimal'
`
class MyTest {
  public static explicit operator bool (MyTest t) {
    return true;
  }
}

class MyClass {

  public static int Main() {
    MyTest t = new MyTest();
    int intI = t?2:3;
    return 1;
  }
}
`
(11,16): error CS0029: Cannot implicitly convert type 'MyTest' to 'bool'
`
interface MyInter {
  int RetInt();
}

class MyTest1 : MyInter{

  public static implicit operator MyTest2(MyTest1 t) {
    return new MyTest2();
  }

  public int RetInt() {
    return 1;
  }
}

class MyTest2 : MyInter{
  public int RetInt() {
    return 2;
  }
}

class MyClass {

  public static int Main() {
    bool b = true;
    MyTest1 t1 = new MyTest1();
    MyTest2 t2 = new MyTest2();
    MyInter test = b?t1:t2;
    if (test.RetInt() == 2) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
interface MyInter {
  int RetInt();
}

class MyTest1 : MyInter{

  public static implicit operator MyTest2(MyTest1 t) {
    return new MyTest2();
  }

  public int RetInt() {
    return 1;
  }
}

class MyTest2 : MyInter{

  public static implicit operator MyTest1(MyTest2 t) {
    return new MyTest1();
  }

  public int RetInt() {
    return 2;
  }
}

class MyClass {

  public static int Main() {
    bool b = false;
    MyTest1 t1 = new MyTest1();
    MyTest2 t2 = new MyTest2();
    MyInter test = b?t1:t2;
    return 1;
  }
}
`
(33,20): error CS0172: Type of conditional expression can't be determined because 'MyTest1' and 'MyTest2' both implicitly convert to each other
`
public class Test
{
  public Test()
  {}

  public static void foo(){}

  public static int Main()
  {
    int b  = (Test()) ? 0 : 1;
    int bb = (foo()) ? 0 : 1;
    return 1;
  }
}
`
(10,15): error CS0119: 'Test' denotes a 'class' which is not valid in the given context
(11,15): error CS0029: Cannot implicitly convert type 'void' to 'bool'
`
using System;

public class TestType {}

public class MyClass {

  public static int Main() {
    bool b = TestType is TestType;
    return 1;
  }

}
`
(8,14): error CS0118: 'TestType' is a 'class' but is used like a variable
`
using System;

public class MyTest1 {

  public static implicit operator MyTest2(MyTest1 m) {
    return new MyTest2();
  }   

}

public class MyTest2 {}

public class MyClass {

  public static int Main() {
    MyTest1 mt = new MyTest1();
    bool b = mt is MyTest2;
    return 0;
  }

}
`
(17,14): warning CS0184: The given expression is never of the provided ('MyTest2') type
(16,13): warning CS0219: The variable 'mt' is assigned but its value is never used
(17,10): warning CS0219: The variable 'b' is assigned but its value is never used
`
using System;

namespace Microsoft.Conformance.Expressions {

  public struct base017 {

    override public String ToString() {
      return "foobar";
    }

    public String GetStr() {
      return base.ToString();
    }

    public static int Main()
    {
      base017 TC = new base017();
      if (TC.GetStr().Equals("Microsoft.Conformance.Expressions.base017")) {
        return 0;
      }
      else {
        return 1;
      }    
    }
  }
}
`
`
using System;

class MyClass {

  public static int Main() {

    char test1 = (char)2;
    char test2 = (char)2;
    ++test1;
    --test2;
    if ((test1 == 3) && (test2 == 1)) {
      return 0;
    }
    else {
      return 1;
    } 
  }
}
`
`
using System;

namespace Microsoft.Conformance.Expressions {

  enum AA {a = 1, b = 2}

  public class arith022 {
    public static int Main()
    {
      AA MyEnum = AA.a + AA.b; //E+E

      if ((int)MyEnum == 3) {
        return 0;
      }
      else {
        return 1;
      }      
    }
  }
}
`
(10,19): error CS0019: Operator '+' cannot be applied to operands of type 'Microsoft.Conformance.Expressions.AA' and 'Microsoft.Conformance.Expressions.AA'
`
using System;

public class MyClass {
  public static int Main() {

    ulong ul1 = 2;

    if ((0.0 / ul1) == 0) {
      return 0;
    }
    else {
      return 1;
    }
  }  
}
`
`
using System;

public class MyClass {

  public static int Main() {
      
    string s1 = null + "foo";

    if (s1 == "foo") {
      return 0;
    }
    else {
      return 1;
    }
  }  
}
`
`
using System;

namespace Microsoft.Conformance.Expressions {

  public struct TestClass {
    public int IntRet() {
      return 1;
    }
  }

  public class mem010 {

    public static void Main()
    {
      int MyInt = TestClass.IntRet(); //non static call should fail    
    }
  }
}
`
(15,19): error CS0120: An object reference is required for the nonstatic field, method, or property 'Microsoft.Conformance.Expressions.TestClass.IntRet()'
`
using System;

namespace Microsoft.Conformance.Expressions {
  public class lit011 {

    public static int Main()
    {
      string s = "This is an expression test";
      object o = s;

      bool b = o == s;
      bool bb = s == o;
      
      if(b && bb)
        return 0;
      else
        return 1;

    }
  }
}
`
(11,16): warning CS0252: Possible unintended reference comparison; to get a value comparison, cast the left hand side to type 'string'
(12,17): warning CS0253: Possible unintended reference comparison; to get a value comparison, cast the right hand side to type 'string'
`
using System;

public class MyClass{

  public static int Main() {

    long l1 = 2;    
    long lngL = 3 >> l1;
    return 1;
  }
}
`
(8,17): error CS0019: Operator '>>' cannot be applied to operands of type 'int' and 'long'
`
using System;

public class Test
{
  public byte ub;
  public ushort ush;
  public uint uin;
  public ulong ulo;
  public char ch;
  

   public static int Main(string [] args)
      {

    Test T = new Test();
    
    T.ub = 0x01;
    T.ub = (byte)(T.ub << 7);
    if (T.ub != 0x80)
      return(1);
    T.ub = (byte)(T.ub >> 7);
    if (T.ub != 0x01)
      return(1);

    T.ush = 0x01;
    T.ush = (ushort)(T.ush << 15);
    if (T.ush != 0x8000) 
      return(1);
    T.ush = (ushort)(T.ush >> 15);
    if (T.ush != 0x01)
      return(1);

    T.uin = 0x01;
    T.uin = T.uin << 31;
    if (T.uin != 0x80000000)
      return(1);
    T.uin = T.uin >> 31;
    if (T.uin != 0x01)
      return(1);

    T.ulo = 0x01;
    T.ulo = T.ulo << 63;
    if (T.ulo != 0x8000000000000000)
      return(1);
    T.ulo = T.ulo >> 63;
    if (T.ulo != 0x01) {
      return(1);
    }

    T.ch = (char)0x01;
    T.ch = (char)(T.ch << 15);
    if (T.ch != 0x8000) 
      return(1);
    T.ch = (char)(T.ch >> 15);
    if (T.ch != 0x01)
      return(1);

    return(0);
   }
}
`
`
using System;

class MyClass {

  int intI = 2;

  public int this [int intJ] {
    get {
      return intI;
    }
  }

  public static int Main() {
    MyClass MC1 = new MyClass();
    ++MC1[0];
    return 1;
  }
}
`
(15,7): error CS0200: Property or indexer 'MyClass.this[int]' cannot be assigned to -- it is read only
`
using System;

public class A
{
  private int i;

  public int I
  {
    get { return i;}
    set { i = value; }    
  }

  public static A operator ++(A a)
  {
    a.i++;
    return a; 
  }

  public static A operator --(A a)
  {
    a.i--;
    return a;
  }

  public static int Main()
  {
        A a = new A();
    
    for(a.I = 0; a.I < 10 ; a++);
    for(; a.I >-1 ; a--);

    for(; a.I < 10 ; ++a);
    for(; a.I >0 ; --a);


    return a.I;
  }
}
`
`
using System;

public class A
{
  public static A operator !(int i)
  {
    return new A();
  }

  public static A operator +(int i)
  {
    return new A();
  }

  public static A operator -(int i)
  {
    return new A();
  }

  public static A operator ~(int i)
  {
    return new A();
  }

  public static int Main()
  {
    return 1;
  }
}
`
(5,19): error CS0562: The parameter of a unary operator must be the containing type
(10,19): error CS0562: The parameter of a unary operator must be the containing type
(15,19): error CS0562: The parameter of a unary operator must be the containing type
(20,19): error CS0562: The parameter of a unary operator must be the containing type
`
using System;
public class A
{
  public static operator ++ A(A i)
  {
    return new A();
  }

  public static operator -- A(A i)
  {
    return new A();
  }

  public static operator ! A(A i)
  {
    return new A();
  }

  public static operator + A(A i)
  {
    return new A();
  }

  public static operator -A(A i)
  {
    return new A();
  }

  public static operator ~A(A i)
  {
    return new A();
  }


  public static int Main()
  {
    return 1;
  }
}
`
(4,29): error CS1554: Declaration is not valid; use '<type> operator ++ (...' instead
(9,29): error CS1554: Declaration is not valid; use '<type> operator -- (...' instead
(14,28): error CS1554: Declaration is not valid; use '<type> operator ! (...' instead
(19,28): error CS1554: Declaration is not valid; use '<type> operator + (...' instead
(24,27): error CS1554: Declaration is not valid; use '<type> operator - (...' instead
(29,27): error CS1554: Declaration is not valid; use '<type> operator ~ (...' instead
`
class MyClass {

  public static int Main() {
    float f1 = 2.0f;
    float f2 = float.NaN;
    double d1 = 2.0;
    double d2 = double.NaN;

    if (f1 < f2) {
      return 1;
    }
    if (f2 < f2) {
      return 1;
    }
    if (d1 < d2) {
      return 1;
    }
    if (d2 < d2) {
      return 1;
    }  
    return 0;
  }
}
`
`
public class A {}
public class B {}

class MyClass {
  public static int Main() {
    A t1 = new A();
    B t2 = new B();
    bool b = (t1 == t2);
    return 1;
  }
}
`
(8,15): error CS0019: Operator '==' cannot be applied to operands of type 'A' and 'B'
`
class MyTest {

  public MyTest(int i) {
    intI = i;
  }    

  public int intI;

  public static bool operator == (MyTest t1, MyTest t2) {
    if (t1.intI == t2.intI) {
      return true;
    }
    else {
      return false;
    }
  }

  public static bool operator != (MyTest t1, MyTest t2) {
    if (t1.intI != t2.intI) {
      return true;
    }
    else {
      return false;
    }
  }

}

class MyClass {
  public static int Main() {
    MyTest s = new MyTest(1);
    MyTest t = new MyTest(1);
    if ((s == t) && !((object)s == t) && !(s == (object)t) && !((object) s == (object) t)) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
(1,7): warning CS0660: 'MyTest' defines operator == or operator != but does not override Object.Equals(object o)
(1,7): warning CS0661: 'MyTest' defines operator == or operator != but does not override Object.GetHashCode()
(33,23): warning CS0252: Possible unintended reference comparison; to get a value comparison, cast the left hand side to type 'MyTest'
(33,44): warning CS0253: Possible unintended reference comparison; to get a value comparison, cast the right hand side to type 'MyTest'
`
public class MyClass {

  const string s1 = null;
  const string s2 = null;

  public static int Main() {

    if ((s1 == s2) && !(s1 != s2)) {
      return 0;
    }  
    else {
      return 1;
    }
  }
}
`
`
public class MyClass 
{

  public static string implicit operator (MyClass MC) 
  {
    return "MyClass1";
  }

  public static MyClass operator implicit (MyClass MC) 
  {
    return "MyClass1";
  }

  public static int Main() 
  {
    return 1;
  }
}
`
(4,24): error CS1553: Declaration is not valid; use 'implicit operator <dest-type> (...' instead
(9,25): error CS1553: Declaration is not valid; use 'implicit operator <dest-type> (...' instead
(9,25): error CS0555: User-defined operator cannot take an object of the enclosing type and convert to an object of the enclosing type
(11,12): error CS0029: Cannot implicitly convert type 'string' to 'MyClass'
`
class MyClass {

  public static object operator & (MyClass t1, MyClass t2) {
    return new MyClass();
  }

  public static bool operator true (MyClass t1) {
    return true;
  }
  
  public static bool operator false (MyClass t1) {
    return false;
  }

  public static int Main() {
    MyClass test1 = new MyClass();
    MyClass test2 = new MyClass();

    if (test1 && test2) {
      return 0;

    }
    else {
      return 1;
    }
  }

}
`
(19,9): error CS0217: In order to be applicable as a short circuit operator a user-defined logical operator ('MyClass.operator &(MyClass, MyClass)') must have the same return type as the type of its 2 parameters.
`
class MyClass {

  public static MyClass operator & (MyClass t1, MyClass t2) {
    return new MyClass();
  }

  public static int Main() {
    MyClass test1 = new MyClass();
    MyClass test2 = new MyClass();

    if (test1 && test2) {
      return 0;

    }
    else {
      return 1;
    }
  }

}
`
(11,9): error CS0218: The type ('MyClass') must contain declarations of operator true and operator false
`
class MyClass {

  public static MyClass operator & (MyClass t1, MyClass t2) {
    return new MyClass();
  }

  public static bool operator true (MyClass t1) {
    return true;
  }
  
  public static bool operator false (MyClass t1) {
    return false;
  }

  public static int Main() {
    MyClass test1 = new MyClass();
    MyClass test2 = new MyClass();

    if (test1 && test2) {
      return 0;

    }
    else {
      return 1;
    }
  }

}
`
`
using System;

enum Visibility {
  None,
  Visible,
  Hidden
}

class Test
{
  Visibility Visibility;
  
  public static void Main() {
     Visibility v = Visibility.Visible;
     Console.WriteLine(v.ToString());
     v = (Visibility)Visibility.Parse(typeof(Visibility), "Hidden");
     Console.WriteLine(v.ToString());
  }
}
`
Visible
Hidden
`
class MyClass {

  public bool Test() {
    int intI = 1;
    string strS = "test";
    if ((intI == 1) && (strS == "test")) {
      return true;
    }
    else {
      return false;
    }
  }

  public static int Main() {
    int intI = 2;
    string strS = "test2";    
    if ((intI != 2) || (strS != "test2")) {
      return 1;
    }
    for (intI = 1; intI < 3; intI++) {
      int intI2 = 3;
      string strS2 = "test3";
      if ((intI2 != 3) || (strS2 != "test3")) {
        return 1;
      }
    }

    {
      int intI3 = 4;
      string strS3 = "test4";
      if ((intI3 != 4) || (strS3 != "test4")) {
        return 1;
      }
    }

    MyClass TC = new MyClass();
    if (TC.Test() == true) {
      return 0;
    }
    else {
      return 1;
    }
  }

}
`
`
public class MyClass {

  public static implicit operator string(MyClass MC) {
    return "foo";
  }

  public static int Main() {

    MyClass MC = new MyClass();

    string TestString1 = "bar";


    if ((MC + TestString1) == "foobar") {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
using System;

namespace Microsoft.Conformance.Expressions {

  namespace Test {
    public class TestClass {
      public int TestInt = 1;
    }
  }

  namespace Ident {

    using TestClass = Test.TestClass;

    public class ident032 {
      public static int Main()
      {
        TestClass TC = new TestClass(); //identifier refers to imported type
        if (TC.TestInt == 1) {
          return 0;
        }
        else {
          return 1;
        }
      }
    }    
  }
}
`
`
using System;

public class A
{
  public static A operator ++(int i)
  {
    return new A();
  }
  public static int Main()
  {
    return 1;
  }
}
`
(5,19): error CS0559: The parameter and return type for ++ or -- operator must be the containing type
`
struct MyStruct{}

class MyClass {
  public static int Main() {
    MyStruct t1 = new MyStruct();
    MyStruct t2 = new MyStruct();
    bool b = (t1 == t2);
    return 1;
  }
}
`
(7,15): error CS0019: Operator '==' cannot be applied to operands of type 'MyStruct' and 'MyStruct'
`
public class MyClass {

  const decimal d1 = 2.0m;
  const decimal d2 = 2.0m;
  const decimal d3 = 3.0m;

  public static int Main() {

    if (!(d1 == d2)) return 1;
    if ((d1 == d3)) return 1;
    if ((d1 != d2)) return 1;
    if (!(d1 != d3)) return 1;
    if (d1 > d2) return 1;
    if (!(d3 > d1)) return 1;
    if (d1 > d3) return 1;
    if (d1 < d2) return 1;
    if (!(d1 < d3)) return 1;
    if (d3 < d1) return 1;
    if (!(d1 >= d2)) return 1;
    if (!(d3 >= d1)) return 1;
    if (d1 >= d3) return 1;
    if (!(d1 <= d2)) return 1;
    if (!(d1 <= d3)) return 1;
    if (d3 <= d1) return 1;
      
    return 0;
  }
}
`
`
class MyTest  {}

class MyClass {

  public static MyClass operator & (MyClass t1, MyTest t2) {
    return new MyClass();
  }

  public static bool operator true (MyClass t1) {
    return true;
  }
  
  public static bool operator false (MyClass t1) {
    return false;
  }

  public static int Main() {
    MyClass test1 = new MyClass();
    MyTest test2 = new MyTest();

    if (test1 && test2) {
      return 0;

    }
    else {
      return 1;
    }
  }

}
`
(21,9): error CS0217: In order to be applicable as a short circuit operator a user-defined logical operator ('MyClass.operator &(MyClass, MyTest)') must have the same return type as the type of its 2 parameters.
`
using System;

public class MyClass {

  public static int Main() {
    bool b = string is string;
    return 1;
  }

}
`
(6,14): error CS0118: 'string' is a 'class' but is used like a variable
`
using System;
using System.IO;

namespace Microsoft.Conformance.Expressions {

  namespace Test {
    public class TestClass {
      public int TestInt = 1;
    }
  }

  namespace Test2 {
    public class TestClass {
      public int TestInt = 2;
    }
  }


  namespace Outer {

    using TestClass = Test2.TestClass;
    using Test;

    namespace Ident {

      public class ident039 {
        public static int Main()
        {
          TestClass TC = new TestClass(); //identifier refers to type in imported type
          if (TC.TestInt == 2) {
            return 0;
          }
          else {
            Console.WriteLine("TC.TestInt=={0}", TC.TestInt);
            return 1;
          }
        }
      }    
    }
  }
}
`
`
class Test{
  
  static void Main() {
    while (true)
      int i = 44;
  }
}  
`
(5,7): error CS1023: Embedded statement cannot be a declaration or labeled statement
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
  int status = 0;

  // empty series
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  int i;
  i = 0;
  i++;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  // empty hanging clause
  if (args != null)
    ;
  else {
    status = 1;
  }

  while (false)
    ;

  do ; while(false);
    
  switch (status) {
    default: break;
  }

  for (;false;) 
    ;

Label: ;
        return(status);

    }
}
`
(18,5): warning CS0642: Possible mistaken null statement
(26,6): warning CS0642: Possible mistaken null statement
(35,1): warning CS0164: This label has not been referenced
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
      true;
      return(0);
    }
}
`
(7,7): error CS0201: Only assignment, call, increment, decrement, and new object expressions can be used as a statement
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
      int ret = 1;

      int value = 23;
      int test = 23;

      switch (value) {
        case test:
          ret = 1;
          break;
        default:
          ret = 1;
          break;
      }

      return(ret);
    }
}
`
(13,14): error CS0150: A constant value is expected
`
using System;

public class Test
{
    public static int Main(string [] args)
    {int i = 5;
    switch (i) {
    case 5: 
      switch (i) {
      case 1:
        goto case 5;
      }
      break;
    }

    return(0);
    }
}
`
(11,9): error CS0159: No such label 'case 5:' within the scope of the goto statement
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
    int ret = 0;
    ret = DoLong();
        return(ret);
    }

  private static int DoLong()
  {
    int ret = 2;
    long l = 0x7fffffffffffffffL;

    switch (l) {
    case 1L:
    case 9223372036854775807L:
      ret--;
      break;
    case -1L:
      break;
    default:
      break;
    }

    switch (l) {
    case 1L:
    case -1L:
      break;
    default:
      ret--;
             break;
    }

    if (ret > 0)
      Console.WriteLine("long failed");
    return(ret);
  }
  
}
`
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
      decimal d = 5.0m;

      switch (d) {
      default:
        break;
      }
      return 1;
    }
}
`
(9,15): error CS0151: A value of an integral type expected
`
using System;

public class Test
{
  public static int Main(string [] args)
  {
    int i = 5;

    switch (i)
    {
      case 1.2f:
        return 1;
    }
    return 0;
  }
}
`
(11,12): error CS0029: Cannot implicitly convert type 'float' to 'int'
`
using System;

public class Test
{
  public static int Main(string [] args)
  {
    int i = 5;

    switch (i)
    {
      case 1:
      case 2:
      case 3:
        return 1;
      case 1001:
      case 1002:
      case 1003:
        return 2;
    }
    return 0;
  }
}
`
`
class Conv
{

  public static implicit operator char (Conv C)
  {
    return 'x';
  }
  
  public static implicit operator int (Conv C)
  {
    return 1;
  }

  public static int Main()
  {
    Conv C = new Conv();
    switch(C)
    {
    default: return 1;
    }
  }    
}
`
(17,12): error CS0151: A value of an integral type expected
`
class A
{
   public static int Main()
   {
      int i = 6;

      switch(i) {}   // CS1522

      return 0;
   }
}
`
(7,18): warning CS1522: Empty switch block
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
      for (;;)
        return(0);
      return(1);
    }
}
`
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
    for (int i = 0;;i < 10)
      if (i++ >= 10)
        return(0);

        return(1);
    }
}
`
(7,21): error CS0201: Only assignment, call, increment, decrement, and new object expressions can be used as a statement
`
using System;
using System.Collections;

public class MyCollection: IEnumerable
{
  int[]  items;

  public MyCollection()
  {
    items = new int[5] {1, 4, 3, 2, 5};
  }

  public MyEnumerator GetEnumerator()
  {
    return new MyEnumerator(this);
  }

  IEnumerator IEnumerable.GetEnumerator() {
        return GetEnumerator();
    }
 
  public class MyEnumerator: IEnumerator
  {
    int        nIndex;
    MyCollection  collection;

    public MyEnumerator(MyCollection coll)
    {
      collection = coll;
      nIndex = -1;
    }
    public bool MoveNext()
    {
      nIndex++;
      return(nIndex < collection.items.GetLength(0));
    }

    public void Reset()
    {
      nIndex = -1;
    }

    public int Current
    {
      get
      {
        return(collection.items[nIndex]);
      }
    }

    object IEnumerator.Current
    {
      get
      {
        return(Current);
      }
    }
  }
}
  
public class Test
{
    public static int Main(string [] args)
    {
    MyCollection  col = new MyCollection();

    foreach (int i in col)
    {
      Console.WriteLine("Value: " + i);
    }

        return(0);
    }
}
`
Value: 1
Value: 4
Value: 3
Value: 2
Value: 5
`
class MyClass
{
  public static int Main()
  {
    int[] myarray = new int[3] {1,2,3};
    foreach (int o myarray) {}
    return 1;
  }
}
`
(6,20): error CS1515: 'in' expected
`
class MyClass
{
  public static int Main()
  {
    int[] myarray = new int[3] {1,2,3};
    foreach (int in myarray) {}
    return 1;
  }
}
`
(6,18): error CS0230: Type and identifier are both required in a foreach statement
`
using System;
using System.Collections;

public class MyCollection
{
  int[]  items;

  public MyCollection()
  {
    items = new int[5] {1, 4, 3, 2, 5};
  }

  public class MyEnumerator
  {
    int        nIndex;
    MyCollection  collection;

    public MyEnumerator(MyCollection coll)
    {
      collection = coll;
      nIndex = -1;
    }
    public bool MoveNext()
    {
      nIndex++;
      return(nIndex < collection.items.GetLength(0));
    }
    public int Current
    {
      get
      {
        return(collection.items[nIndex]);
      }
    }
  }
}
  
public class Test
{
    public static int Main(string [] args)
    {
    MyCollection  col = new MyCollection();

    foreach (int i in col)
    {
      Console.WriteLine("Value: " + i);
    }

        return(0);
    }
}
`
(44,23): error CS1579: foreach statement cannot operate on variables of type 'MyCollection' because 'MyCollection' does not contain a public definition for 'GetEnumerator'
`
using System;
using System.Collections;

class T
{
static void Main() {
      ArrayList list = new ArrayList();

      list.Add("One");
      list.Add("Two");

      foreach (string s in list) {
          s = "a";  
      }
   }
}
`
(13,11): error CS1604: Cannot assign to 's' because it is read-only
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
      int ret = 1;
      if (true)
        break;
      return(ret);
    }
}
`
(9,9): error CS0139: No enclosing loop out of which to break or continue
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
    int i = 5;
    int ret = 0;

    Console.WriteLine("Doing while");
    while (--i != 0)
      continue;

    if (i != 0)
      return(1);

    Console.WriteLine("Doing do/while");
    i = 5;
    do
      continue;
    while (--i != 0);

    if (i != 0)
      return(1);


    Console.WriteLine("Doing for");
    for (i = 5; i != 0 ; i--)
      continue;

    int [] iArr = new int[20];
    foreach (int i2 in iArr)
      continue;

        return(ret);
    }
}
`
(32,18): warning CS0219: The variable 'i2' is assigned but its value is never used
Doing while
Doing do/while
Doing for
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
      goto default;
      return(1);
    }
}
`
(7,7): error CS0153: A goto case is only valid inside a switch statement
`
using System;

public class Test
{
  public static int Main(string [] args)
  { 
    string target = "t1";

    switch(target)
    {
      label1:
        case "t1":
         goto label1;

    }

    return 0; 
  }

}
`
(11,7): error CS1523: The keyword case or default must precede code in switch block
(11,13): error CS1002: ; expected
(13,15): error CS0159: No such label 'label1' within the scope of the goto statement
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
      Test.sMethod();
      Test t = new Test();
      t.Method();

      return(0);
    }

  private static string sMethod() {
    return(1);
  }

  private int Method() {
    return("string");
  }
}
`
(15,12): error CS0029: Cannot implicitly convert type 'int' to 'string'
(19,12): error CS0029: Cannot implicitly convert type 'string' to 'int'
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
    Test.sMethod();
    Test t = new Test();
    t.Method();

    return(0);
    }

  private static void sMethod() {
    return(23);
  }

  private void Method() {
    return(32);
  }
}
`
(15,12): error CS0127: Since 'Test.sMethod()' returns void, a return keyword must not be followed by an object expression
(19,12): error CS0127: Since 'Test.Method()' returns void, a return keyword must not be followed by an object expression
`
using System;

public class Test
{
    public static void Main(string [] args)
    {
    }

  private static int sMethod() {
    try {
      throw new ApplicationException();
    } catch(ApplicationException) {
      return(0);
    }
    return(1);
  }

  private int Method() {
    try {
      throw new ApplicationException();
    } catch(ApplicationException) {
      return(0);
    }
    return(1);
  }
}
`
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
      int i;
      i = Test.sMethod();

      return(i == 0 ? 0 : 1);
    }

  private static int sMethod() {
    try {
      throw 23;
    } catch(ApplicationException e) {
      return(2);
    }
    return(1);
  }
}
`
(15,13): error CS0155: The type caught or thrown must be derived from System.Exception
`
using System;

public class Test
{
  public static int Main(string [] args)
  {
    int i;
    Test t = new Test();
    i = t.Method();
    return(i == 0 ? 0 : 1);
  }

  private int Method() {
    try {
      throw new ApplicationException();
    }
    return(1);
  }
}
`
(17,5): error CS1524: Expected catch or finally
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
      int i;
      Test t = new Test();

      i = t.Method();

      return(i == 0 ? 0 : 1);
    }

  private int Method() {
    catch(ApplicationException e) {
      return(0);
    }
    return(1);
  }
}
`
(16,5): error CS1003: Syntax error, 'try' expected
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
    int i;
    Test t = new Test();

    i = t.Method();

    return(i == 0 ? 0 : 1);
    }

  private int Method() {
    try {
      return(1);
    }
    catch(Guid e) {
      return(1);
    }

    return(1);
  }
}
`
(19,11): error CS0155: The type caught or thrown must be derived from System.Exception
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
    int i;
    Test t = new Test();

    i = t.Method();

    int tt = i == 0 ? 0 : 1;
    Console.WriteLine("Value is " + tt);
    return(i == 0 ? 0 : 1);
    }

  private int Method() {
    try {
      try {
        Thrower();
      } catch(ApplicationException) {
        Console.WriteLine("Rethrow");
        throw;
      } 
    } catch (ApplicationException) {
      Console.WriteLine("Recatch");
      return(0);
    }
    return(1);
  }

  private void Thrower() {
    throw new ApplicationException();
  }
}
`
Rethrow
Recatch
Value is 0
`
using System;
struct _valtype { }
class Conv
{
  public static int Main()
  {
    _valtype t = new _valtype();
    lock(t)
    {
      return 0;
    }
  }    
}
`
(8,10): error CS0185: '_valtype' is not a reference type as required by the lock statement
`
using System;
class Conv
{
  public static int Main()
  {
    lock(typeof(Conv));
    {
      return 0;
    }
  }    
}
`
(6,23): warning CS0642: Possible mistaken null statement
`
namespace test.nspace
{
  class B
  {
    public int i;
  }
}

namespace internalnamespace
{
  using System;
  using tn = test.nspace.B;

  class A
  {

    public static void Main(String[] args)
    {
      tn b = new tn();
      b.i = 3;
      
      Console.WriteLine(b.i);
    }
  }
}
`
3
`
namespace Foo.Bar
{
  class A {}
}

namespace Baz
{
  using F = Foo.Bar;
}

namespace Baz
{
  using System;

  class B : F.A 
  {
    public static void Main(String[] args)
    {
      Console.WriteLine("This should not compile!");
    }
  }
}
`
(15,13): error CS0246: The type or namespace name 'F' could not be found (are you missing a using directive or an assembly reference?)
`
namespace Foo.Bar
{
  class A {}
}

namespace Baz
{
  class A {}
}

namespace Baz
{
  using A = Foo.Bar.A;

  class main
  {
    public static void Main() {A a = null;}
  }
}
`
(13,9): error CS0576: Namespace 'Baz' already contains a type definition for 'A'
(8,9): (Location of symbol related to previous error)
`
namespace Foo.Bar
{
  class A {}
}

namespace Baz
{
}

namespace Baz
{
  using A = Foo.Bar.A;
  using A = Foo.Bar.A;

  class main
  {
    public static void Main() {}
  }
}
`
(13,9): error CS1537: The using alias 'A' appeared previously in this namespace
(12,9): (Location of symbol related to previous error)
`
using F = Foo.Bar;

namespace Foo.Bar
{
  class A {}
}

namespace Baz
{
  class F {}

  class B : F.A {}

  class main
  {
    public static void Main() {}
  }
}
`
(12,15): error CS0426: The type name 'A' does not exist in the type 'Baz.F'
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
        int ret = 1;
        switch (23) {
        case :
          ret = 1;
          break;
        }

        return(ret);
    }
}
`
(9,14): error CS0150: A constant value is expected
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
      int ret = 0;
      ret = DoFloat();
      return(ret);
    }

  private static int DoFloat()
  {
    int ret = 2;
    float f = 5.0f;

    switch (f) {
      case 1.0:
      case 5.0:
        ret--;
        break;
      case -1.0:
        break;
      default:
        break;
      }

    switch (f) {
      case 1.0:
      case -1.0:
        break;
      default:
        ret--;
    }

    if (ret > 0)
      Console.WriteLine("float failed");
    return(ret);
  }
}
`
(17,13): error CS0151: A value of an integral type expected
(28,13): error CS0151: A value of an integral type expected
`
using System;

public class Test
{
  public static int Main(string [] args)
  {
    int i = 5;

    switch (i)
    {
      case (int) 5.0f:
        return 0;
      default:
        return 1;
    }
  }
}
`
`
using System;

public class Test
{

  public static implicit operator int (Test val)
  {
    return 1;
  }

  public static implicit operator float(Test val)
  {
    return 2.1f;
  }



  public static int Main(string [] args)
  {
    Test t = new Test();

    switch (t)
    {
      case 1:
        Console.WriteLine("a");
        return 0;
      default:
        return 1;
    }
  }
}
`
a
`
public class A
{
  public static int Main()
  {
    int i = 0;

    switch (i)
    {
      case 1: break;
      case 1: break;   // CS0152
    }

    return 1;
  }
}
`
(10,12): error CS0152: The label 'case 1:' already occurs in this switch statement
(9,12): (Location of symbol related to previous error)
`
namespace Tests
{  
  public class Driver
  {
    public static int Main(string [] args)
    {
      foreach (int i in null)
      {
        return 1;
      }
      return 1;  
      
    }
  }
}
`
(7,25): error CS0186: Use of null is not valid in this context
`
using System;
using System.Collections;

public class Foreachable 
{
  public Foreachable[] GetEnumerator()
  {
    return null;
  }

  public static int Main()
  {
    Foreachable f = new Foreachable();
    foreach(Foreachable c in f) {}
    return 1;    
  }
}
`
(14,30): error CS0202: The call to GetEnumerator must return a class or a struct, not 'Foreachable[]'
`
using System;

public class Test
{
  public static int Main(string [] args)
  {
    int i;
    Test t = new Test();

    i = t.Method();

    return(i == 0 ? 0 : 1);
  }

  private int Method() {
    try
      throw new ApplicationException();
    catch(ApplicationException e)
      return(0);

    return(1);
  }
}
`
(17,7): error CS1514: { expected
(18,5): error CS1513: } expected
(19,7): error CS1514: { expected
`
using System;

public class Test
{
  private const int CONST = 2;

  public static int Main(string [] args)
  {
    int i = 2;

    if (i < (MyEnum) CONST)
      return 1;

    if (i == (MyEnum) 0)
      return 1;

    return 0;
  }
}

public enum MyEnum
{
  aaa,
  bbb,
  ccc
}
`
(11,9): error CS0019: Operator '<' cannot be applied to operands of type 'int' and 'MyEnum'
(14,9): error CS0019: Operator '==' cannot be applied to operands of type 'int' and 'MyEnum'
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
        int i, j, k;
        return(0);
    }
}
`
`
using System;
namespace Tests
{  
  public class Driver
  {
    public static int Main(string [] args)
    {
      foreach (char c in "")
      {
        return 1;
      }
      return 0;  
      
    }
  }
}
`
(8,21): warning CS0219: The variable 'c' is assigned but its value is never used
`
using System;

[module:CLSCompliant(true)]

class A
{
  public void printClassName()
  {
    Console.WriteLine("Class A");
  }

  static void Main() {}
}
`
(3,9): warning CS3012: You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking
`
private namespace test
{
  using System;

  class A
  {
    public static void Main(String[] args)
    {
      Console.WriteLine("This worked!");
    }
  }
}
`
(1,1): error CS1527: Namespace elements cannot be explicitly declared as private or protected
`
namespace test {
  namespace test2 {
    namespace test3 {
      namespace test4 {
        namespace test5 {
          namespace test6 {
            namespace test7 {
              namespace test8 {
                namespace test9 {
                  namespace test10 {
                    class TheClass 
                    { 
                      public void SayHello() {
                        System.Console.WriteLine("Hello");
                      }
                    }
                  }
                };
              };
            }
          }
        };
      };
    }
  };
}

namespace Main {
  class main {
    public static void Main() {
      test.test2.test3.test4.test5.test6.test7.test8.test9.test10.TheClass tc;
      tc = new test.test2.test3.test4.test5.test6.test7.test8.test9.test10.TheClass();
      tc.SayHello();
    }
  }
}
`
Hello
`
internal namespace test
{
}

namespace Main
{
  class main 
  {
    public static void Main() {}
  }
}
`
(1,10): error CS1518: Expected class, delegate, enum, interface, or struct
`
class main 
{
  namespace namespace
  {
    class foo{}
  }

  public static void Main() {}
}
`
(3,3): error CS1519: Invalid token 'namespace' in class, struct, or interface member declaration
(3,13): error CS1041: Identifier expected, 'namespace' is a keyword
`
namespace test
{
}
}
`
(4,1): error CS1022: Type or namespace definition, or end-of-file expected
`
namespace Foo.Bar
{
  class A 
  {
    public void showMessage() 
    {
      System.Console.WriteLine("Foo.Bar.A");
    }
  }
}

namespace testns
{
  using Foo.Bar;
  using System;

  class A
  {
    public void showMessage()
    {
      System.Console.WriteLine("testns.A");  
    }
  }

  class main
  {
    public static void Main()
    {
      A a = new A();
      a.showMessage();
    }
  }
}
`
testns.A
`
using System;
using System.Reflection;

[assembly:AssemblyVersion("65535.65535.65535.65535")]

public class C {
  public static int Main () {
    return 1;
  }
}
`
(4,11): error CS0647: Error emitting 'System.Reflection.AssemblyVersionAttribute' -- argument '65535.65535.65535.65535' is invalid
`
using System;
using System.Reflection;
using System.Resources;

[assembly:SatelliteContractVersion("4.3.*.1")]

public class C {
  public static int Main () {
    return 1;
  }
}
`
(5,11): error CS0647: Error emitting 'System.Resources.SatelliteContractVersionAttribute' -- argument '4.3.*.1' is invalid
`
class MyClass : {
  public static int Main() {
    return 1;  
  }
}
`
(1,17): error CS1031: Type expected
`
class base1 {}

class MyClass : : base1 {
  public static int Main() {
    return 1;  
  }
}
`
(3,17): error CS1031: Type expected
`
class A: B {}
class B: C {}
class C: A {
  public static int Main() {
    return 1;
  }
}
`
(3,7): error CS0146: Circular dependency between 'C' and 'A'
(1,7): (Location of symbol related to previous error)
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
    int[] i[30];
    int j = i[23];

    if (j != 0) {
      return(1);
    }

        return(0);
    }
}
`
(7,12): error CS0650: Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier
`
class A: B.C {}
class B: A {
  public class C {
    public static int Main() {
      return 1;
    }
  }
}
`
(1,7): error CS0146: Circular dependency between 'A' and 'B.C'
(3,16): (Location of symbol related to previous error)
`
public abstract class BaseClass {
  public int IntI = 2;
}

public class MyClass : BaseClass {
  public static int Main() {
    MyClass Test = new MyClass();
    if (Test.IntI == 2) {
      return 0;
    }
    else {
      return 1;
    }    
  }
}
`
`
abstract class MyClass {  
  public static int Main() {
    MyClass test = new MyClass();
    return 1;
  }
}
`
(3,20): error CS0144: Cannot create an instance of the abstract class or interface 'MyClass'
`
abstract sealed class TestClass {}

class MyClass {  
  public static int Main() {
    return 1;
  }
}
`
(1,23): error CS0502: 'TestClass' cannot be both abstract and sealed
`
abstract class TestClass {
  public abstract void foo();
}

class MyClass : TestClass {  
  public static int Main() {
    return 1;
  }
}
`
(5,7): error CS0534: 'MyClass' does not implement inherited abstract member 'TestClass.foo()'
(2,24): (Location of symbol related to previous error)
`
abstract class TestClass {
  public abstract int intI {
    get;
  }
}

class MyClass : TestClass {
  
  public static int Main() {
    return 1;
  }
}
`
(7,7): error CS0534: 'MyClass' does not implement inherited abstract member 'TestClass.intI.get'
(3,5): (Location of symbol related to previous error)
`
abstract class TestClass {
  public abstract int intI {
    set;
  }
}

class MyClass : TestClass {
  
  public static int Main() {
    return 1;
  }
}
`
(7,7): error CS0534: 'MyClass' does not implement inherited abstract member 'TestClass.intI.set'
(3,5): (Location of symbol related to previous error)
`
class MyClass {

  public int intI = 2;

  public static MyClass operator ^ (MyClass MyInt) {
    return MyInt;
  }

  public static int Main() {
    return 1;  
  }

}
`
(5,34): error CS1019: Overloadable unary operator expected
`
using System;

namespace nms {

delegate int boo();

public class poo
    {
    public static int retval = 0x03;
    public int bar () {Console.WriteLine("bar"); return 0x01;}
    static public int far ()
        {
        Console.WriteLine("far");
        return 0x02;
        }
    }

public class start
    {
    static public int Main ()
        {
        boo foo = null;
        try {
            foo();
        }
        catch (NullReferenceException)
        {
            poo.retval -= 0x03;
        }
        if (poo.retval == 0) Console.WriteLine ("PASS");
        else Console.WriteLine ("FAIL");
        return poo.retval;
        }
    }

}
`
PASS
`
using System;
namespace nms {

public class mine {
    private static int retval = 1;
    public static int Main()
    {
    try {
        Console.WriteLine ("In try block, ready to throw.");
      throw new ApplicationException("An exception has occurred");
        }
    catch (OutOfMemoryException)
        {
        Console.WriteLine ("FAIL -- Should not enter catch (OutOfMemoryException a) block.");
        retval = 1;
        }
    catch
        {
        Console.WriteLine ("In catch block.");
        retval -= 1;
        }
    return retval;
    }
    };
}
`
In try block, ready to throw.
In catch block.
`
public class B<T, U> {}

internal class C
{
   private class C1 {}
   public class C2 {}

   public B<C1, C2> memberFunction() {return null;}

   public static int Main()
   {
      return 1;
   }
}
`
(8,21): error CS0050: Inconsistent accessibility: return type 'B<C.C1,C.C2>' is less accessible than method 'C.memberFunction()'
(1,14): (Location of symbol related to previous error)
`
using System;
namespace nms {
  public class mine {
    public enum e1 : float  {one=1, two=2, three=3};

    public static int Main()
    {
      e1 v_e1 = e1.two;
      Console.Write ("v_e1 == ");
      Console.WriteLine (v_e1);
      return 1;
    }
  };
}
`
(4,22): error CS1008: Type byte, sbyte, short, ushort, int, uint, long, or ulong expected
`
using System;

struct A 
{
  protected int a;

  public void MyMethod() 
  {
    // This code is here to avoid the "a not used" compiler warning
    a = 5;
    if (a == 5)
      a++;
  }
}

class main 
{
  public static int Main() 
  {
    return 0;
  }
}
`
(5,17): error CS0666: 'A.a' : new protected member declared in struct
`
class MyClass {

  public int intI = 2;

  public static MyClass operator >>> (MyClass MyInt, int MyInt2) {
    MyClass MC = new MyClass();
    MC.intI = MyInt.intI + MyInt2;
    return MC;
  }

  public static int Main() {
    MyClass Test1 = new MyClass();

    MyClass Test = Test1 >>> 3;

    if (Test.intI == 5) {
      return 0;
    }
    else {
      return 1;
    }    
  }
}
`
(5,36): error CS1003: Syntax error, '(' expected
(14,28): error CS1525: Invalid expression term '>'
`
class MyClass {

  public int intI = 2;

  public static int operator compare (MyClass MyInt1, MyClass MyInt2) {
    return 1;
  }

  public static int Main() {
    MyClass Test1 = new MyClass();
    MyClass Test2 = new MyClass();
    MyClass Test3 = new MyClass();
  
    bool intI = Test1 > Test2;    

    return 1;
  
  }
}
`
(5,30): error CS1020: Overloadable binary operator expected
(14,17): error CS0019: Operator '>' cannot be applied to operands of type 'MyClass' and 'MyClass'
`
class MyClass {

  public int intI = 2;

  public static MyClass operator != (MyClass MyInt, MyClass MyInt2) {
    return new MyClass();
  }

  public static int Main() {
    return 1;    
  }
}
`
(5,25): error CS0216: The operator 'MyClass.operator !=(MyClass, MyClass)' requires a matching operator '==' to also be defined
(1,7): warning CS0660: 'MyClass' defines operator == or operator != but does not override Object.Equals(object o)
(1,7): warning CS0661: 'MyClass' defines operator == or operator != but does not override Object.GetHashCode()
`
class MyClass {

  public static MyClass operator ~ (MyClass MyInt) {
    return MyInt;
  }  

  public MyClass op_OnesComplement(MyClass MyInt) {
    return MyInt;
  }

  public static int Main() {
    return 1;  
  }  
}
`
(7,18): error CS0111: Type 'MyClass' already defines a member called 'op_OnesComplement' with the same parameter types
(3,25): (Location of symbol related to previous error)
`
class MyClass {

  public static bool operator true (MyClass MyInt) {
    return true;
  }

  public static int Main() {
    return 1;  
  }
}
`
(3,22): error CS0216: The operator 'MyClass.operator true(MyClass)' requires a matching operator 'false' to also be defined
`
class MyClass {

  public static bool operator > (MyClass MyInt, MyClass MyInt2) {
    return true;
  }
  public static int Main() {
    return 1;  
  }
}
`
(3,22): error CS0216: The operator 'MyClass.operator >(MyClass, MyClass)' requires a matching operator '<' to also be defined
`
class MyClass {

  public static bool operator >= (MyClass MyInt, MyClass MyInt2) {
    return true;
  }
  public static int Main() {
    return 1;  
  }
}
`
(3,22): error CS0216: The operator 'MyClass.operator >=(MyClass, MyClass)' requires a matching operator '<=' to also be defined
`
interface MyInter {}

class MyClass : MyInter, MyInter {

  public static int Main() {
    return 1;
  }
}
`
(3,26): error CS0528: 'MyInter' is already listed in interface list
`
public interface iface : iface{}
public interface iface1 : iface2{};
public interface iface2 : iface1{};
public class MyClass{
  public static int Main() {
    return 1;  
  }
}
`
(1,18): error CS0529: Inherited interface 'iface' causes a cycle in the interface hierarchy of 'iface'
(2,18): error CS0529: Inherited interface 'iface2' causes a cycle in the interface hierarchy of 'iface1'
(3,18): (Location of symbol related to previous error)
`
using System;

struct A 
{
  protected internal int a;

  public void MyMethod() 
  {
    // This code is here to avoid the "a not used" compiler warning
    a = 5;
    if (a == 5)
      a++;
  }
}

class main 
{
  public static int Main() 
  {
    return 0;
  }
}
`
(5,26): error CS0666: 'A.a' : new protected member declared in struct
`
using System;

private enum E1 {}
protected enum E2 {}
protected internal enum E3 {}

namespace N1 {
    private enum E4 {}
    protected enum E5 {}
    protected internal enum E6 {}
}

struct S1 {
    protected enum E7 {}
    protected internal enum E8 {}
}

class Test {
  static void Main() {}
}
`
(3,1): error CS1527: Namespace elements cannot be explicitly declared as private or protected
(4,1): error CS1527: Namespace elements cannot be explicitly declared as private or protected
(5,1): error CS1527: Namespace elements cannot be explicitly declared as private or protected
(8,5): error CS1527: Namespace elements cannot be explicitly declared as private or protected
(9,5): error CS1527: Namespace elements cannot be explicitly declared as private or protected
(10,5): error CS1527: Namespace elements cannot be explicitly declared as private or protected
(14,5): error CS0106: The modifier 'protected' is not valid for this item
(15,5): error CS0106: The modifier 'protected' is not valid for this item
`
interface I {}

class C : I
{
  void I.M() {}
    static void Main() {}
}
`
(5,10): error CS0539: 'C.I.M()' in explicit interface declaration does not match a member of interface 'I'
(1,11): (Location of symbol related to previous error)
`
class MyClass {
  public MyClass1() {}
  public static int Main() {
    return 1;
  }
}
`
(2,10): error CS1520: Class, struct, or interface method must have a return type
`
class MyClass {

  int this[int intI] {
    get {
      return 1;
    }
  }

  int this[int intJ] {
    get {
      return 2;
    }
  }

  public static int Main() {
    return 1;
  }
}
`
(9,7): error CS0111: Type 'MyClass' already defines a member called 'MyClass.this' with the same parameter types
(3,7): (Location of symbol related to previous error)
`
using System;

private delegate void D1();
protected delegate void D2();
protected internal delegate void D3();

namespace N1 {
    private delegate void D4();
    protected delegate void D5();
    protected internal delegate void D6();
}

struct S1 {
    protected delegate void D13();
    protected internal delegate void D14();
}

class Test {
  static void Main() {}
}
`
(3,1): error CS1527: Namespace elements cannot be explicitly declared as private or protected
(4,1): error CS1527: Namespace elements cannot be explicitly declared as private or protected
(5,1): error CS1527: Namespace elements cannot be explicitly declared as private or protected
(8,5): error CS1527: Namespace elements cannot be explicitly declared as private or protected
(9,5): error CS1527: Namespace elements cannot be explicitly declared as private or protected
(10,5): error CS1527: Namespace elements cannot be explicitly declared as private or protected
(14,5): error CS0106: The modifier 'protected' is not valid for this item
(15,5): error CS0106: The modifier 'protected' is not valid for this item
`
namespace test
{
  class B {}
  
  using System;

  class A
  {
    public static void Main()
    {
      System.Console.WriteLine("This works!  It shouldn't though!");
    }
  }
}
`
(5,3): error CS1529: A using clause must precede all other namespace elements
`
using System;

class MyBase {}

class MyClass : MyBase {
  
  new public static int intK = 3;

  public static int Main() {
    if (MyClass.intK == 3) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
(7,25): warning CS0109: The member 'MyClass.intK' does not hide an inherited member. The new keyword is not required.
`
class B : A
{
        private fooDel fooDelInst;

        protected event fooDel fooEvent
        {
                add { base += value; }
                remove { base -= value; }
        }
}

class A
{
   protected delegate void fooDel();

   public static int Main()
   {
        return 1;
   }
}
`
(7,23): error CS0175: Use of keyword base is not valid in this context
(8,26): error CS0175: Use of keyword base is not valid in this context
`
class MyClass {

  public static int intI = 1;

  public static int Main() {
    MyClass test = new MyClass();
    int intJ = test.intI;
    return 1;    
  }
}
`
(7,16): error CS0176: Static member 'MyClass.intI' cannot be accessed with an instance reference; qualify it with a type name instead
`
class MyTest {
  public const int intI = 2, intJ = 3;
}

class MyClass {

  public static int Main() {
    if ((MyTest.intI == 2) && (MyTest.intJ == 3)) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
using System;

public class MyClass {

  public int intI = 2;
  public static int intK = intI;

  public static int Main() {
    return 1;
  }
}
`
(6,28): error CS0120: An object reference is required for the nonstatic field, method, or property 'MyClass.intI'
`
public class MyClass {  

  public void TestMeth(out int intI) {
    intI = 2;
  }

  public static int Main() {  

    int s1 = 2;
    MyClass test = new MyClass();
    test.TestMeth(ref s1);
    return 1;
  }
}
`
(11,19): error CS0029: Cannot implicitly convert type 'ref int' to 'out int'
`
public class MyClass {
  public virtual static int Prop{get{return 0;}}
  public virtual static void Meth() {}
  public static int Main() {
    return 1;
  }
}
`
(2,29): error CS0112: A static member 'MyClass.Prop' cannot be marked as override, virtual, or abstract
(3,30): error CS0112: A static member 'MyClass.Meth()' cannot be marked as override, virtual, or abstract
`
public class MyClass {  

  int intJ;

  protected int this[int intI] {
    get {
      return intI + intJ;
    }
    set {
      intJ = intI + 1;
    }
  }
}


public class TestClass {
  public static int Main() {
    MyClass test = new MyClass();
    test[1] = 1;
    return 1;
  }
}
`
(19,5): error CS0122: 'MyClass.this[int]' is inaccessible due to its protection level
`
public struct A
{
  string[] a = new string[100];   // CS0573

  public static int Main() { return 1; }
}
`
(3,16): error CS0573: 'A.a': cannot have instance field initializers in structs
`
using System;

interface test 
{
  int TestMethod(int x) {
    Console.WriteLine("Test");
  }
}

class main
{
  public static void Main() {}
}
`
(5,7): error CS0531: 'test.TestMethod(int)': interface members cannot have a definition
`
class MyClass {

  int intTest = 1;
  static int intTest2 = 2;
  string strTest = "test";
  static string strTest2 = "test2";
  class TestClass{}
  [Microsoft.Contracts.NotDelayed]
  public MyClass() {
    int intI = intTest;
    string strS = strTest;
    TestClass tc = new TestClass();
  }

  ~MyClass() {
    int intI = intTest;
    string strS = strTest;
    TestClass tc = new TestClass();
  }

  public void TestMeth() {
    int intI = intTest;
    string strS = strTest;
    TestClass tc = new TestClass();
  }  

  public static int Main() {
    int intI = intTest2;
    string strS = strTest2;
    TestClass tc = new TestClass();
    return 0;
  }
}
`
(10,9): warning CS0219: The variable 'intI' is assigned but its value is never used
(11,12): warning CS0219: The variable 'strS' is assigned but its value is never used
(12,15): warning CS0219: The variable 'tc' is assigned but its value is never used
(16,9): warning CS0219: The variable 'intI' is assigned but its value is never used
(17,12): warning CS0219: The variable 'strS' is assigned but its value is never used
(18,15): warning CS0219: The variable 'tc' is assigned but its value is never used
(22,9): warning CS0219: The variable 'intI' is assigned but its value is never used
(23,12): warning CS0219: The variable 'strS' is assigned but its value is never used
(24,15): warning CS0219: The variable 'tc' is assigned but its value is never used
(28,9): warning CS0219: The variable 'intI' is assigned but its value is never used
(29,12): warning CS0219: The variable 'strS' is assigned but its value is never used
(30,15): warning CS0219: The variable 'tc' is assigned but its value is never used
`
class MyClass {

  public int intI = 2;

  public static MyClass operator + (int intI, long MyInt2) {
    return new MyClass();
  }

  public static int Main() {
    return 1;
  }

}
`
(5,25): error CS0563: One of the parameters of a binary operator must be the containing type
`
class MyClass {

  public int intI = 2;

  public static void operator + (MyClass MyInt, MyClass MyInt2) {
    MyClass MC = new MyClass();
    return MC;
  }

  public static int Main() {
    return 1;    
  }

}
`
(5,17): error CS0590: User-defined operators cannot return void
`
using System;

public delegate void MyDelegate(object sender);

interface IControl
{
    event MyDelegate MyEvent;
}

interface IForm
{
    event MyDelegate MyEvent;
}

class main : IControl, IForm
{
    public event MyDelegate MyEvent;
    
    public static void Main()
    {

    }
}
`
`
interface IOne
{
    void F();
}

class MyClass
{
    public void F() {}
    public void G() {}
}

class MyOtherClass : MyClass, IOne
{
    public new void G() {}
}

class main
{
    public static void Main() {} 
}
`
`
interface first 
{
  const int x
    {
        get;
        set; 
    }
}

class main 
{
  public static void Main() {}
}
`
(4,5): error CS0145: A const field requires a value to be provided
`
using System;
    
public class mine {
  public enum e1 {one=1, two=2.2, three=3};

  public static int Main()
    {
    return 1;
    }
}
`
(4,30): error CS0031: Constant value '2.2' cannot be converted to a 'int'
`
struct test
{
  private interface baseiface {}
  public interface inheritor : baseiface {}
}

class main
{
  public static void Main() {}  
}
`
(4,20): error CS0061: Inconsistent accessibility: base interface 'test.baseiface' is less accessible than interface 'test.inheritor'
(3,21): (Location of symbol related to previous error)
`
using System;
    
public class mine {
    public enum e1 {one=1, two=2, three= };

  public static int Main()
    {
    return 1;
    }
}
`
(4,42): error CS0150: A constant value is expected
`
using System;

public class A {
  [method:STAThread()]
  public event EventHandler evh;
  public void Fire () {
    if (null != evh)
      evh ("Sender object", EventArgs.Empty);
  }
}

public class B {
  public static void HandlerInB (object sender, EventArgs ea) {
    if ("Sender object" == (string)sender)
      C.retval -= 1;
    C.retval -= 2;
  }
}

public class C {
  public static int retval = 0x0F;
  public static int Main () {
    A a = new A ();
    a.evh += new EventHandler(B.HandlerInB);
    a.Fire();
    object[] oa = a.GetType().GetEvent("evh").GetAddMethod().GetCustomAttributes(false);
    foreach (object o in oa) {
      if (o.GetType() == typeof(System.STAThreadAttribute))
        C.retval -= 4;
    }
    oa = a.GetType().GetEvent("evh").GetRemoveMethod().GetCustomAttributes(false);
    foreach (object o in oa) {
      if (o.GetType() == typeof(System.STAThreadAttribute))
        C.retval -= 8;
    }
    if (0 == retval) Console.WriteLine ("PASS");
    else Console.WriteLine ("FAIL, retval=="+retval.ToString());
    return retval;
  }
}
`
PASS
`
class MyBase {
  public int MyProp {
    get {
      return 1;
    }
  }
}  

class MyClass : MyBase {

  int intI = 0;

  new int MyProp {
    get {
      return intI;
    }
    set {
      intI = value;
    }
  }

  public static int Main() {
    MyClass test = new MyClass();
    test.MyProp = 2;
    if (test.MyProp == 2) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
public enum MyEnum {a = 1, b = 2}

public struct MyStruct1 {

  public MyStruct1(int intI) {
    E = MyEnum.a;
  }

  public MyEnum E;
}

public struct MyStruct2 {

  public MyStruct2(int intI) {
    E = MyEnum.b;
  }

  public MyEnum E;

  public static int Main() {

    MyStruct1 Test1 = new MyStruct1(0);
    MyStruct2 Test2 = new MyStruct2(0);

    if (Test1.E != MyEnum.a) {
      return 1;
    }
    if (Test2.E != MyEnum.b) {
      return 1;
    }
    return 0;
  }
}
`
`
class MyClass {

  public static int operator true (MyClass MyInt) {
    return 1;
  }

  public static bool operator false (MyClass MyInt) {
    return false;
  }

  public static int Main() {

    return 1;  
  }
}
`
(3,21): error CS0215: The return type of operator True or False must be bool
`
class MyClass {

  public static int Main() 
  {
    int retVal = 0;

    long l = 2;
    ulong ul = 2;

    if ((ul+l) != ul)
      retVal = -1;
    if ((l+ul) != ul)
      retVal = -1;
    
    return retVal;

  }
}
`
(10,10): error CS0034: Operator '+' is ambiguous on operands of type 'ulong' and 'long'
(12,10): error CS0034: Operator '+' is ambiguous on operands of type 'long' and 'ulong'
`
class MyClass {

  public static int Main() 
  {
    int retVal = 0;

    sbyte sb = 2;
    byte b = 2;
    short s = 2;
    ushort us = 2;
    int i = 2;
    uint ui = 2;
    long l = 2;
    ulong ul = 2;

    if ((sb+0) != sb)
      retVal = -1;
    if ((0+sb) != sb)
      retVal = -1;

    if ((b+0) != b)
      retVal = -1;
    if ((0+b) != b)
      retVal = -1;

    if ((s+0) != s)
      retVal = -1;
    if ((0+s) != s)
      retVal = -1;

    if ((us+0) != us)
      retVal = -1;
    if ((0+us) != us)
      retVal = -1;

    if ((i+0) != i)
      retVal = -1;
    if ((0+i) != i)
      retVal = -1;

    if ((ui+0) != ui)
      retVal = -1;
    if ((0+ui) != ui)
      retVal = -1;

    if ((l+0) != l)
      retVal = -1;
    if ((0+l) != l)
      retVal = -1;

    if ((ul+0) != ul)
      retVal = -1;
    if ((0+ul) != ul)
      retVal = -1;
    

    return retVal;

  }

}
`
`
class MyClass {

  public static int Main() 
  {
    int retVal = 0;

    sbyte sb = 2;
    byte b = 2;
    short s = 2;
    ushort us = 2;
    int i = 2;
    uint ui = 2;
    long l = 2;
    ulong ul = 2;

    if ((sb*0) != 0)
      retVal = -1;
    if ((0*sb) != 0)
      retVal = -1;

    if ((b*0) != 0)
      retVal = -1;
    if ((0*b) != 0)
      retVal = -1;

    if ((s*0) != 0)
      retVal = -1;
    if ((0*s) != 0)
      retVal = -1;

    if ((us*0) != 0)
      retVal = -1;
    if ((0*us) != 0)
      retVal = -1;

    if ((i*0) != 0)
      retVal = -1;
    if ((0*i) != 0)
      retVal = -1;

    if ((ui*0) != 0)
      retVal = -1;
    if ((0*ui) != 0)
      retVal = -1;

    if ((l*0) != 0)
      retVal = -1;
    if ((0*l) != 0)
      retVal = -1;

    if ((ul*0) != 0)
      retVal = -1;
    if ((0*ul) != 0)
      retVal = -1;
    
    return retVal;

  }

}
`
`
using System;

public class MyClass {
  public static int Main() {

    char c1 = (char)2;

    if ((c1 * 0) == 0) {
      return 0;
    }
    else {
      return 1;
    }
  }  
}
`
`
namespace Microsoft.Conformance.Expressions {
  public class arith009 {
    public static int Main()
    {
      int i1 = 4 + false;
    }
  }
}
`
(5,16): error CS0019: Operator '+' cannot be applied to operands of type 'int' and 'bool'
`
using System;

public class MyClass {
  public static int Main() {
    
    int i1 = (int) (0x80000000/-1);
    
    if (i1 == int.MinValue) {
      return 0;
    }
    else {
      return 1;
    }

  }  
}
`
`
class MyClass {  
  protected MyClass() {}
}

class MyClass2 {

  public static int Main() {
    MyClass test = new MyClass();
    return 1;
  }
}
`
(8,20): error CS0122: 'MyClass.MyClass()' is inaccessible due to its protection level
`
class MyBase {}

class MyClass : MyBase {  
  static MyClass() : base() {
    intI = 2;
  }

  static int intI = 1;

  public static int Main() {
    return 1;
  }
}
`
(4,20): error CS0514: A static constructor cannot have an explicit this or base constructor call
`
class MyClass {

  public MyClass(int intJ) {
    intI = 2;
  }

  public MyClass(int intJ) {
    intI = 3;
  }

  public static int intI = 1;

  public static int Main() {
    return 1;
  }

}
`
(7,10): error CS0111: Type 'MyClass' already defines a member called 'MyClass' with the same parameter types
(3,10): (Location of symbol related to previous error)
`
class MyBase {
  private MyBase() {}
}

class MyClass : MyBase {  

  public static int Main() {
      return 1;
  }
}
`
(5,7): error CS0122: 'MyBase.MyBase()' is inaccessible due to its protection level
`
class A
{
   public static int Main() { return 1; }
}


class B : A[] {}   // CS1521
`
(7,12): error CS1521: Invalid base type
`
class MyClass  {  

  //no modifier
  MyClass() : 
  {}

  MyClass(int i) : 
  {}

  public static int Main() 
  {
    return 1;
  }
}
`
(5,3): error CS1018: Keyword this or base expected
(8,3): error CS1018: Keyword this or base expected
`
class MyClass  {  

  MyClass(int i){}

  public static int Main() 
  {
    MyClass m(10);
    return 1;
  }
}
`
(7,14): error CS1528: Expected ; or = (cannot specify constructor arguments in declaration)
`
class MyClass {

  ~MyClass(int intI) {}

  public static int Main() {
    return 1;
  }
}
`
(3,12): error CS1026: ) expected
`
using System;

class C
{
  protected override void Finalize() {  // error
    Console.WriteLine("Finalize");
  }
  
  public static int Main() {
    return 1;
  }
}
`
(5,27): error CS0249: Do not override object.Finalize.  Instead, provide a destructor.
`
using System;

class C {

  public void F() {
    this.Finalize();        // error
  }
  
  public static int Main() {
    return 1;
  }
}
`
(6,5): error CS0245: Destructors and object.Finalize cannot be called directly.  Consider calling IDisposable.Dispose if available.
`
using System;

class C {
  void MyMeth() {        
    base.Finalize();  
  }
  
  public static int Main() {
    return 1;
  }
}
`
(5,5): error CS0250: Do not directly call your base class Finalize method. It is called automatically from your destructor.
`
interface MyInter {
  int MyProp {
    get;
    set;
  }
}

class MyClass : MyInter {

  static int intI = 0;

  int MyInter.MyProp {
    get {
      return intI;
    }
    set {
      intI = value;
    }
  }

  public static int Main() {
    MyClass MC = new MyClass();

    ((MyInter)MC).MyProp = 2;
    if (((MyInter)MC).MyProp == 2) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
class MyClass {  

  MyClass(int intX) {}
  MyClass(int intX, char ch) {}

  public static int Main() {
    MyClass test = new MyClass();
    return 1;
  }
}
`
(7,20): error CS1501: No overload for method 'MyClass' takes '0' arguments
(3,3): (Location of symbol related to previous error)
(4,3): (Location of symbol related to previous error)
`
class MyClass {  

  int intI = 1;

  MyClass(int intJ) : this(3) {
    intI = intI * intJ;
  }

  public static int Main() {
    return 1;
  }
}
`
(5,23): error CS0516: Constructor 'MyClass.MyClass(int)' cannot call itself
`
class MyClass {  

  //static constructor
  static MyClass() {
    intI = 2;
  }

  MyClass() {
    intI = 3;
  }

  static int intI = 1;

  public static int Main() {

    int RetVal = 0;

    if (intI != 2) {
      RetVal = 1;
    }

    MyClass Test = new MyClass();
    
    if (intI != 3) {
      RetVal = 1;
    }

    return RetVal;
  }
}
`
(22,13): warning CS0219: The variable 'Test' is assigned but its value is never used
`
class MyClass {  

  //static constructor
  public static MyClass(int bar) {
    intI = 2;
  }

  static int intI = 1;

  public static int Main() {
    return 1;
  }
}
`
(4,3): error CS0515: Access modifiers are not allowed on static constructors
(4,25): error CS0132: A static constructor must be parameterless
`
class BaseClass {
  public BaseClass(int intI, long lngL) {}
  public BaseClass(long lngL, int intI) {} 
}
class MyClass : BaseClass {
  public MyClass() : base((short)2, (short)2) {}
  public static int Main() {
    return 1;
  }
}
`
(6,22): error CS0121: The call is ambiguous between the following methods or properties: 'BaseClass.BaseClass(int, long)' and 'BaseClass.BaseClass(long, int)'
`
class A
{
   static public int Main ()
   {
      double d = new double(1);   // CS0143
      return 1;
   }
}
`
(5,18): error CS0143: The type 'double' has no constructors defined
`
public class MyClass {

  public int MyProp {}

  public static int Main() {
    return 1;  
  }
}
`
(3,14): error CS0548: 'MyClass.MyProp' : property or indexer must have at least one accessor
`
public abstract class TestClass {
  public abstract int MyProp {
    set {}  
  }
}

public class MyClass {

  public static int Main() {
    return 1;  
  }
}
`
(3,5): error CS0500: 'TestClass.MyProp.set' cannot declare a body because it is marked abstract
`
public class MyClass {

  public void MyProp {
    get {
      return;
    }
    set {
    }
  }

  public static int Main() {
    return 1;
  }
}
`
(3,15): error CS0547: 'MyClass.MyProp' : property or indexer cannot have void type
`
using System;

public class MyClass {

  public int MyProp {
    get {
      return;    
    }
  }

  public static int Main() {
    return 1;
  }
}
`
(7,7): error CS0126: An object of a type convertible to 'int' is required
`
public class MyBase {
  public virtual int MyProp {
    set {}
    get {return 1;}
  }
}

public class MyClass : MyBase {

  public override long MyProp {
    set {}
    get {return 2;}
  }

  public static int Main() {
    return 1;
  }
}
`
(10,24): error CS0508: 'MyClass.MyProp': cannot change return type when overriding inherited member 'MyBase.MyProp'
(2,22): (Location of symbol related to previous error)
`
public class MyBase {
  public virtual int MyProp {
    get {return 1;}
  }
}

public class MyClass : MyBase {

  public override int MyProp {
    set {}
    get {return 2;}
  }

  public static int Main() {
    return 1;
  }
}
`
(9,23): error CS0546: 'MyClass.MyProp': cannot override because 'MyBase.MyProp' does not have an overridable set accessor
(2,22): (Location of symbol related to previous error)
`
public class MyBase {
  public virtual int MyProp {
    set {}
  }
}

public class MyClass : MyBase {

  public override int MyProp {
    set {}
    get {return 2;}
  }

  public static int Main() {
    return 1;
  }
}
`
(9,23): error CS0545: 'MyClass.MyProp': cannot override because 'MyBase.MyProp' does not have an overridable get accessor
(2,22): (Location of symbol related to previous error)
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
        int i = 0;
        
        do {
            return(1);
        } while (i);

        return(1);
    }
}
`
(11,18): error CS0029: Cannot implicitly convert type 'int' to 'bool'
`
class MyClass {

  ~MyClass() {}
  ~MyClass() {}
}
`
(4,4): error CS0111: Type 'MyClass' already defines a member called '~MyClass' with the same parameter types
(3,4): (Location of symbol related to previous error)
`
using System;

public class lineTests
{
  public static void Main() 
  {
        #line 13
        short a = 123456;

        #line 6 
        short b = 123456;

        #line 33
        short c = 123456;

        #line 13
        short d = 123456;

        #line 6 
        short e = 123456;

        #line 33
        short f = 123456;

        #line 13
        short g = 123456;

        #line 6 
        short h = 123456;

        #line 33 
        short i = 123456;

        #line 13 
        short j = 123456;

        #line 6 
        short k = 123456;

        #line 33
        short l = 123456;

        #line 13
        short m = 123456;

        #line 6 
        short n = 123456;

        #line 33
        short o = 123456;
    }
}
`
(13,19): error CS0031: Constant value '123456' cannot be converted to a 'short'
(6,19): error CS0031: Constant value '123456' cannot be converted to a 'short'
(33,19): error CS0031: Constant value '123456' cannot be converted to a 'short'
(13,19): error CS0031: Constant value '123456' cannot be converted to a 'short'
(6,19): error CS0031: Constant value '123456' cannot be converted to a 'short'
(33,19): error CS0031: Constant value '123456' cannot be converted to a 'short'
(13,19): error CS0031: Constant value '123456' cannot be converted to a 'short'
(6,19): error CS0031: Constant value '123456' cannot be converted to a 'short'
(33,19): error CS0031: Constant value '123456' cannot be converted to a 'short'
(13,19): error CS0031: Constant value '123456' cannot be converted to a 'short'
(6,19): error CS0031: Constant value '123456' cannot be converted to a 'short'
(33,19): error CS0031: Constant value '123456' cannot be converted to a 'short'
(13,19): error CS0031: Constant value '123456' cannot be converted to a 'short'
(6,19): error CS0031: Constant value '123456' cannot be converted to a 'short'
(33,19): error CS0031: Constant value '123456' cannot be converted to a 'short'
`
using System;

namespace nms {

  delegate int boo();

  public class poo {

      public int bar () {Console.WriteLine("bar"); return 0x01;}
      static public int far ()
          {
          Console.WriteLine("far");
          return 0x02;
          }
  }

  public class start {
      static int retval = 0x03;
      static bool loo() {return true;}
      
      static public int Main ()
          {
          poo p = new poo();
          boo foo = null;
          foo = loo() ? new boo(p.bar): null;
          retval -= foo();
          foo = !loo() ? null: new boo(poo.far);
          retval -= foo();
          if (retval == 0) Console.WriteLine ("PASS");
          else Console.WriteLine ("FAIL");
          return retval;
          }
  }

}
`
bar
far
PASS
`
using System;

public class B<T, U> {}

internal class C
{
   internal protected class C1 {}
   public class C2 {}

   public B<C1, C2> memberFunction() {return null;}

   public static int Main()
   {
      return 0;
   }
}
`
`
class main
{
  internal interface baseiface {}
  
  public interface inheritor : baseiface {}
  
  public static void Main() {}  
}
`
`
interface Outer
{
  interface Inner { }
}

class Test
{
  static void Main() {}
}
`
(3,3): error CS0524: Interfaces cannot declare types
`
using System;

public struct A 
{
  public virtual int Foo
  {
    get
    {
      return 10;
    }
  }
}

public class AA
{
  public static int Main()
  {
    A a = new A();
    if(a.Foo == 10)
      return 1;
    else
      return 1;
  }

}
`
(5,10): error CS0106: The modifier 'virtual' is not valid for this item
`
using System;

public delegate void MyEventHandler();

public class CSEvent {

  [Obsolete]
  public int foo{
    get{
      return 0;
    }
    set{
    }
  }
  
  [Obsolete("Obsolete field")]
  public int bar;

  [Obsolete("This is Obsolete", true)]
  public event MyEventHandler CMyEvent;

  [Obsolete(null, true)]
  public void Fire() {
    if (CMyEvent != null) CMyEvent();
  }
}

public class MyClass {


  public static void MyMeth() {
    System.Console.WriteLine("foo");
  }

  public static void Main() {
    CSEvent mc = new CSEvent();
    mc.bar = 1;
    mc.foo = 5;
    int i = mc.foo;
    mc.CMyEvent += new MyEventHandler(MyMeth);
    mc.Fire();
  }
}
`
(37,5): warning CS0618: 'CSEvent.bar' is obsolete: 'Obsolete field'
(38,5): warning CS0612: 'CSEvent.foo' is obsolete
(39,13): warning CS0612: 'CSEvent.foo' is obsolete
(40,5): error CS0619: 'CSEvent.CMyEvent' is obsolete: 'This is Obsolete'
(41,5): error CS0613: 'CSEvent.Fire()' is obsolete
`
public class MyClass {  

  int intJ;

  private int this[int intI] {
    get {
      return intI + intJ;
    }
    set {
      intJ = intI + 1;
    }
  }
}


public class TestClass {
  public static int Main() {
    MyClass test = new MyClass();
    bool b =  (test[2] != 0);
    return 1;
  }
}
`
(19,16): error CS0021: Cannot apply indexing with [] to an expression of type 'MyClass'
`
public class MyClass {  

  //override modifier
  public override int MyMeth(){
    return 2;
  }  

  public static int Main() {
    return 1;
  }
}
`
(4,23): error CS0115: 'MyClass.MyMeth()': no suitable method found to override
`
class MyClass {

  readonly int intI = 1;

  public void OutTest(out int intJ) {
    intJ = 2;
  }

  public static int Main() {
    MyClass test = new MyClass();
    test.OutTest(out test.intI);
    return 1;
  }
}
`
(11,22): error CS0192: A readonly field cannot be passed ref or out (except in a constructor)
`
class A {
  public const int X = B.Z + 1;
  public const int Y = 10;
}
class B {
  public const int Z = A.Y + 1;
  public static int Main() {
    if((A.Y == 10) && (B.Z == 11) && (A.X == 12)) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
public class Outer {
  protected internal class MyBase {}
  public class MyClass : MyBase {
    public static int Main() {
      return 0;
    }
  }
}
`
(3,16): error CS0060: Inconsistent accessibility: base class 'Outer.MyBase' is less accessible than class 'Outer.MyClass'
(2,28): (Location of symbol related to previous error)
`
class A {
  public const int X = B.Z + 1;
}
class B {
  public const int Z = A.X + 1;
  
  public static int Main() {
    return 1;
  }

}
`
(2,20): error CS0110: The evaluation of the constant value for 'A.X' involves a circular definition
`
public class TestClass {
  public int MyProp {
    set;  
  }
}

public class MyClass {

  public static int Main() {
    return 1;  
  }
}
`
(3,5): error CS0501: 'TestClass.MyProp.set' must declare a body because it is not marked abstract or extern
`
public class MyClass {

  public int MyProp {
    set {
      get {return 1;}
    }
  }

  public static int Main() {
    return 1;
  }
}
`
(5,7): error CS1513: } expected
(9,17): error CS1518: Expected class, delegate, enum, interface, or struct
`
class MyClass {

  public int MyProp {
    virtual get {  
      return 1;
    }
  }

  public static int Main() {
    return 1;
  }
}
`
(4,5): error CS1609: Modifiers cannot be placed on property or event accessor declarations
`
class MyClass {

  private virtual int intI {
    get {
      return 1;
    }
  }

  public static int Main() {
    return 1;
  }

}
`
(3,3): error CS0621: 'MyClass.intI' : virtual or abstract members cannot be private
`
public class MyClass {

  public abstract int intI {
    set;
  }

  public static int Main() {
    return 1;
  }

}
`
(4,5): error CS0513: 'MyClass.intI.set' is abstract but it is contained in nonabstract class 'MyClass'
(1,14): (Location of symbol related to previous error)
`
class MyBase {
  public virtual int foo {
    get {
      return 1;
    }
  }  
}

class MyDerived : MyBase {
  private int get_foo() {
    return 1;
  }  
}

class MyDerived2 : MyDerived {
  public override int foo {
    get {
      return 2;
    }
  }

  public static int Main() {
    MyBase MB = new MyDerived2();
    if (MB.foo == 2) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
class MyBase {
  public virtual int foo {
    get {
      return 1;
    }
  }  
}

class MyDerived : MyBase {
  public new virtual int get_foo() {
    return 1;
  }  
}

class MyDerived2 : MyDerived {
  public override int foo {
    get {
      return 2;
    }
  }

  public static int Main() {
    return 1;
  }
}
`
(17,5): error CS0560: Accessor 'MyDerived2.foo.get' : cannot override 'MyBase.foo.get' because it is hidden by 'MyDerived.get_foo()'
(3,5): (Location of symbol related to previous error)
(10,26): (Location of symbol related to previous error)
`
public class MyClass {
  public int MyInt {
    get {
      return 2;
    }
  }

  public static int Main() {
    MyClass mc = new MyClass();
    int intJ = mc.get_MyInt();
    return 1;
  }
}
`
(10,16): error CS0571: 'MyClass.MyInt.get': cannot explicitly call operator or accessor
`
public abstract class MyBase {
  public abstract int intI {
    get;
    set;
  }  
}

public class MyClass : MyBase {

  public override int intI {
    get {
      return 1;
    }
    set{
    }
  }  

  public int MyMeth() {
    return base.intI = 5;
  }

  public static int Main() {
    return 1;
  }

}
`
(19,12): error CS0205: Cannot call an abstract base member: 'MyBase.intI'
`
public abstract class MyBase {
  public abstract int intI {
    get;
  }  
}

public class MyClass : MyBase {

  public override int intI {
    get {
      return 1;
    }
  }  

  public int MyMeth() {
    return base.intI;
  }

  public static int Main() {
    return 1;
  }

}
`
(16,12): error CS0205: Cannot call an abstract base member: 'MyBase.intI.get'
`
abstract public class B
{
        public int i;
}

public class A : B
{
        public override int i   // CS0544
        {
                get { return 0; }
                set {}
        }

        public static int Main()
        {
                return 1;
        }
}
`
(8,29): error CS0544: 'A.i' : cannot override; 'B.i' is not a property
(3,20): (Location of symbol related to previous error)
`
using System;

public class A 
{
  public int foo
  {
    get { return 0; }
    void foo(){}
  }
  public static int Main()
  {
    return 1;
  }
}
`
(8,5): error CS1014: A get or set accessor expected
(10,17): error CS1518: Expected class, delegate, enum, interface, or struct
(8,10): error CS0102: The type 'A' already contains a definition for 'foo'
(5,14): (Location of symbol related to previous error)
`
class MyClass {

  public int intI;

  public static int this[int intI] {
    get {
      intI = 2;
      return 2;
    }
  }

  public static int Main() {
    return 1;
  }
}
`
(5,10): error CS0106: The modifier 'static' is not valid for this item
`
class MyClass {

  const int test = 2L;

  public static int Main() {
    return 1;
  }
}
`
(3,20): error CS0029: Cannot implicitly convert type 'long' to 'int'
`
class BaseClass {
  private static int intI = 1;
}

class MyClass : BaseClass {
  public static int Main() {
    int intJ = intI;
    return 1;
  }
}
`
(7,16): error CS0122: 'BaseClass.intI' is inaccessible due to its protection level
(2,22): (Location of symbol related to previous error)
`
using System;

class BaseClass {
  private struct MyStruct{}
}

class MyClass : BaseClass {
  public static int Main() {
    MyStruct test = new MyStruct();
    return 1;
  }
}
`
(9,5): error CS0122: 'BaseClass.MyStruct' is inaccessible due to its protection level
`
using System;

class B
{
}

class A : B
{
   public static int Main()
   {
        return 1;
   }

   public void f1()
   {
      Console.WriteLine(base);   // CS0175
   }
}
`
(16,25): error CS0175: Use of keyword base is not valid in this context
`
using System;

enum ColorA {
  Red;
}

class Test 
{
  static int Main () 
  {
    return 1;
  }

}
`
(4,6): error CS1513: } expected
`
public class B
{
        public object i;
}

public class A : B
{
        public override void i() {}

        public static int Main()
        {
                return 1;
  }
}
`
(8,30): error CS0505: 'A.i()' : cannot override; 'B.i' is not a function
(3,23): (Location of symbol related to previous error)
`
abstract public class B
{
        abstract protected float f();
}

abstract public class A : B
{
        new public void f() {}   // CS0533

  public static int Main()
  {
    return 1;  
  }
}
`
(8,25): error CS0533: 'A.f()' hides inherited abstract member 'B.f()'
(3,34): (Location of symbol related to previous error)
`
class B
{
   public virtual int Prop
   {
      get { return 0; }
   }
}

class C : B
{
   public override int get_Prop()   // CS0561
   {
      return 0;
   }

   public static int Main() { return 1; }
}
`
(11,24): error CS0561: 'C.get_Prop()' : cannot override 'B.Prop.get' because it is a special compiler-generated method
(5,7): (Location of symbol related to previous error)
`
using System;

namespace Tests {

  public class Driver 
  {
      public static void Main() 
      {
        uint  dest = 0;
        if (dest != 4294967296 && 4294967296 > dest)
          Console.WriteLine("Pass");
        else
          Console.WriteLine("Fail");
        return;
      }
  }

}
`
(10,13): warning CS0652: Comparison to integral constant is useless; the constant is outside the range of type 'uint'
(10,35): warning CS0652: Comparison to integral constant is useless; the constant is outside the range of type 'uint'
Pass
`
using System;

namespace Tests {

  public class Driver 
  {
      public static void Main() 
      {
        uint  dest = (uint)4294967296;
      }
  }

}
`
(9,28): error CS0221: Constant value '4294967296' cannot be converted to a 'uint' (use 'unchecked' syntax to override)
`
class C
{
       public static int Main()
       {
                return 1;
       }

       void f1()
       {
                base();
       }
}
`
(10,17): error CS0175: Use of keyword base is not valid in this context
`
abstract public class B
{
  public abstract float foo { set; }
}

abstract class A : B
{
  new protected enum foo {}

  public static int Main()
  {
    return 1;  
  }
}
`
(8,22): error CS0533: 'A.foo' hides inherited abstract member 'B.foo.set'
(3,31): (Location of symbol related to previous error)
`
using System;

abstract class B
{
}

abstract class D : B
{
   public override event EventHandler foo;
}

class C : D
{
   public override void add_foo(EventHandler eh) {}

   public static int Main() { return 1; }
}
`
(9,39): error CS0115: 'D.foo': no suitable method found to override
(14,25): error CS0561: 'C.add_foo(System.EventHandler)' : cannot override 'D.foo.add' because it is a special compiler-generated method
(9,39): (Location of symbol related to previous error)
`
using System;

abstract class B
{
   public abstract event EventHandler foo{
     add;
   }
}


class C
{

   public static int Main() { return 1; }
}
`
(6,9): error CS0073: An add or remove accessor must have a body
`
using System;

abstract class B
{
   public abstract event EventHandler foo;
}

abstract class D : B
{
   public override event EventHandler foo;
}

class C : D
{
   public override void add_foo(EventHandler eh) {}

   public static int Main() { return 1; }
}
`
(15,25): error CS0561: 'C.add_foo(System.EventHandler)' : cannot override 'D.foo.add' because it is a special compiler-generated method
(10,39): (Location of symbol related to previous error)
`
using System;

sealed class MyClass {

  protected int intI = 0;
  
  public static int Main() {
    return 0;
  }
}
`
(5,17): warning CS0628: 'MyClass.intI' : new protected member declared in sealed class
`
using System;

sealed class MyClass {

  protected class MyNested {}

  
  public static int Main() {
    return 0;
  }
}
`
(5,19): warning CS0628: 'MyClass.MyNested' : new protected member declared in sealed class
`
using System;

public class Test
{
    public static int Main(string [] args)
    {  
      sbyte sb = 0x01;
      sb = (sbyte)(sb << 7);
      if (sb != unchecked((sbyte)0xFFFFFF80)) 
        return(1);
      sb = (sbyte)(sb >> 7);
      if (sb != -1)
        return(1);

      short sh = 0x01;
      sh = (short)(sh << 15);
      if (sh != unchecked((short)0xFFFF8000)) 
        return(1);
      sh = (short)(sh >> 15);
      if (sh != -1)
        return(1);

      int in1 = 0x01;
      in1 = in1 << 31;
      if (in1 != unchecked((int)0x80000000))
        return(1);
      in1 = in1 >> 31;
      if (in1 != -1)
        return(1);

      long lo = 0x01;
      lo = lo << 63;
      unchecked {
        if (lo != (long)0x8000000000000000)
          return(1);
      }
      lo = lo >> 63;
      if (lo != -1) {
        return(1);
      }
      return(0);
    }
}
`
`
public class MyClass {

  public static int Main() {
    bool b = (byte)true;
    return 1;
  }

}
`
(4,20): error CS0030: Cannot convert type 'bool' to 'byte'
`
using System;

abstract class D
{
   public abstract event EventHandler foo;
}

abstract class B : D
{
   public override event EventHandler foo { add {} remove {} }
}

class C : B
{
   public override void add_foo(EventHandler eh) {}

   public static int Main() { return 1; }
}
`
(15,25): error CS0561: 'C.add_foo(System.EventHandler)' : cannot override 'B.foo.add' because it is a special compiler-generated method
(10,45): (Location of symbol related to previous error)
`
using System;

public class MyClass {

  public int intI = 2;
  public int intK = intI;

  public static int Main() {
    return 1;
  }
}
`
(6,21): error CS0236: A field initializer cannot reference the nonstatic field, method, or property 'MyClass.intI'
`
class MyClass {

  static MyClass() {
    MyMeth1(ref intI);
    MyMeth2(out intJ);
  }

  public static void MyMeth1(ref int i) {
    i = 2;
  }

  public static void MyMeth2(out int j) {
    j = 3;
  }


  public static readonly int intI;
  public static readonly int intJ;
  

  public static int Main() {
    if ((MyClass.intI == 2) && (MyClass.intJ == 3)) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
using System;
using System.Reflection;
using System.Runtime.CompilerServices;

class MyClass {

  public readonly volatile int test = 10;

  public static int Main() {
    return 1;
  }
}
`
(7,32): error CS0678: 'MyClass.test': a field can not be both volatile and readonly
`
`/warnaserror
using System;

class Test {
  static volatile int x;
  static void meth(out int x) { x = 10; }
  static int Main() { 
    meth(out x);
    return 1;
  }
}
`
(7,14): error CS0420: 'Test.x': a reference to a volatile field will not be treated as volatile
`
using System;

class Test {
  public volatile const int x = 1;
  static int Main() { 
    return 1;
  }
}
`
(4,10): error CS0106: The modifier 'volatile' is not valid for this item
`
using System;

class Test {
  static volatile long x;
  static int Main() { 
    x = 1;
    return 1;
  }
}
`
(4,24): error CS0677: 'Test.x': a volatile field can not be of the type 'long'
`
abstract class MyBase {
  //abstract modifier
  abstract int MyMeth();
}

class MyClass {  

  public static int Main() {
    return 1;
  }
}
`
(3,3): error CS0621: 'MyBase.MyMeth' : virtual or abstract members cannot be private
`
using System;

enum E {} 
class Test {
  static volatile E x;
  static int Main() { 
    x = 0;
    if (x == 0)
      return 0;
    return 1;
  }
}
`
`
using System;

class Test {
  static volatile char x;
  static int Main() { 
    x = 'A';
    if (x == 'A')
      return 0;
    return 1;
  }
}
`
`
public class Test {
  //extern modifier
  extern public int MyMeth();
}

public class MyClass {  

  public static int Main() {
    return 0;
  }
}
`
(3,21): warning CS0626: Method, operator, or accessor 'Test.MyMeth()' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation
`
public class MyClass {  

  //extern modifier
  extern public int MyMeth() {
    return 1;
  }

  public static int Main() {
    return 0;
  }
}
`
(4,21): error CS0179: 'MyClass.MyMeth()' cannot be extern and declare a body
`
public class MyClass {  

  public int RetInt(out int intI) {
    intI = 2;
    return 2;
  }

  public int RetInt(ref int intI) {
    return 3;
  }

  public int RetInt(int intI) {
    return 4;
  }


  public static int Main() {
    return 1;
  }
}
`
(8,14): error CS0663: 'RetInt' cannot define overloaded methods which differ only on ref and out
(3,14): (Location of symbol related to previous error)
`
public class BaseClass {

  public virtual int Test() {
    return 1;
  }
}

public class BaseClass2 : BaseClass {
  new public int Test() {
    return 2;
  }
}

public class MyClass : BaseClass2 {
  public override int Test() {
    return 3;
  }
  public static int Main() {return 1;
  }
}
`
(15,23): error CS0506: 'MyClass.Test()' : cannot override inherited member 'BaseClass2.Test()' because it is not marked virtual, abstract, or override
(9,18): (Location of symbol related to previous error)
`
abstract public class MyClass {

  [dllimport("kernel32")]
  public abstract static extern bool RemoveDirectory(string name);

  public static int Main() {
    return 1;
  }
}
`
(3,4): error CS0246: The type or namespace name 'dllimport' could not be found (are you missing a using directive or an assembly reference?)
(4,38): error CS0112: A static member 'MyClass.RemoveDirectory(string)' cannot be marked as override, virtual, or abstract
(4,38): error CS0180: 'MyClass.RemoveDirectory(string)' cannot be both extern and abstract
`
using System;
using System.Runtime.InteropServices;

abstract public class MyClass {

  [DllImport("kernel32.dll")]
  public static void RemoveDirectory(string name){}

  public static int Main() {
    return 1;
  }
}
`
(6,4): error CS0601: The DllImport attribute must be specified on a method marked 'static' and 'extern'.
`
using System;
using System.Runtime.InteropServices;

abstract public class MyClass {

  [DllImport("kernel32.dll")]
  public extern bool RemoveDirectory(string name);

  public static int Main() {
    return 1;
  }
}
`
(6,4): error CS0601: The DllImport attribute must be specified on a method marked 'static' and 'extern'.
`
public class MyClass {

  [one] public bool field;
  [three] public bool property { get { return true; }}
  [two] public bool method() {}

  public static int Main() {
    return 1;
  }
}
`
(3,4): error CS0246: The type or namespace name 'one' could not be found (are you missing a using directive or an assembly reference?)
(4,4): error CS0246: The type or namespace name 'three' could not be found (are you missing a using directive or an assembly reference?)
(5,4): error CS0246: The type or namespace name 'two' could not be found (are you missing a using directive or an assembly reference?)
`
public class TestClass {

  public int IntI = 2;

  public static implicit operator int(TestClass t) {
    return t.IntI;
  }  
}

public class MyClass {

  public long RetVal() {
    TestClass tc = new TestClass();
    return tc;
  }

  public static int Main() {
    MyClass test = new MyClass();
    if (test.RetVal() == 2) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
using System;

public class MyClass {

  public int MyMeth(params int[][] values, int intJ) {
    return 1;
  }

  public static int Main() {
    return 1;
  }
}
`
(5,21): error CS0231: A params or __arglist parameter must be the last parameter in a formal parameter list
`
using System;

public class MyClass {

  public int MyMeth(params int values) {
    return 1;
  }

  public static int Main() {
    return 1;
  }
}
`
(5,21): error CS0225: The params parameter must be a single dimensional array
`
using System;

public class MyClass {

  public int MyMeth1(short x, short y){
    return 1;
  }

  public int MyMeth1(int x, int y){
    return 2;
  }


  public static int Main() {
    MyClass mc = new MyClass();
    short s1 = 1;
    int i1 = 2;
    if ((mc.MyMeth1(s1,i1) == 2)) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
using System;

public class MyClass {

  public int MyMeth1(params short[] values) {
    return 1;
  }

  public int MyMeth1(params int[] values) {
    return 2;
  }

  public static int MyMeth2(params short[] values) {
    return 1;
  }

  public static int MyMeth2(params int[] values) {
    return 2;
  }

  public static int Main() {
    MyClass mc = new MyClass();
    short s1 = 1;
    int i1 = 2;
    if ((mc.MyMeth1(s1,i1) == 2) && (MyMeth2(s1,i1) == 2)) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
using System;

namespace Tests {
  public class Driver{
    public static void Main(){
      ulong dest = -1;
      if (dest <= -1)
        Console.WriteLine("Pass");
      else
        Console.WriteLine("Fail");
      return;
    } 
  }
}
`
(6,20): error CS0031: Constant value '-1' cannot be converted to a 'ulong'
(7,11): error CS0034: Operator '<=' is ambiguous on operands of type 'ulong' and 'int'
`
using System;
namespace Simple
{
    public enum SomeType2
    {
        Type1 = 100,
        Type2,
        Type3
    }

    public class SimpleEnum
    {
        public static int Main()
        {
        SomeType2[] tt = new SomeType2[2];
        tt[0] = SomeType2.Type1;
        tt[1] = SomeType2.Type1;
        Console.WriteLine(tt[0].ToString());
        Console.WriteLine(tt[1].ToString());
        int nInt = (int) tt[1];
        Console.WriteLine(nInt.ToString());
        int i = (int)tt[0] + (int)tt[1] + nInt - 300;
        if (0 == i) Console.WriteLine ("PASS");
        else Console.WriteLine ("FAIL");
        return i;
        }
    }
}
`
Type1
Type1
100
PASS
`
using System;

namespace Tests {

public class Driver 
{
    public static void Main() 
    {
    short  x = 0;

    x += 5;    // expands to x = x + 5. Normally, this would give an error, because x + 5 is an int.
    Console.WriteLine(x);
  }
}

}
`
5
`
using System;

struct Struct1 {
  public int pub;
  private int priv;
  internal int intern;

  public int TestPubPriv()
  {
    return TestPriv();
  }

  private int TestPriv() 
  {
    pub = 1;
    priv = 2;

    return(pub + priv);
  }

  internal int TestIntern()
  {
    intern = 3;
    return(intern);
  }

  public int GetPrivate()
  {
    return(priv);
  }
}

public class Test
{
  public static int Main(string [] args)
  {
    Struct1 s1 = new Struct1();
    int result;

    result = s1.TestPubPriv();
    result += s1.TestIntern();

    result -= s1.intern;
    result -= s1.pub;
    result -= s1.GetPrivate();

    return(result);
  }

}
`
`
using System;

struct Struct1 {
  public Struct1(int j) { i = j; }
  ~Struct1() { Console.WriteLine("Destructor called"); }
  public int i;
}

public class Test
{
    public static int Main(string [] args)
    {
        Struct1 s = new Struct1(42);
        return(s.i - 42);
    }
}
`
(5,4): error CS0575: Only class types can contain destructors
`
using System;

public interface IA
{
  int foo();
}


public struct A : IA 
{
  public IA GetI()
  {
    this.i = 10;
    return this;
  }

  public int foo()
  {
    return i;
  }

  public int i;
}

public class AA
{
  public static int Main()
  {
    A a = new A();
    object o = a;  // boxing

    bool b = o is IA;
    
    if(!b)
      return 1;


    if((a as IA) == null)
      return 1;

        if(a.GetI().foo() != 10)
      return 1;
    else
      return 0;
  }

}
`
`
delegate void foo();

public struct A
{
  event foo ev = new foo(f1);   // CS0573

  static void f1(){}
  public static int Main() { return 1; }
}
`
(5,18): error CS0573: 'A.ev': cannot have instance field initializers in structs
`
struct S1
{
  public S2 s2;
}

struct S2
{
  public S1 s1;
  public static int Main()
  {
    return 1;
  }

}
`
(3,13): error CS0523: Struct member 'S1.s2' of type 'S2' causes a cycle in the struct layout
(8,13): error CS0523: Struct member 'S2.s1' of type 'S1' causes a cycle in the struct layout
`
using System;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public interface MyStruct
{
  //[FieldOffset(0)]
  /*
  public static int i;
  public static int Main ()
  {
    return 1;
  }
  */
}
`
(4,2): error CS0592: Attribute 'StructLayout' is not valid on this declaration type. It is valid on 'class, struct' declarations only.
`
using System;
struct Conv
{
  
  public void TryMe()
  {
    lock(this) {}
  }
  public static int Main()
  {
      return 0;
  }    
}
`
(7,10): error CS0185: 'Conv' is not a reference type as required by the lock statement
`
using System;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit, CharSet=CharSet.None)]
public struct MyStruct
{
  //[FieldOffset(0)]
  public static int i;
  public static int Main ()
  {
    return 1;
  }
}
`
(4,36): error CS0647: Error emitting 'System.Runtime.InteropServices.StructLayoutAttribute' -- argument 'CharSet' is invalid
`
using System;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit, Pack=3)]
public struct MyStruct
{
  //[FieldOffset(0)]
  public static int i;
  public static int Main ()
  {
    return 1;
  }
}
`
(4,36): error CS0647: Error emitting 'System.Runtime.InteropServices.StructLayoutAttribute' -- argument 'Pack' is invalid
`
using System;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit, Size=-3)]
public struct MyStruct
{
  //[FieldOffset(0)]
  public static int i;
  public static int Main ()
  {
    return 1;
  }
}
`
(4,36): error CS0647: Error emitting 'System.Runtime.InteropServices.StructLayoutAttribute' -- argument 'Size' is invalid
`
using System;
using System.Runtime.InteropServices;

public struct MyStruct
{
  [FieldOffset(0)]
  public static int i;
  public static int Main ()
  {
    return 1;
  }
}
`
(6,4): error CS0636: The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)
`
using System;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct MyStruct
{
  [FieldOffset(0)]
  public static int i;
  public static int Main ()
  {
    return 1;
  }
}
`
(7,4): error CS0637: The FieldOffset attribute is not allowed on static or const fields
`
using System;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
public struct MyStruct
{
  [FieldOffset(-1000)]
  public int i;
  public static int Main ()
  {
    return 1;
  }
}
`
(7,16): error CS0647: Error emitting 'System.Runtime.InteropServices.FieldOffsetAttribute' -- argument 'Value' is invalid
`
interface InterfaceS 
{
  int TestMethodS();
}

interface InterfaceT : InterfaceS
{
  int TestMethodT();
}

class MyClass : InterfaceS, InterfaceT
{
  public int TestMethodS()
  {
    return 0;
  }
  public int TestMethodT()
  {
    return 0;
  }
}

class ArrayCovariance
{
  public static int Main()
  {
    InterfaceS[] ifs = new InterfaceT[10];
    InterfaceT[] ift = new InterfaceT[10];

    MyClass mc = new MyClass();

    for (int x = 0; x < 10; x++)
    {  
      ifs[x] = new MyClass();
      ift[x] = new MyClass();
    }

    ift = (InterfaceT[])ifs;

    return 0;
  }
}
`
(30,13): warning CS0219: The variable 'mc' is assigned but its value is never used
`
using System;

struct Foo {
  public Foo(int x): this(5, 6) {
  }

  public Foo(int x, int y) {
    m_x = x;
    m_y = y;
  }

  public int m_x;
  public int m_y;
}


public class MyClass
{

  static public int Main(String[] args)
  {
    Foo s1 = new Foo(1);

    if (s1.m_x != 5)
      return(1);
    if (s1.m_y != 6)
      return(1);

    return 0;
  }
}
`
`
using System;

public class foo{
  public static foo operator+(foo fee, foo fum){return fee;}
  public static foo operator+(foo fee){return fee;}
}

public class bar : foo{}

public class Test{
  public static int Main(string[] args){
    bar b = new bar();
    foo f = b + b;
    if (f != b) return 1;
    f = +b;
    if (f != b) return 1;
    return 0;
  }
}
`
`
using System;

public delegate int MyDelegate(params int[] values);

public class MyClass {

  public int MyMeth1(params int[] values) {
    return values[0] + values[1] + values [2];
  }

  public MyDelegate md;

  public static int Main() {

    int intI = 1;
    int intJ = 2;
    int intK = 3;

    MyClass mc = new MyClass();
    mc.md = new MyDelegate(mc.MyMeth1);

    if (mc.md(intI, intJ, intK) == 6) {
      return 0;
    }
    else {
      return 1;
    }
  }  
}
`
`
using System;

public delegate int MyDelegate(params int[] values, int foo);

public class MyClass {

  public static int Main() {
    return 1;
  }  
}
`
(3,32): error CS0231: A params or __arglist parameter must be the last parameter in a formal parameter list
`
using System;

public delegate int MyDelegate(int[] values, int foo);

public class MyClass {

  public int MyMeth1(params int[] values) {
    return values[0] + values[1] + values [2];
  }
  public int MyMeth1(int values) {
    return 0;
  }
  public int MyMeth1(int[] values, float foo) {
    return values[0] + values[1] + values [2];
  }
  
  //public int MyMeth2;

  public MyDelegate md;

  public static int Main() {
    MyClass mc = new MyClass();
    mc.md = new MyDelegate(mc.MyMeth2);
    return 1;
  }  
}
`
(23,31): error CS0117: 'MyClass' does not contain a definition for 'MyMeth2'
`
using System;

public delegate int MyDelegate(int[] values, int foo);

public class MyClass {

  public int MyMeth1(params int[] values) {
    return values[0] + values[1] + values [2];
  }
  public int MyMeth1(int values) {
    return 0;
  }
  public int MyMeth1(int[] values, float foo) {
    return values[0] + values[1] + values [2];
  }
  
  public int MyMeth2;

  public MyDelegate md;

  public static int Main() {
    MyClass mc = new MyClass();
    mc.md = new MyDelegate(mc.MyMeth2);
    return 1;
  }  
}
`
(23,31): error CS0118: 'MyClass.MyMeth2' is a 'field' but is used like a method
`
using System;

public delegate int MyDelegate(int[] values, int foo);

public class MyClass {

  public int MyMeth1(params int[] values) {
    return values[0] + values[1] + values [2];
  }
  public int MyMeth1(int values) {
    return 0;
  }
  public int MyMeth1(int[] values, float foo) {
    return values[0] + values[1] + values [2];
  }
  
  public MyDelegate md;

  public static int Main() {
    MyClass mc = new MyClass();
    mc.md = new MyDelegate(mc.MyMeth1);
    return 1;
  }  
}
`
(21,31): error CS0123: No overload for 'MyMeth1' matches delegate 'int MyDelegate(int[], int)'
(3,21): (Location of symbol related to previous error)
(7,14): (Location of symbol related to previous error)
`
using System;

namespace test
{
  class Test {
    
    static void Main() {
        decimal total = 0;
        Decimal d = 5.555m;
        total ^= d;
        Console.WriteLine(total);
    }
  }

}
`
(10,9): error CS0019: Operator '^' cannot be applied to operands of type 'decimal' and 'decimal'
`
using System;

namespace test
{
  class Test {
    
    static void Main() {
        decimal total = 0;
        decimal d = 5.555m;
        total += d;
        Console.WriteLine(total.ToString(System.Globalization.CultureInfo.InvariantCulture));
    }
  }
}
`
5.555
`
public class MyClass {  

  int intJ;

  protected int this[int intI] {
    get {
      return intI + intJ;
    }
    set {
      intJ = intI + 1;
    }
  }
}


public class TestClass : MyClass {
  public static int Main() {
    MyClass test = new MyClass();
    test[1] = 1;
    return 1;
  }
  public void foo(){
    base[1] = 1;
  }  
}
`
(19,5): error CS1540: Cannot access protected member 'MyClass.this[int]' via a qualifier of type 'MyClass'; the qualifier must be of type 'TestClass' (or derived from it)
`
using System;

public class MyClass {

  public event int MyEvent;

  public static int Main() {
    return 1;
  }
}
`
(5,20): error CS0066: 'MyClass.MyEvent': event must be of a delegate type
`
using System;

class A
{
  public static int Main()
  {
    bool[][] arr;
    arr = new bool[3][] {new bool[] {true,false}, new bool[] {true,false}, new bool[] {true,false}};

    int result = 0;
    
    // verify all elements were assigned correctly
    bool verifier = true;
    for (int x = 0; x < 3; x++)
    {
      for (int y = 0; y < 2; y++)
      {
        if (arr[x][y] != verifier)
          result = 1;
        verifier = !verifier;
      }
    }

    if (arr.Length != 3)
      result = 1;

    return result;
  }
}
`
`
class A
{
  public static int Main()
  {
    int[] arr = new int[1.0];    

    return 0;
  }
}
`
(5,25): error CS0029: Cannot implicitly convert type 'double' to 'int'
`
class A
{
  public static int Main()
  {
    const int x = -1;
    int[] arr = new int[x];    

    return 0;
  }
}
`
(6,25): error CS0248: Cannot create an array with a negative size
`
using System;

namespace Microsoft.Conformance.Expressions {

  enum AA {a = 1, b = 2}

  public class arith024 {
    public static int Main()
    {
      AA MyEnum = AA.a + 3; //E+U

      if ((int)MyEnum == 4) {
        return 0;
      }
      else {
        return 1;
      }      
    }
  }
}
`
`
using System;

public sealed class MyClass {

  public virtual void MyMeth() {}

  public static int Main () {
    return 1;
  }

}
`
(5,10): error CS0549: New virtual member in a sealed class
`
using System;

public class MyClass {

  public void MyMeth(params int[] i) {}

  public static int Main() {

    MyClass MC = new MyClass();
    MC.MyMeth("bogus");

    return 1;
  }
}
`
(10,15): error CS0029: Cannot implicitly convert type 'string' to 'int'
`
using System;

public class MyClass {

  public int MyMeth(int i, int j, params int[] k) {
    return i + j;
  }

  public static int Main() {

    MyClass MC = new MyClass();

    if (MC.MyMeth(1,2) == 3) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
using System;

public class MyClass {

  public sealed int MyMeth(int intI) {
    return 1;
  }  

}

public class TestClass {
  public static int Main() {

    MyClass MC = new MyClass();


    if (MC.MyMeth(1) == 2) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
(5,10): error CS0238: 'MyClass.MyMeth' cannot be sealed because it is not an override
`
class A
{
  public static int Main()
  {
    System.Array SystemArray;
    int[]  StaticArray = new int[] {10, 20, 30, 40};

    // There exists an implicit reference conversion for this
    SystemArray = StaticArray;

    if (SystemArray[0] == 10)
        return 1;

    return 0;
  }
}
`
(11,9): error CS0021: Cannot apply indexing with [] to an expression of type 'System.Array'
`
using System;

[Flags]
enum MyFlag{
  Zero = 0x0000,
  First   = 0x0001,
  Second   = 0x0002,
  Third    = 0x0004,
  Fourth   = 0x0008,
}

public class A
{
  public static int Main()
  {
    MyFlag r = MyFlag.First | MyFlag.Fourth;

    r+= 0x00f;  // out of range

    Console.WriteLine(r.ToString());
    return (int)r == (int)24 ? 0 : 1;
  }
}
`
24
`
class Test
{
  static int Main()
  {
      System.TypedReference[] arr;
  }
}
`
(5,7): error CS0611: Array elements cannot be of type 'System.TypedReference'
`
class Test
{
  static int Main()
  {
      object arr = new System.ArgIterator[1];
  }
}
`
(5,20): error CS0611: Array elements cannot be of type 'System.ArgIterator'
`
class A
{
  public static int Main()
  {
    int[] arr = new int[10];

    arr[5] = 100;

    double idx = 5d;

    if (arr[idx] == 100)
      return 0;
    else
      return 1;
  }
}
`
(11,13): error CS0029: Cannot implicitly convert type 'double' to 'int'
`
class A
{
  public static int Main()
  {
    decimal[] arr = new decimal[5];

    arr[3] = (decimal)1.00;

    return 0;
  }
}
`
`
public class Test
{
   public static void Main()
   {
      int[] a = new int[10];
      a[0,1] = 9;
   }
}
`
(6,7): error CS0022: Wrong number of indices inside [], expected '1'
`
class foo{
  class bar{}
}
class xyx : foo.bar{
}
`
(4,13): error CS0122: 'foo.bar' is inaccessible due to its protection level
`
using System;

public class MyBase {
  public virtual int RetInt() {
    return 1;
  }
}

public class MyClass : MyBase {

  public sealed override int RetInt() {
    return 2;
  }

  public static int Main () {
    MyClass MC = new MyClass();
    if (MC.RetInt() == 2) {
      return 0;
    }
    else {
      return 1;
    }
  }

}
`
`
class A
{
  public static int Main()
  {
    int[] arr = new int[10];

    arr[5] = 100;

    long idx = 5L;

    if (arr[idx] == 100)
      return 0;
    else
      return 1;
  }
}
`
`
using System;

delegate void del();

public class C {

    public static int retval = 3;
    public void bar () {Console.WriteLine("bar"); retval -= 1;}
    static public void far ()
        {
        Console.WriteLine("far");
        retval -= 2;
        }
}

public class start {
    static bool loo() {return true;}

    static public int Main ()
        {
        C p = new C();
        del foo1 = new del(C.far);
        del foo2 = new del(p.bar);
        del foo3 = foo1 + foo2;
        foo3();
        if (C.retval == 0) Console.WriteLine ("PASS");
        else Console.WriteLine ("FAIL, retval=="+C.retval.ToString());
        return C.retval;
        }
}
`
far
bar
PASS
`
using System;

public class MyBaseClass 
{

  public virtual int MyMeth(int intI) 
  {
    return 1;
  }  
}

public class MyClass : MyBaseClass
{

  public sealed override int MyMeth(int intI) 
  {
    return 3;
  }  

}

public class MyDerivedClass : MyClass
{

  public override int MyMeth(int intI) 
  {
    return 3;
  }  

}

public class TestClass 
{
  public static int Main() {
    return 1;
  }
}
`
(25,23): error CS0239: 'MyDerivedClass.MyMeth(int)' : cannot override inherited member 'MyClass.MyMeth(int)' because it is sealed
(15,30): (Location of symbol related to previous error)
`
public class MyClass {  

  int intJ;

  protected int this[int intI] {
    get {
      return intI + intJ;
    }
    set {
      intJ = intI + 1;
    }
  }
}


public class TestClass : MyClass {
  public static int Main() {
    TestClass test = new TestClass();
    test[1] = 1;
    if (test[1] == 3) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
using System;


interface IFoo
{
  event EventHandler E { add { } remove { } }
}

class Test 
{
  public static int Main()
  {
    return 1;
  }
}
`
(6,26): error CS0069: 'IFoo.E': event in interface cannot have add or remove accessors
`
using System;

class Test1
{
  public delegate void invalidDelegate();
}



class Test2: Test1
{
  public override event EventHandler invalidDelegate;  // CS0072

  static public int Main()
  { return 1;}
}
`
(12,38): error CS0072: 'Test2.invalidDelegate' : cannot override; 'Test1.invalidDelegate' is not an event
(5,24): (Location of symbol related to previous error)
`
using System;

class A
{
    public static int ElementTaker(ref int val)
    {
        val += 5;
        return val;
    }
    
    public static int Main()
  {
    int[] arr = new int[5] {1,2,3,4,5};
        Console.WriteLine(ElementTaker(ref arr[2]));

        if (arr[2] != 8)
            return 1;

        return 0;    
  }
}
`
8
`
class A
{
  public static int Main()
  {
    int arr[] = new int[10];    

    return 0;
  }
}
`
(5,12): error CS0650: Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier
`
class Test
{
    public void Method(string arg[])
    {
    }

  static void Main() {}
}
`
(3,34): error CS1552: Array type specifier, [], must appear before parameter name
`
class A
{
  public static int Main()
  {
    decimal[] arr;
    arr = new decimal[5] {1.0m,2.0m,3.0m,4.0m,5.0m};

    int x = 0;

    if (arr[0] != 1.0m)
      x = 1;
    if (arr[1] != 2.0m)
      x = 1;
    if (arr[2] != 3.0m)
      x = 1;
    if (arr[3] != 4.0m)
      x = 1;
    if (arr[4] != 5.0m)
      x = 1;

    return x;
  }
}
`
`
interface ICloneable
{
    string this[string hashkey] { get; set; }
}

interface IComparable
{
    int CompareTo(object other);
}

class ListEntry : ICloneable, IComparable
{
    public string st = "";

    string ICloneable.this[string hashkey]
    {
        get 
        {
            return "success";
        }
        set 
        {
            st = value;
        }
    }
    
    int IComparable.CompareTo(object other)
    {
        return 0;
    }
}

class Test
{
    public static int Main() 
    {
        ListEntry le = new ListEntry();
        ((ICloneable)le)["test"] = "correct";
        string s = ((ICloneable)le)["test"];

        if ( le.st == "correct" && s == "success" )
            return 0;
        else
            return 1;
    }
}
`
`
interface first 
{
  int x = 4;
}

class main 
{
  public static void Main() {}
}
`
(3,3): error CS0525: Interfaces cannot contain fields
`
public class MyClass {

  int intI;

  int this[] {
    get {
      return intI;
    }
    set {
      intI = value;
    }
  }

  public static int Main() {
    return 1;
  }
}
`
(5,12): error CS1551: Indexers must have at least one parameter
`
using System;

class CFoo
{
  public event EventHandler E { add {} }
}

class Test 
{
  public static int Main()
  {
    return 1;
  }
}
`
(5,29): error CS0065: 'CFoo.E' : event property must have both add and remove accessors
`
using System;

class A
{
  public static int Main()
  {
        try
        {
            int[] arr = new int[2147483648];
        }
        catch (OverflowException)
        {
            return 0;
        }

    return 1;
  }
}
`
(9,19): warning CS0219: The variable 'arr' is assigned but its value is never used
`
using System;
using System.Reflection;

[assembly:AssemblyVersion("4.3.*.*")]

public class C {
  public static int Main () {
    return 1;
  }
}
`
(4,11): error CS0647: Error emitting 'System.Reflection.AssemblyVersionAttribute' -- argument '4.3.*.*' is invalid
`
interface I1
{ 
   int foo();
}

interface I2 
{
   int foo();
}

class Bar : I1, I2
{
    public int foo() { return 0; }
}

class main
{
    public static int Main()
    {
        Bar x = new Bar();
        
        I1 a = x; 
        I2 b = x; 
        
        if (a == b)
        {
            return 0;
        }

        return 1;
    }
}
`
`
using System;

public abstract class MyClass {

  private abstract int MyMeth(int intI);  

  public int MyMeth(params int[] intI) {
    return 2;
  }

}

public class TestClass {
  public static int Main() {
    return 1;
  }
}
`
(5,3): error CS0621: 'MyClass.MyMeth' : virtual or abstract members cannot be private
`
public class MyClass {

  int intI;

  int this[out int intJ] {
    get {
      intJ = 2;
      return intI;
    }
    set {
      intJ = 2;
      intI = value;
    }
  }

  public static int Main() {
    return 1;
  }
}
`
(5,12): error CS0631: Indexers can't have ref or out parameters
`
using System;

public class A
{
  public event EventHandler Foo{
    add{
    }
    remove{
    }
  }

  public void H1(object sender, EventArgs arg) {}

  public static int Main()
  {
    A a = new A();
    a.Foo = new EventHandler(a.H1);

    return 1;
  }
}
`
(17,5): error CS0079: The event 'A.Foo' can only appear on the left hand side of += or -=
`
using System;

public class A
{
  public event EventHandler Foo;
}

public class B{

  public void H1(object sender, EventArgs arg) {}

  public static int Main()
  {
    A a = new A();
    B b = new B();
    a.Foo = new EventHandler(b.H1);

    return 1;
  }
}
`
(16,5): error CS0070: The event 'A.Foo' can only appear on the left hand side of += or -= (except when used from within the type 'A')
`
using System;

class A
{
    public static int ElementTaker(int val)
    {
        return val;
    }
    
    public static int Main()
  {
        int[][] arr = new int[][] { new int[] {1,2}, new int[] {3,4}, new int[] {5,6}};
        Console.WriteLine(ElementTaker(arr[2][1]));

        return 0;    
  }
}
`
6
`
using System;

public class MyClass
{

  public int MyMeth(params ref int[] mbc) 
  {
    return 1;
  }  

}

public class TestClass 
{
  public static int Main() 
  {
    return 1;
  }
}
`
(6,28): error CS1611: The params parameter cannot be declared as ref or out
`
public class MyClass {

  public int this [int intI]{
    set {}
  }

  public static int Main() {
    MyClass test = new MyClass();
    int intJ = test[1];
    return 1;
  }
}
`
(9,16): error CS0154: The property or indexer 'MyClass.this[int]' cannot be used in this context because it lacks the get accessor
`
using System;

class Test
{
  public event EventHandler MyEvent
  {
    j +=
  }

  public static int Main()
  {
    return 1;
  }

  int i, j;
}
`
(7,5): error CS1055: An add or remove accessor expected
`
class A
{
  public static int Main()
  {
    int[] arr = new int[5m];    

    return 0;
  }
}
`
(5,25): error CS0029: Cannot implicitly convert type 'decimal' to 'int'
`
class A
{
  public static int Main()
  {
    object[] arr = {{1,2,3,4,5}};

    return 0;
  }
}
`
(5,21): error CS0623: Array initializers can only be used in a variable or field initializer. Try using a new expression instead.
`
using System;

interface I
{
  int P { get; }
  void m();
}

class C : I
{
  void I.m() {}
  int I.get_P() { return 0; }              // error should be generated here
  public   int P { get { return 0; } }

  static void Main() {}
}
`
(12,9): error CS0683: 'C.I.get_P()' explicit method implementation cannot implement 'I.P.get' because it is an accessor
`
public delegate void foo();

public class B
{
   public foo fooDel;

   public virtual event foo fooEv
   {
    add {}
    remove {}
   }
}

public class A : B
{
   event foo fooEv // CS0114
   {
        add {}
        remove {}
   }

   public static void Main() {}
}
`
(16,14): warning CS0114: 'A.fooEv' hides inherited member 'B.fooEv'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.
(7,29): (Location of symbol related to previous warning)
`
using System;

public abstract class Test
{
   abstract public event EventHandler e = null;   // CS0074

   public static int Main()
   {
     return 1;
   }
}
`
(5,39): error CS0074: 'Test.e': abstract event cannot have an initializer
`
using System;

class A
{
  const long myLength = 5;

  public static int Main()
  {
    int[] arr = new int[(int)myLength] {1,2,3,4,5};

    int x = 0;
    if (arr[0] != 1)
      x = 1;      
    if (arr[1] != 2)
      x = 1;      
    if (arr[2] != 3)
      x = 1;      
    if (arr[3] != 4)
      x = 1;      
    if (arr[4] != 5)
      x = 1;      

    return x;
  }
}
`
`
public class MyClass
{  
  public void foo(int i = 10){}

  public static int Main() 
  {
    return 1;
  }
}
`
(3,25): error CS0241: Default parameter specifiers are not permitted
`
public class MyClass
{  
  public void foo1(void){}
  public delegate void foo2(void);
  
  public static int Main(void) 
  {
    return 1;
  }
}
`
(3,20): error CS1536: Invalid parameter type 'void'
(4,29): error CS1536: Invalid parameter type 'void'
(6,26): error CS1536: Invalid parameter type 'void'
`
public class MyClass
{  
  public static void foo(ref int i, out int j)
  {
    j = 1;
  }
  

  public static void foo(ref object i, out object j)
  {
    j = null;
  }

  public static int Main() 
  {
    foo(ref 1, out 1);
    foo(ref null, out null);
    return 1;
  }
}
`
(16,13): error CS1510: A ref or out argument must be an lvalue
(16,20): error CS1510: A ref or out argument must be an lvalue
(17,13): error CS1510: A ref or out argument must be an lvalue
(17,23): error CS1510: A ref or out argument must be an lvalue
`
public class MyBase {

  public int TestInt;

  public int this [int intI] {
    set {
      TestInt = -1;
    }
    get {
      return -1;
    }
  }
}

public class MyClass : MyBase {

  public override int this [int intI] {
    set {
      TestInt = intI + value;
    }
    get {
      return TestInt + intI;
    }
  }

  public static int Main() {  
    return 1;
  }
}
`
(21,5): error CS0506: 'MyClass.this[int].get' : cannot override inherited member 'MyBase.this[int].get' because it is not marked virtual, abstract, or override
(9,5): (Location of symbol related to previous error)
(18,5): error CS0506: 'MyClass.this[int].set' : cannot override inherited member 'MyBase.this[int].set' because it is not marked virtual, abstract, or override
(6,5): (Location of symbol related to previous error)
`
class A
{
  public static int Main()
  {
    int[] arr = new int[5] {1,2,3,4};

    return 0;
  }
}
`
(5,17): error CS0178: Incorrectly structured array initializer
`
using System;


public class Class1
{
  private EventHandler foo;

  public event EventHandler Foo
  {
    add{}
    remove{}
  }

  public static int Main()
  {
    Foo();   // CS0079
    return 1;
  }
}
`
(16,5): error CS0079: The event 'Class1.Foo' can only appear on the left hand side of += or -=
`
using System;

class A
{
  public static int Main()
  {
    int myLength = 5;
    int[] arr = new int[myLength] {1,2,3,4,5};

    return 0;
  }
}
`
(8,25): error CS0150: A constant value is expected
`
// commented out test because this is no longer an error in Spec#
class A
{
  public static int Main()
  {
    //int[] a1 = new int {1,2,3,4,};
    //int[] a2 = new int;

    return 0;
  }
}
//
//(5,24): error CS1526: A new expression requires () or [] or {} after the type
//(6,23): error CS1526: A new expression requires () or [] or {} after the type
`
`
// commented out test because this is no longer an error in Spec#
class A
{
  public static int Main()
  {
//    A a1 = { new A() };
//    A a2 = { 1, 2, 3 };

    return 0;
  }
}
//(6,12): error CS0622: Can only use array initializer expressions to assign to array types. Try using a new expression instead.
`
`
class A
{
  public static int Main()
  {
    int[] arr  = new int[];

    return 0;
  }
}
`
(5,27): error CS1586: Array creation must have array size or array initializer
`
class A
{
  public static int Main()
  {
    int[] arr  = new int[] 1,2};

    return 0;
  }
}
`
(5,28): error CS1514: { expected
`
using System;

public class Class1
{
  private EventHandler foo;

  public event EventHandler Foo
  {
    add{}
    remove{}
  }

  public void Fire()
  {
    foo += Foo; // CS0079
  }

  public static int Main()
  {
    return 1;
  }
}
`
(15,12): error CS0079: The event 'Class1.Foo' can only appear on the left hand side of += or -=
`
using System;

class Class1
{
  private EventHandler foo;

  public event EventHandler Foo
  {
    add{}
    remove{}
  }

  public static int Main()
  {
    return 1;
  }
}

class Class2
{
  void f1() { Class1.Foo(); } // CS0079
}
`
(21,15): error CS0079: The event 'Class1.Foo' can only appear on the left hand side of += or -=
`
interface IA 
{
    void Method();
}

interface IB : IA
{
    void IA.Method();
}

class Driver
{
    static void Main() {}
}
`
(8,10): error CS0541: 'IA.Method': explicit interface declaration can only be declared in a class or struct
`
class A
{
  public static int Main()
  {
    int[] arr1 = new int[5L];    

    return 0;
  }
}
`
(5,11): warning CS0219: The variable 'arr1' is assigned but its value is never used
`
class A
{
  public static int Main()
  {
    float[] arr = new float[5] {1.0f,2.0f,3.0f,4.0f,5.0f};

    int x = 0;

    if (arr[0] != 1.0)
      x = 1;
    if (2.0 != arr[1])
      x = 1;
    if (arr[2] != 3.0)
      x = 1;
    if (arr[3] != 4.0)
      x = 1;
    if (arr[4] != 5.0)
      x = 1;

    return x;
  }
}
`
`
interface IFoo
{
  void F();
}

interface IBar
{
  void G();
}

class C : IFoo, IBar
{
  public void IFoo.F() {}
  void IBar.G() {}
  public static void Main() {}
}
`
(13,3): error CS0106: The modifier 'public' is not valid for this item
`
interface IFoo
{ 
    int MyMethod(); 
}

class A : IFoo 
{ 
    int IFoo.MyMethod() 
    {
        return 1;
    } 
    
    int IFoo.MyMethod() 
    {
        return 2;
    } 
}

class Driver
{
    static int Main()
    {
        return 0;
    }
}
`
(13,14): error CS0111: Type 'A' already defines a member called 'IFoo.MyMethod' with the same parameter types
(8,14): (Location of symbol related to previous error)
`
interface first 
{
    static first();
    
}

class main 
{
  public static void Main() {}
}
`
(3,12): error CS0526: Interfaces cannot contain constructors
`
using System;

public delegate void MyEvent(object sender);

interface ITest
{
    event MyEvent Clicked;
}

class Test : ITest
{
    event MyEvent ITest.Clicked
    {
        add { }
        remove { }
    }

    public void MyHandler(object sender)
    {
        
    }
}

class main
{
    public static void Main()
    {
        Test t = new Test();
    }
}
`
(28,14): warning CS0219: The variable 't' is assigned but its value is never used
`
using System;
using System.Collections;

public class MyCollection
{
  int[]  items;

  public MyCollection()
  {
    items = new int[5] {1, 4, 3, 2, 5};
  }

  private MyEnumerator GetEnumerator()
  {
    return new MyEnumerator(this);
  }

  public class MyEnumerator
  {
    int        nIndex;
    MyCollection  collection;

    public MyEnumerator(MyCollection coll)
    {
      collection = coll;
      nIndex = -1;
    }
    public bool MoveNext()
    {
      nIndex++;
      return(nIndex < collection.items.GetLength(0));
    }
    public int Current
    {
      get
      {
        return(collection.items[nIndex]);
      }
    }
  }
}
  
public class Test
{
    public static int Main(string [] args)
    {
    MyCollection  col = new MyCollection();

    foreach (int i in col)
    {
      Console.WriteLine("Value: " + i);
    }

        return(0);
    }
}
`
(49,23): error CS1579: foreach statement cannot operate on variables of type 'MyCollection' because 'MyCollection' does not contain a public definition for 'GetEnumerator'
`
using System;

public delegate void MyEvent(object sender);

interface ITest
{
    event MyEvent Clicked;
}

class Test : ITest
{
    event MyEvent ITest.Clicked;
}

class main
{
    public static void Main()
    {
        Test t = new Test();
    }
}
`
(12,32): error CS0071: An explicit interface implementation of an event must use property syntax
`
using System;
using System.Collections;

public class MyCollection
{
  int[]  items;

  public MyCollection()
  {
    items = new int[5] {1, 4, 3, 2, 5};
  }

  public MyEnumerator GetEnumerator()
  {
    return new MyEnumerator(this);
  }

  public class MyEnumerator
  {
    int        nIndex;
    MyCollection  collection;

    public MyEnumerator(MyCollection coll)
    {
      collection = coll;
      nIndex = -1;
    }
    public int Current
    {
      get
      {
        return(collection.items[nIndex]);
      }
    }
  }
}
  
public class Test
{
    public static int Main(string [] args)
    {
    MyCollection  col = new MyCollection();

    foreach (int i in col)
    {
      Console.WriteLine("Value: " + i);
    }

        return(0);
    }
}
`
(44,23): error CS1579: foreach statement cannot operate on variables of type 'MyCollection' because 'MyCollection.MyEnumerator' does not contain a public definition for 'MoveNext'
`
using System;

public delegate void MyEvent(object sender);

interface ITest
{
    event MyEvent Clicked;
}

class Test : ITest
{
    event MyEvent ITest.Clicked 
    { 
        add {} 
        remove {} 
    }

    public void MyHandler(object sender)
    {
        
    }
}

class main
{
    public static void Main()
    {
        new main().Run();
    }

    public void Run()
    {
        Test t = new Test();
        ((ITest)t).Clicked += new MyEvent(TheHandler);
    }

    public void TheHandler(object sender)
    {

    }
}
`
`
using System;

struct testStruct
{
}

interface test 
{
  testStruct this [ testStruct ident1, int x, double y ] { }
}

class main
{
  public static void Main() {}
}
`
(9,14): error CS0548: 'test.this[testStruct, int, double]' : property or indexer must have at least one accessor
`
interface ICloneable
{
    string this[string hashkey] { get; set; }
}

interface IComparable
{
    int CompareTo(object other);
}

struct ListEntry : ICloneable, IComparable
{
    public string st;

    string ICloneable.this[string hashkey]
    {
        get {
            return "success";
        }
        set {
            st = value;
        }
    }
    
    int IComparable.CompareTo(object other)
    {
        return 0;
    }
}

class Test
{
    public static int Main() 
    {
        ListEntry le = new ListEntry();
        ((ICloneable)le)["test"] = "correct";
        string s = ((ICloneable)le)["test"];

        if ( s == "success" )
            return 0;
        else
            return 1;
    }
}
`
`
using System;
namespace nms {
  enum E1 {yes=1, no= yes-1};
    
  public class mine {

    public static int retval = 0;

    public enum E1 {yes=1, no= yes-1};

    public static int Main()
      {
      Console.WriteLine ("PASS");
      return retval;
      }
  };
}
`
PASS
`
using System;
using System.Runtime.Remoting;
using System.Threading;

public class Client
{
    public static void Main(String[] args)
    {
    }
    public static int NotMain(){
        HD hd = new HD(Client.Hello);
        int i = 1;
        IAsyncResult ar = hd.BeginInvoke(out i,null, null);
        i = 1;
        hd.EndInvoke(out i, ar);
        if (0==i) Console.WriteLine("PASS");
        else Console.WriteLine("FAIL, i=="+i.ToString());
        return i;
    }

    public delegate void HD(out int i);

    public static void Hello(out int i)
    {
        i = 0;
    }
}
`
`
interface ICloneable
{
    string this[string hashkey] { get; set; }
}

interface IComparable
{
    int CompareTo(object other);
}

class ListEntry : ICloneable, IComparable
{
    public string st = "";

    string ICloneable.this[string hashkey]
    {
        get 
        {
            return "success";
        }
        set 
        {
            st = value;
        }
    }
    
    int IComparable.CompareTo(object other)
    {
        return 0;
    }
}

class Test
{
    public static int Main() 
    {
        ListEntry le = new ListEntry();
        ICloneable["test"] = "correct";
        string s = ICloneable["test"];

        if ( le.st == "correct" && s == "success" )
            return 0;
        else
            return 1;
    }
}
`
(38,9): error CS0118: 'ICloneable' is a 'class' but is used like a variable
(39,20): error CS0118: 'ICloneable' is a 'class' but is used like a variable
`
using System;

interface IMethods
{
    void F();
    void G();
    void H();
    void I();
}
interface IBMethods{
  void J();
}

class Base : IMethods
{
    void IMethods.F() 
    {
        Console.WriteLine("Base.IMethods.F()");
    }
    
    void IMethods.G() 
    {
        Console.WriteLine("Base.IMethods.G()");
    }
    
    public void H() 
    {
        Console.WriteLine("Base.H()");
    }
    
    public void I() 
    {
        Console.WriteLine("Base.I()");
    }
    public void J()
    {
        Console.WriteLine("Base.J()");
    }
}

class Derived : Base, IMethods, IBMethods
{
    public void F() 
    {
        Console.WriteLine("Derived.F()");
    }
    
    void IMethods.H() 
    {
        Console.WriteLine("Derived.IMethods.H()");
    }
}

class main
{
    public static void Main()
    {
        Derived d = new Derived();
        IMethods im = d;

        im.F();
        im.G();
        im.H();
        im.I();
        ((IBMethods)im).J();
    }
}
`
Derived.F()
Base.IMethods.G()
Derived.IMethods.H()
Base.I()
Base.J()
`
using System;

public delegate void MyEvent(object sender);

interface ITest
{
    event MyEvent Clicked;
}

class Test : ITest
{
    event MyEvent ITest.Clicked 
    { 
        add {}
        remove {}
    }

    public void MyHandler(object sender)
    {
        
    }
}

class main
{
    public static void Main()
    {
        new main().Run();
    }

    public void Run()
    {
        ITest.Clicked += new MyEvent(TheHandler);
    }

    public void TheHandler(object sender) {}
}
`
(33,9): error CS0120: An object reference is required for the nonstatic field, method, or property 'ITest.Clicked'
`
using System;

interface first {
  void F(int x);
}

interface second : first {
  int F(int x);
}

class main {
  public static void Main() {}
}
`
(8,7): warning CS0108: The keyword new is required on 'second.F(int)' because it hides inherited member 'first.F(int)'
(4,8): (Location of symbol related to previous warning)
`
interface ICloneable
{
    object Clone();
}

interface IComparable
{
    int CompareTo(object other);
}


class ListEntry : ICloneable
{
    object ICloneable.Clone() 
    { 
        return new object(); 
    }
    
    int IComparable.CompareTo(object other)
    {
        return 0;
    }
}

class test {
    public static void Main() {}
}
`
(19,9): error CS0540: 'ListEntry.IComparable.CompareTo(object)': containing class does not implement interface 'IComparable'
(6,11): (Location of symbol related to previous error)
`
interface IFoo
{
}

class C : IFoo
{
  string IFoo.MyProp { get {} set {} }
  public static void Main() {}
}
`
(7,15): error CS0539: 'C.IFoo.MyProp' in explicit interface declaration does not match a member of interface 'IFoo'
(1,11): (Location of symbol related to previous error)
`
interface IFoo
{
    string MyProp { set; }
}

class C : IFoo
{
  string IFoo.MyProp { get {} set {} }
  public static void Main() {}
}
`
(8,24): error CS0550: 'C.IFoo.MyProp.get' adds an accessor not found in interface member 'IFoo.MyProp'
(3,12): (Location of symbol related to previous error)
`
interface IFoo
{
    string MyProp { get; set; }
}

class C : IFoo
{
  string IFoo.MyProp { set {} }
  public static void Main() {}
}
`
(6,7): error CS0535: 'C' does not implement interface member 'IFoo.MyProp.get'
(3,21): (Location of symbol related to previous error)
(8,15): error CS0551: Explicit interface implementation 'C.IFoo.MyProp' is missing accessor 'IFoo.MyProp.get'
(3,21): (Location of symbol related to previous error)
`
using System;

interface first {
  void F(int x);
}

interface second : first {
  new int F(int x);
}

class main {
  public static void Main() {}
}
`
`
using System;

public delegate void MyEvent(object sender);

interface ITest
{
    event MyEvent Clicked;
    string this[int index] { get; set; }
    int Property { get; set; }
    void Method();
}

struct Test : ITest
{
    private int num;
    
    protected internal void ITest.Method()
    {
        Console.WriteLine("Method()");
    }
    protected internal int ITest.Property
    {
        get
        {
            return num;
        }
        set
        {
            if (value >= 0 && value <= 10)
                num = value;
        }
    }
    protected internal event MyEvent ITest.Clicked 
    { 
        add {}
        remove {}
    }
    protected internal string ITest.this[int index]
    {
        get { return "Test"; }
        set {}
    }
    public void MyHandler(object sender)
    {        
    }
}

class main
{
    public static void Main()
    {
        Test t = new Test();
    }
}
`
(17,5): error CS0106: The modifier 'protected' is not valid for this item
(17,15): error CS0106: The modifier 'internal' is not valid for this item
(21,5): error CS0106: The modifier 'protected' is not valid for this item
(21,15): error CS0106: The modifier 'internal' is not valid for this item
(33,5): error CS0106: The modifier 'protected' is not valid for this item
(33,15): error CS0106: The modifier 'internal' is not valid for this item
(38,5): error CS0106: The modifier 'protected' is not valid for this item
(38,15): error CS0106: The modifier 'internal' is not valid for this item
`
interface IFoo
{
    int MyProp { get; set; }
}

class A : IFoo
{ 
    string IFoo.MyProp
    {
        get { }
        set { }
    } 
}

class Driver
{
    static int Main()
    {
        return 0;
    }
}
`
(8,17): error CS0539: 'A.IFoo.MyProp' in explicit interface declaration does not match a member of interface 'IFoo'
(1,11): (Location of symbol related to previous error)
`
class Foo
{
  void F() {}
}

class C : Foo
{
  void Foo.F() {}
  public static void Main() {}
}
`
(8,8): error CS0538: 'Foo' in explicit interface declaration is not an interface
(1,7): (Location of symbol related to previous error)
`
public delegate void MyEvent(object sender);

interface ITest {
    //event MyEvent Clicked;
    string this[int index] { get; set; }
    int Property { get; set; }
    void Method();
}

class Test : ITest {
    extern int ITest.Property { get; set; }
    extern void ITest.Method();
    //extern event MyEvent Clicked { add; remove; }       // works if it's { add {} remove {} }
    extern string ITest.this[int index] { get; set; }
}

class main
{
    public static void Main() {}
}
`
(11,33): warning CS0626: Method, operator, or accessor 'Test.ITest.Property.get' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation
(11,38): warning CS0626: Method, operator, or accessor 'Test.ITest.Property.set' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation
(12,23): warning CS0626: Method, operator, or accessor 'Test.ITest.Method()' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation
(14,43): warning CS0626: Method, operator, or accessor 'Test.ITest.this[int].get' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation
(14,48): warning CS0626: Method, operator, or accessor 'Test.ITest.this[int].set' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation
`
public delegate void MyDelegate();

interface test 
{
  event MyDelegate e = new MyDelegate(Test.Main);
}

class Test
{
  static void Main() {}
}
`
(5,24): error CS0068: 'test.e': event in interface cannot have initializer
`
using System;
namespace nms {
  public enum E1 : byte { a, b, c, d=253, e, f };

  public class mine {

    public static int retval = 0x3F;

    public static int Main(){
      if ((int)E1.a == 0)
          retval -= 0x20;
      if ((int)E1.b == 1)
          retval -= 0x10;
      if ((int)E1.c == 2)
          retval -= 0x08;
      if ((int)E1.d == 253)
          retval -= 0x04;
      if ((int)E1.e == 254)
          retval -= 0x02;
      if ((int)E1.f == 255)
          retval -= 0x01;
          
      if (retval == 0) Console.WriteLine ("PASS");
      else
          {
          Console.WriteLine ("FAIL\nretval == ");
          Console.WriteLine (retval);
          }

      return retval;
    }
  };
}
`
PASS
`
using System;
namespace nms {

public class S : Exception {
};

public class S1 : Exception {
};

public class mine {
    private static int retval = 2;
    public static int Main()
    {
        try {
                throw new S();
        }
        catch {}
        catch (S1) {}
        catch (S) {}

        if (retval == 0) Console.WriteLine ("PASS");
        else Console.WriteLine("FAIL");
         return retval;
    }
    };
}
`
(18,9): error CS1017: Try statement already has a default catch block
(19,9): error CS1017: Try statement already has a default catch block
`
using System;

namespace nms {

  delegate int boo();

  interface I {
      int bar();
  }

  public struct poo : I {

      public int bar () {Console.WriteLine("bar"); return 0x01;}
  }

  public class start {
      static int retval = 0x01;
      
      static public int Main (){
          poo p = new poo();
          boo foo = new boo(p.bar);
          retval -= foo();
          if (retval == 0){
            Console.WriteLine ("PASS");
          }
          else 
          {
            Console.WriteLine ("FAIL");
          }
          return retval;
      }
  }

}
`
bar
PASS
`
using System;
namespace nms {
  public enum E1 : byte { a, b, c, d=255, e, f };

  public class mine {

    public static int retval = 0x3F;

    public static int Main()
      {
          Console.WriteLine ("FAIL");
          return retval;
      }
  }
}
`
(3,43): error CS0543: 'nms.E1.e': the enumerator value is too large to fit in its type
`
using System;
using System.Threading;
using System.Runtime.Remoting.Messaging;

delegate void MyDelegate(int i, params string[] p);

class Test
{
  static volatile int res;
  
  void m1(int i, params string[] p) 
  {
    res = p.Length;
  }
  
  
  public static int Main()
  {
    Test t = new Test();
    MyDelegate d = new MyDelegate(t.m1);
    int i = 7;
    string[] strArr = {"foo","bar"};
    IAsyncResult ar = d.BeginInvoke(i, "foo","bar",null, null);
    ar.AsyncWaitHandle.WaitOne();
    if (res == 2) 
      return 0;
    else
      return 1;
  }
}
`
(23,23): error CS1501: No overload for method 'BeginInvoke' takes '5' arguments
`
using System;
namespace nms {

public class S : Exception {
};

public class S1 : Exception {
};

public class mine {
    private static int retval = 3;
    public static int Main()
    {
    int caught = 0;
      try {
        throw new S();
      }
      catch (Exception) {
        caught = 20;
      }
      catch (S) {
        caught = 98;
      }
      catch {
        caught = 99;
      }

        if (caught == 20)
            retval--;

        if (retval == 0) Console.WriteLine ("PASS");
        else Console.WriteLine("FAIL");
         return retval;
    }
    };
}
`
(21,14): error CS0160: A previous catch clause already catches all exceptions of this or a super type ('System.Exception')
`
using System;
namespace nms {
  public enum E1 : byte { a, b, c, d=-256, e, f };

  public class mine {

    public static int retval = 0x3F;

    public static int Main()
      {
      Console.WriteLine ("FAIL");
      return retval;
      }
  };
}
`
(3,38): error CS0031: Constant value '-256' cannot be converted to a 'byte'
`
using System;

delegate double MyDelegate1 (ref int integerPortion, out float fraction);

public class MyClass
{
  public delegate double MyDelegate2 (out int integerPortion, ref float fraction);

  public double DelegatedMethod (ref int intPart, ref float frac) {
    return intPart+frac+5;
  }

    public static int Main(String[] args)
    {
      int retval = 0x07;
      
      MyClass mc = new MyClass();
      MyDelegate1 md1 = new MyDelegate1(mc.DelegatedMethod);
      MyDelegate2 md2 = new MyDelegate2(mc.DelegatedMethod);
      if (md1 == md2)
        retval -= 0x01;
      if (md2 == md1)
        retval -= 0x02;

      if (0 == retval) Console.WriteLine ("PASS");
      else Console.WriteLine ("FAIL, 0x{0:X}", retval);
      return 1;
   }
}
`
(20,11): error CS0019: Operator '==' cannot be applied to operands of type 'MyDelegate1' and 'MyClass.MyDelegate2'
(22,11): error CS0019: Operator '==' cannot be applied to operands of type 'MyClass.MyDelegate2' and 'MyDelegate1'
(18,44): error CS0123: No overload for 'DelegatedMethod' matches delegate 'double MyDelegate1(ref int, out float)'
(3,17): (Location of symbol related to previous error)
(9,17): (Location of symbol related to previous error)
(19,44): error CS0123: No overload for 'DelegatedMethod' matches delegate 'double MyClass.MyDelegate2(out int, ref float)'
(7,26): (Location of symbol related to previous error)
(9,17): (Location of symbol related to previous error)
`
using System;

public class MyException : ApplicationException {
    public MyException(String str) : base (str)
    {}
};

public class mine {
    private static int retval = 0x07;
    public static int Main() {
    try {
        try {
            Console.WriteLine ("In try block, ready to throw.");
            throw new MyException("An exception has occurred");
        }
        catch (DivideByZeroException s){
            Console.WriteLine ("In catch block.");
            Console.WriteLine (s.Message);
        }
      finally {
        Console.WriteLine ("In inner finally block");
        retval ^= 0x01;
      }
    }
    catch (MyException s) {
      if (0 == (retval & 0x01))
        retval ^= 0x02;
      Console.WriteLine ("In catch block.");
      Console.WriteLine (s.Message);
    }
    catch (Exception) {
      Console.WriteLine ("FAIL -- Should not enter catch (Exception) block");
      retval ++;
    }
    finally {
        Console.WriteLine ("In outer finally block");
      if (0 == (retval & 0x03))
        retval ^= 0x04;
    }
      if (0 == retval) Console.WriteLine ("PASS");
    else Console.WriteLine ("FAIL, retval == 0x" + retval.ToString("X"));
    return retval;
  }
};
`
In try block, ready to throw.
In inner finally block
In catch block.
An exception has occurred
In outer finally block
PASS
`
using System;
using System.Runtime.CompilerServices;

public class bug
{
  [IndexerName("item","item")]
  public int this [int index]
  {
    get
    {
      return 0;
    }
  }

  public static int Main()
  {
    return 1;
  }
}
`
(6,23): error CS0580: Too many unnamed arguments to attribute 'IndexerName'
`
enum MyEnum {aa = 2}

enum MyEnum2 {bb = aa}

public class MyClass {
  public static int Main() {
    return 1;
  }
}
`
(3,20): error CS0103: The name 'aa' does not exist in the current context
`
using System;
namespace nms {
    public enum E1 : int { a, b, c, d=0x7FFFFFFF, e, f };

    public class mine {

      public static int retval = 0x3F;
    
      public static int Main()
        {
            Console.WriteLine ("FAIL");
            return retval;
        }
    };
}
`
(3,51): error CS0543: 'nms.E1.e': the enumerator value is too large to fit in its type
`
using System;
namespace nms {

  public class mine {
    int d=(int)-2147483649;
  
    public static void Main()
    {
    }
  };
}
`
(5,16): error CS0221: Constant value '-2147483649' cannot be converted to a 'int' (use 'unchecked' syntax to override)
`
using System;
namespace nms {
  public enum E1 : int { a, b, c, d=(int)-2147483649, e, f };

  public class mine{
    public static int retval = 0x3F;

    public static int Main()
    {
      Console.WriteLine ("FAIL");
      return retval;
    }
  };
}
`
(3,42): error CS0221: Constant value '-2147483649' cannot be converted to a 'int' (use 'unchecked' syntax to override)
`
using System;

delegate double MyDelegate1 (int integerPortion, float fraction);

public class MyClass
{
    public delegate double MyDelegate2 (int integerPortion, float fraction);

    public double DelegatedMethod1 (int intPart, float frac) {
        Console.WriteLine ("DelegatedMethod1");
        return intPart+frac+5;
    }

    public double DelegatedMethod2 (int intPart, float frac) 
    {
        Console.WriteLine ("DelegatedMethod2");
        return intPart+frac+10;
    }

    public double DelegatedMethod3 (int intPart, float frac) 
    {
        Console.WriteLine ("DelegatedMethod3");
        return intPart+frac+15;
    }

    public double DelegatedMethod4 (int intPart, float frac) 
    {
        Console.WriteLine ("DelegatedMethod4");
        return intPart+frac+20;
    }

    public static int Main(String[] args)
    {
        int retval = 0x1F;
        
        MyClass mc = new MyClass();
        try {
            MyDelegate1 md1 = new MyDelegate1(mc.DelegatedMethod1);
            md1 += new MyDelegate1(mc.DelegatedMethod2);
            MyDelegate2 md2 = new MyDelegate2(mc.DelegatedMethod1);
            md2 += new MyDelegate2(mc.DelegatedMethod2);
            Delegate[] da1 = md1.GetInvocationList();
            Delegate[] da2 = md2.GetInvocationList();
            if (da1[1].Method == da2[1].Method)
                retval ^= 0x01;
            if (da1[0].Method == da2[0].Method)
                retval ^= 0x02;
            md2 = new MyDelegate2(mc.DelegatedMethod4);
            md2 += new MyDelegate2(mc.DelegatedMethod3);
            MyDelegate1 md3 = new MyDelegate1(mc.DelegatedMethod4)+new MyDelegate1(mc.DelegatedMethod3);
            MyDelegate1 md4 = new MyDelegate1(md1)+md3;
            Delegate[] da3 = md4.GetInvocationList();
            if (da3[0].Method.Name == "Invoke")  //This is because was constructed by copying another delegate
                retval ^= 0x04;
            if (da3[1].Method.Name == mc.GetType().GetMethod("DelegatedMethod4").Name)
                retval ^= 0x08;
            if (da3[2].Method.Name == mc.GetType().GetMethod("DelegatedMethod3").Name)
                retval ^= 0x10;
        }
        catch (NullReferenceException) {
            retval -= 0x01;
        }

        if (0 == retval) Console.WriteLine ("PASS");
        else Console.WriteLine ("FAIL, 0x{0:X}", retval);
        return retval;
   }

}
`
PASS
`
using System;

public class MyAtt : Attribute
{
  public MyAtt(string s) {}

  public string Foo = null; 
  public string Boo = null;
}

[MyAtt(Foo="foo",null)]
public class Test
{
  public static int Main ()
  {
    return 1;
  }
}
`
(11,18): error CS1016: Named attribute argument expected
`
using System;

class MyAtt : Attribute
{
  public delegate void D();
  public event D E;
}

[MyAtt(E = null)]
class Test
{
  public static int Main()
  {
    return 1;
  }
}
`
(9,8): error CS0617: 'E' is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static or const, or read-write properties which are not static.
(6,18): (Location of symbol related to previous error)
`
using System;
namespace nms {

    public enum E1 : long { a, b, c, d=(long)0x7FFFFFFFFFFFFFFDL, e, f };

    public class mine {

      public static int retval = 0x3F;
    
      public static int Main()
        {
            if ((long)E1.a == 0)
                retval -= 0x20;
            if ((long)E1.b == 1)
                retval -= 0x10;
            if ((long)E1.c == 2)
                retval -= 0x08;
            if ((long)E1.d == 0x7FFFFFFFFFFFFFFD)
                retval -= 0x04;
            if ((long)E1.e == 0x7FFFFFFFFFFFFFFE)
                retval -= 0x02;
            if ((long)E1.f == 0x7FFFFFFFFFFFFFFF)
                retval -= 0x01;
                
            if (retval == 0) Console.WriteLine ("PASS");
            else
                {
                Console.WriteLine ("FAIL\nretval == ");
                Console.WriteLine (retval);
                }

            return retval;
        }
    };
}
`
PASS
`
using System;

delegate string func(int i);

class a
{
   public static void Main()
   {
      func dt = new func("hello");   // CS0149
   }
}
`
(9,26): error CS0149: Method name expected
`
using System;

[AttributeUsage(AttributeTargets.Class)]
public class HelpAttribute : Attribute
{
  public HelpAttribute(byte b1) {
      b = b1;
  }
  byte b = 0;
  public byte Verify {get {return b;} }
}

[HelpAttribute(111)] 
class Class1
    {
    }
    
public class MainClass
    {
    public static int Main ()
        {
//        Class1 c1 = new Class1();
        object[] attrs = typeof(Class1).GetCustomAttributes(false);
        for (int i = 0; i < attrs.Length; i++)
            {
            HelpAttribute a = attrs[i] as HelpAttribute;
            if (a == null) continue;
            Console.WriteLine("{0} : {1}", i, a.Verify);
            }

        return 0;
        }
    }
`
0 : 111
`
using System;

[AttributeUsage(AttributeTargets.Class)]
public class HelpAttribute : Attribute
{    public HelpAttribute(object[] b1) {
        b = b1[1];
    }
    object b = typeof(HelpAttribute);
    public object Verify {get {return b;} }
}

[HelpAttribute(new object[2] {800, "Eight thousand"})] 
class Class1
    {
    }
    
public class MainClass
    {
    public static int Main ()
        {
//        Class1 c1 = new Class1();
        object[] attrs = typeof(Class1).GetCustomAttributes(false);
        for (int i = 0; i < attrs.Length; i++)
            {
            HelpAttribute a = attrs[i] as HelpAttribute;
            if (a == null) continue;
            Console.WriteLine("{0} : {1}", i, a.Verify);
            }

        return 0;
        }
    }
`
0 : Eight thousand
`
using System;

public class MyClass {
  public static int Main() {

    double d1 = double.MaxValue;
    double d2 = double.PositiveInfinity;
    double d3 = double.NegativeInfinity;

    if ((double)(d1 + (d1 * 1.0e-15f)) != d2) {
      return 1;
    }
    if ((double)(d1 - (-d1 * 1.0e-15f)) != d2) {
      return 1;
    }
    if ((double)(d1 * (1.0f + 1.0e-15f)) != d2) {
      return 1;
    }
    if ((double)(d1 / (1.0f - 1.0e-15f)) != d2) {
      return 1;
    }    
    if ((double)(-d1 + (-(d1 * 1.0e-15f))) != d3) {
      return 1;
    }
    if ((double)((-d1 - (d1 * 1.0e-15f))) != d3) {
      return 1;
    }
    if ((double)(-d1 * (1.0f + 1.0e-15f)) != d3) {
      return 1;
    }
    if ((double)(-d1 / (1.0f - 1.0e-15f)) != d3) {
      return 1;
    }  

    return 0;        
  }
}
`
`
class MyClass {

  public const int intL = 4;  

  public static int Main() {
    MyClass test = new MyClass();
    int intI = test.intL;
    return 1;    
  }
}
`
(7,16): error CS0176: Static member 'MyClass.intL' cannot be accessed with an instance reference; qualify it with a type name instead
`
using System;
namespace nms {
     public enum E1 : long { a, b, c, d=(long)0xFFFFFFFFFFFFFFFFF, e, f };


    public class mine {

        public static int retval = 0x3F;
    
      public static int Main()
        {
            Console.WriteLine ("FAIL");
            return retval;
            }
        };
    }
`
(3,47): error CS1021: Integral constant is too large
`
using System;
namespace nms {

     public enum E1 : int { a, b, c, d=(int)0x7FFFFFFD, e, f };
     public enum E2 : short { a=(short)E1.a, b, c, d, e, f };

    public class mine {

        public static int retval = 0x3F;
    
      public static int Main()
        {
            if ((int)E2.a == 0)
                retval -= 0x20;
            if ((int)E2.b == 1)
                retval -= 0x10;
            if ((int)E2.c == 2)
                retval -= 0x08;
            if ((int)E2.d == 3)
                retval -= 0x04;
            if ((int)E2.e == 4)
                retval -= 0x02;
            if ((int)E2.f == 5)
                retval -= 0x01;
                
            if (retval == 0) Console.WriteLine ("PASS");
            else
                {
                Console.WriteLine ("FAIL\nretval == ");
                Console.WriteLine (retval);
                }

            return retval;
            }
        };
    }
`
PASS
`
using System;
namespace nms {

     public enum E2 : int { a=(int)E1.a, b, c, d, e, f };
     public enum E1 : ulong { a, b, c, d=0xFFFFFFFFFFFFFFFEL, e, f };

    public class mine {

        public static int retval = 0x3F;
    
      public static int Main()
        {
            if ((int)E1.a == 0)
                retval -= 0x20;
            if ((int)E1.b == 1)
                retval -= 0x10;
            if ((int)E1.c == 2)
                retval -= 0x08;
            if ((int)E1.d == -3)
                retval -= 0x04;
            if ((int)E1.e == -2)
                retval -= 0x02;
            if ((int)E1.f == -1)
                retval -= 0x01;
                
            if (retval == 0) Console.WriteLine ("PASS");
            else Console.WriteLine ("FAIL\nretval == {0}", retval);

            return retval;
            }
        };
    }
`
(5,66): error CS0543: 'nms.E1.f': the enumerator value is too large to fit in its type
(19,22): error CS0221: Constant value 'E1.d' cannot be converted to a 'int' (use 'unchecked' syntax to override)
(21,22): error CS0221: Constant value 'E1.e' cannot be converted to a 'int' (use 'unchecked' syntax to override)
`
using System;
namespace nms {
public class mine {
    public enum e1 {zero, one=1, two=2, three=3};
  public static int Main()
    {
    int retval = 7;
    e1 v_e1 = e1.two;

    if ((int)(~v_e1) == -3)
        retval -= 1;
    
    if ((int)(~e1.three) == -4)
        retval -= 2;
    
    if ((~(e1.one | e1.two) & e1.three) == e1.zero)
        retval -= 4;
    
    if (0 == retval) Console.WriteLine ("PASS");
        else Console.WriteLine ("FAIL");
    return retval;
    }
    };
}
`
PASS
`
using System;
namespace nms {

     public enum E1 : uint { a, b, c, d=0xFFFFFFFD, e, f };

    public class mine {

        public static int retval = 0x3F;
    
      public static int Main()
        {
            if ((int)E1.a == 0)
                retval -= 0x20;
            if ((int)E1.b == 1)
                retval -= 0x10;
            if ((int)E1.c == 2)
                retval -= 0x08;
            if ((uint)E1.d == 0xFFFFFFFD)
                retval -= 0x04;
            if ((uint)E1.e == 0xFFFFFFFE)
                retval -= 0x02;
            if ((uint)E1.f == 0xFFFFFFFF)
                retval -= 0x01;
                
            if (retval == 0) Console.WriteLine ("PASS");
            else
                {
                Console.WriteLine ("FAIL\nretval == ");
                Console.WriteLine (retval);
                }

            return retval;
            }
        };
    }
`
PASS
`
using System;
namespace nms {
     public enum E1 { a, b, c, d, e, f };
     public enum E2 : byte { a, b, c, d, e, f };
     public enum E2sb : sbyte { a, b, c, d, e, f };
     public enum E3 : short { a, b, c, d, e, f };
     public enum E3us : ushort { a, b, c, d, e, f };
     public enum E4 : int { a, b, c, d, e, f };
     public enum E4ui : uint { a, b, c, d, e, f };
     public enum E5 : long { a, b, c, d, e, f };
     public enum E5ul : ulong { a, b, c, d, e, f };


    public class mine {

        public static int retval = 0x7FFFFFF;
    
      public static int Main()
        {
        E1 e1 = E1.a;
        e1++; e1++; e1++; e1--; e1--; e1--; e1++; e1--; e1--; e1++; e1++; e1++; e1++; e1++; e1++; e1++;
        if ((int)e1 == (int)E1.f+1)
            retval -= 0x01;
        e1--; e1--; e1--; e1--; e1--; e1--;
        if (e1 == E1.a)
            retval -= 0x02;
        e1--;
        if ((int)e1 == (int)E1.a-1)
            retval -= 0x04;
            
        E2 e2 = E2.a;
        e2++; e2++; e2++; e2--; e2--; e2--; e2++; e2--; e2--; e2++; e2++; e2++; e2++; e2++; e2++; e2++;
        if ((int)e2 == (int)E2.f+1)
            retval -= 0x08;
        e2--; e2--; e2--; e2--; e2--; e2--;
        if (e2 == E2.a)
            retval -= 0x10;
        e2--;
        if ((int)e2 == 255)  //This has to be a manifest constant because byte is UNSIGNED
            retval -= 0x20;
            
        E2sb e2sb = E2sb.a;
        e2sb++; e2sb++; e2sb++; e2sb--; e2sb--; e2sb--; e2sb++; e2sb--; e2sb--; e2sb++; e2sb++; e2sb++; e2sb++; e2sb++; e2sb++; e2sb++;
        if ((int)e2sb == (int)E2sb.f+1)
            retval -= 0x8000;
        e2sb--; e2sb--; e2sb--; e2sb--; e2sb--; e2sb--;
        if (e2sb == E2sb.a)
            retval -= 0x10000;
        e2sb--;
        if ((int)e2sb == -1)
            retval -= 0x20000;
            
        E3 e3 = E3.a;
        e3++; e3++; e3++; e3--; e3--; e3--; e3++; e3--; e3--; e3++; e3++; e3++; e3++; e3++; e3++; e3++;
        if ((int)e3 == (int)E3.f+1)
            retval -= 0x40;
        e3--; e3--; e3--; e3--; e3--; e3--;
        if (e3 == E3.a)
            retval -= 0x80;
        e3--;
        if ((int)e3 == (int)E3.a-1)
            retval -= 0x100;
            
        E3us e3us = E3us.a;
        e3us++; e3us++; e3us++; e3us--; e3us--; e3us--; e3us++; e3us--; e3us--; e3us++; e3us++; e3us++; e3us++; e3us++; e3us++; e3us++;
        if ((int)e3us == (int)E3us.f+1)
            retval -= 0x40000;
        e3us--; e3us--; e3us--; e3us--; e3us--; e3us--;
        if (e3us == E3us.a)
            retval -= 0x80000;
        e3us--;
        if ((int)e3us == 65535)
            retval -= 0x100000;
            
        E4 e4 = E4.a;
        e4++; e4++; e4++; e4--; e4--; e4--; e4++; e4--; e4--; e4++; e4++; e4++; e4++; e4++; e4++; e4++;
if ((int)e4 == (int)E4.f+1)
            retval -= 0x200;
        e4--; e4--; e4--; e4--; e4--; e4--;
        if (e4 == E4.a)
            retval -= 0x400;
        e4--;
        if ((int)e4 == (int)E4.a-1)
            retval -= 0x800;
            
        E4ui e4ui = E4ui.a;
        e4ui++; e4ui++; e4ui++; e4ui--; e4ui--; e4ui--; e4ui++; e4ui--; e4ui--; e4ui++; e4ui++; e4ui++; e4ui++; e4ui++; e4ui++; e4ui++;
        if ((int)e4ui == (int)E4ui.f+1)
            retval -= 0x200000;
        e4ui--; e4ui--; e4ui--; e4ui--; e4ui--; e4ui--;
        if (e4ui == E4ui.a)
            retval -= 0x400000;
        e4ui--;
        if ((int)e4ui == (int)E4ui.a-1)
            retval -= 0x800000;
            
        E5 e5 = E5.a;
        e5++; e5++; e5++; e5--; e5--; e5--; e5++; e5--; e5--; e5++; e5++; e5++; e5++; e5++; e5++; e5++;
        if ((int)e5 == (int)E5.f+1)
            retval -= 0x01000;
        e5--; e5--; e5--; e5--; e5--; e5--;
        if (e5 == E5.a)
            retval -= 0x02000;
        e5--;
        if ((int)e5 == (int)E5.a-1)
            retval -= 0x04000;

        E5ul e5ul = E5ul.a;
        e5ul++; e5ul++; e5ul++; e5ul--; e5ul--; e5ul--; e5ul++; e5ul--; e5ul--; e5ul++; e5ul++; e5ul++; e5ul++; e5ul++; e5ul++; e5ul++;
        if ((int)e5ul == (int)E5ul.f+1)
            retval -= 0x01000000;
        e5ul--; e5ul--; e5ul--; e5ul--; e5ul--; e5ul--;
        if (e5ul == E5ul.a)
            retval -= 0x02000000;
        e5ul--;
        if ((int)e5ul == (int)E5ul.a-1)
            retval -= 0x04000000;

            if (retval == 0)  Console.WriteLine ("PASS");
            else Console.WriteLine ("FAIL, 0x{0:X}", retval);
            return retval;
            }
        };
    }
`
PASS
`
using System;
    
namespace nms {    
public class mine {
    public enum E1 : char {a, b, c};

  public static int Main()
    {
    E1 e1 = E1.a;

    return 1;
    }
    };
}
`
(5,22): error CS1008: Type byte, sbyte, short, ushort, int, uint, long, or ulong expected
`
using System;
    
abstract enum E1  {a, b, c, };
sealed enum E2 {a, b, c, };
namespace nms {    
    abstract enum E3  {a, b, c, };
    sealed enum E4 {a, b, c, };

public class mine {
    abstract enum E5  {a, b, c, };
    sealed enum E6 {a, b, c, };

  public static int Main()
    {
    return 1;
    }
    };
}
`
(3,10): error CS0106: The modifier 'abstract' is not valid for this item
(4,8): error CS0106: The modifier 'sealed' is not valid for this item
(6,14): error CS0106: The modifier 'abstract' is not valid for this item
(7,12): error CS0106: The modifier 'sealed' is not valid for this item
(10,14): error CS0106: The modifier 'abstract' is not valid for this item
(11,12): error CS0106: The modifier 'sealed' is not valid for this item
`
using System;             

delegate string func(int i);

class a
{
   public static int Main()
   {
      return 1;
   }

   public static void x(func hello)
   {
      hello(8, 9);   // CS1593
   }
}
`
(14,7): error CS1593: Delegate 'func' does not take '2' arguments
(3,17): (Location of symbol related to previous error)
`
using System;

public class Test
{
  private delegate int D();

  public int foo()
  {
    D d = delegate(){ return int.MaxValue;};
    return d();
  }

  public static int Main()
  {
    Test t = new Test();
    return t.foo()-int.MaxValue;
  }
}
`
`
using System;

class MyClass
{
   public static int Main()
   {
      return 1;
   }

   public ArgIterator Test()   // CS1599
   {
      return null;
   }
}
`
(10,23): error CS1564: Method or delegate cannot return type 'System.ArgIterator'
`
using System;

public class Test
{
  private delegate void D();

  public static void boo(){}
  public int foo()
  {
    D d = delegate(boo)
    {};
    return 1;
  }

  public static int Main()
  {
    Test t = new Test();
    return t.foo();
  }
}
`
(10,23): error CS1001: Identifier expected
(10,20): error CS0246: The type or namespace name 'boo' could not be found (are you missing a using directive or an assembly reference?)
(10,11): error CS1661: Cannot convert anonymous method block to delegate type 'Test.D' because the specified block's parameter types do not match the delegate parameter types
`
using System;

class MyClass
{
   public void Test (out ArgIterator t){}   // CS1601

   public static int Main() { return 1; }
}
`
(5,38): error CS1601: Method or delegate parameter cannot be of type 'out System.ArgIterator'
`
using System;

[AttributeUsage(AttributeTargets.Class)]
public class HelpAttribute : Attribute
{
    public HelpAttribute(char b1) {
        b = b1;
    }
    char b = 'a';
    public char Verify {get {return b;} }
}

[HelpAttribute('C')] 
class Class1
    {
    }
    
public class MainClass
    {
    public static int Main ()
        {
//        Class1 c1 = new Class1();
        object[] attrs = typeof(Class1).GetCustomAttributes(false);
        for (int i = 0; i < attrs.Length; i++)
            {
            HelpAttribute a = attrs[i] as HelpAttribute;
            if (a == null) continue;
            Console.WriteLine("{0} : {1}", i, a.Verify);
            }

        return 0;
        }
    }
`
0 : C
`
using System;

[AttributeUsage(AttributeTargets.All,AllowMultiple=true)]
internal class Att : Attribute
{
  internal int X;
}

[Att(X=5)]
public class A 
{
  [Att(X=5)]
  public void foo(){}

  public static int Main()
  {
    return 1;
  }
}
`
(9,6): error CS0617: 'X' is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static or const, or read-write properties which are not static.
(6,16): (Location of symbol related to previous error)
(12,8): error CS0617: 'X' is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static or const, or read-write properties which are not static.
(6,16): (Location of symbol related to previous error)
`
using System;

class MyClass
{
   public static int Main()
   {
   return 1;
   }

   protected delegate ArgIterator Test(); 
}
`
(10,23): error CS1564: Method or delegate cannot return type 'System.ArgIterator'
`
using System;

class MyClass
{
   public static int Main()
   {
   return 1;
   }

   protected delegate void Test(ref ArgIterator args); 
}
`
(10,49): error CS1601: Method or delegate parameter cannot be of type 'ref System.ArgIterator'
`
class A
{
  public static int Main()
  {
    int[][] arr = new int[10][5];    

    return 0;
  }
}
`
(5,31): error CS0178: Incorrectly structured array initializer
`
using System;

public class Test
{
  private delegate int D(int i);

  public static int boo(int i){ return i; }
  public int foo()
  {
    D d1 = delegate(int i){return i;};
    D d2 = delegate(int i)
    {return i;};
    D d3 = new D(boo);
    return d1(10) - d2(1) - d3(9);
  }

  public static int Main()
  {
    Test t = new Test();
    return t.foo();
  }
}
`
`
class A
{
  public static int Main()
  {
    int[,]   arr1 = new int[10,2];
    double[,] arr2 = new double[5,3];
    float[,]  arr3;
    arr3 = new float[1,1];
    char[,]   arr4;
    arr4 = new char[0,0];

    int x = 0;

    if (arr1.Length != 20)
      x = 1;
    if (arr2.Length != 15)
      x = 1;
    if (arr3.Length != 1)
      x = 1;
    if (arr4.Length != 0)
      x = 1;

    return x;
  }
}
`
`
using System;

[AttributeUsage(0)]
class MyAtt : Attribute
{}

[MyAtt]
public class Test
{
  public static int Main()
  {
    return 1;
  }
}
`
(3,17): error CS0591: Invalid value for argument to 'AttributeUsage' attribute
`
using System;
using System.Runtime.CompilerServices;

public class Base
{
  public virtual int this[int index]
  {
    get  { return 0; }
    set  {}
  }
}

public class Test : Base
{
  [IndexerName("Item")]
  public override int this[int index]
  {
    get  { return 0;  }
    set  {}
  }
  public static int Main()
  {
    return 1;
  }
}
`
(15,4): error CS0609: Cannot set the IndexerName attribute on an indexer marked override
`
using System;
using System.Diagnostics;

interface I
{
  void boo();
}

interface IA : I
{
  [Conditional("DEBUG")]
  void foo();
}

public class A
{
  public static int Main()
  {
    return 1;
  }
}
`
(11,4): error CS0582: Conditional not valid on interface members
`
using System;

public class Test
{
  private delegate int D();
  private void foo(ref D d)
  {
    d = delegate(){ return 10;};
  }

  public static int Main()
  {
    D d = null;
    Test t = new Test();
    t.foo(ref d);
    return d()-10;
  }
}
`
`
using System;

delegate void Bar(int i);

class foo
{
  Bar bar = delegate(int a) { Console.WriteLine(a); };

  static void Main() {
    foo myFoo = new foo();

    myFoo.bar(5);
  }
}
`
5
`
using System;

public class Test
{

  private delegate int D(int index1, int index2, int[,] i);

  public static int Main()
  {
    int[,] i = new int[,]{{0,1,2},{3,4,5}};
    D d = delegate(int index1, int index2, int[,] ii){   
              return ii[index1,index2];
             };
    int ret = d(1,1,i);
    if(i[1,1] == ret)
      return 0;
    else
      return 1;
  }
}
`
`
class A
{
  public static int Main()
  {
    int[,] arr = new int[5,5];

    arr[0,0] = 5;

    if (arr[0,0] == 5)
      return 0;
    else
      return 1;
  }
}
`
`
using System;
using System.Diagnostics;

interface IA
{
  void foo();
}

interface IB
{
  void foo();
}

public class AB : IA, IB
{
  [Conditional("Debug")]
  void IA.foo(){}

  [Conditional("Debug")]
  void IB.foo(){}

  public static int Main()
  {
    return 1;
  }
}
`
(16,4): error CS0577: Conditional not valid on 'AB.IA.foo()' because it is a constructor, destructor, operator, or explicit interface implementation
(19,4): error CS0577: Conditional not valid on 'AB.IB.foo()' because it is a constructor, destructor, operator, or explicit interface implementation
`
using System;

struct Point {
  public int x;
  public int y;
};
class CTrail {
  public Point[] segments;
}
public class Test{
  static CTrail t = new CTrail();
  public static int Main(string[] args){
    t.segments = new Point[1];
    t.segments[0].x = 5;
    t.segments[0].y = 6;
    Point p = t.segments[0];
    if (p.x != t.segments[0].x) return 1;
    if (p.y != t.segments[0].y) return 1;
    return 0;
  }
}
`
`
using System;
using System.Diagnostics;

public class Test 
{
  [Conditional("Debug")]
  public virtual ~Test(){}

  public static int Main()
  {
    return 1;
  }
}
`
(7,3): error CS0106: The modifier 'public' is not valid for this item
(6,4): error CS0577: Conditional not valid on 'Test.~Test()' because it is a constructor, destructor, operator, or explicit interface implementation
`
using System;
public class Test
{
  enum eTypes {
    kFirst,
    kSecond,
    kThird,
  };
    public static int Main(string [] args)
    {
    int r = 0;
    r = DoEnum();
        return(r);
    }
  
  private static int DoEnum()
  {
          int ret = 2;
          eTypes e = eTypes.kSecond;

          switch (e) {
          case eTypes.kThird:
          case eTypes.kSecond:
              ret--;
              break;
          case (eTypes) (-1):
              break;
          default:
              break;
          }

          switch (e) {
          case (eTypes)100:
          case (eTypes) (-1):
              break;
          default:
              ret--;
              break;
          }

          if (ret > 0)
              Console.WriteLine("enum  failed");
          return(ret);
  }
}
`
`
class A
{
  public static int Main()
  {
    int[,] arr = new int[5,9];

    arr[3,7] = 100;

    long idx = 3L;

    if (arr[idx,7] == 100)
      return 0;
    else
      return 1;
  }
}
`
`
class A
{
  public static int Main()
  {
    int[,] arr = new int[3,2] {{1,2},{3,4},{5,6}};

    if (arr[1,0] != 3)
      return 1;

    arr = null;

    try
    {
      if (arr[2,1] == 3)
        return 1;
    }
    catch (System.NullReferenceException)
    {
      return 0;
    }

    return 1;
  }
}
`
`
public class Test
{
   public static void Main()
   {
      int[,,] a = new int[10,10,10];
      a[4][4] = 9;
      a[4] = 9;
   }
}
`
(6,7): error CS0022: Wrong number of indices inside [], expected '3'
(7,7): error CS0022: Wrong number of indices inside [], expected '3'
`
using System;
using System.Diagnostics;

public struct DBBool
{
  // The three possible DBBool values:
  public static readonly DBBool dbNull = new DBBool(0);
  public static readonly DBBool dbFalse = new DBBool(-1);
  public static readonly DBBool dbTrue = new DBBool(1);
  // Private field that stores -1, 0, 1 for dbFalse, dbNull, dbTrue:
  int value; 

  // Private constructor. The value parameter must be -1, 0, or 1:
  //[Conditional("Debug")]
  DBBool(int value) 
  {
    this.value = value;
  }

  // Implicit conversion from bool to DBBool. Maps true to 
  // DBBool.dbTrue and false to DBBool.dbFalse:
  [Conditional("Debug")]
  public static implicit operator DBBool(bool x) 
  {
    return x? dbTrue: dbFalse;
  }

  // Explicit conversion from DBBool to bool. Throws an 
  // exception if the given DBBool is dbNull, otherwise returns
  // true or false:
  [Conditional("Debug")]
  public static explicit operator bool(DBBool x) 
  {
    if (x.value == 0) throw new InvalidOperationException();
    return x.value > 0;
  }

  // Equality operator. Returns dbNull if either operand is dbNull, 
  // otherwise returns dbTrue or dbFalse:
  [Conditional("Debug")]
  public static DBBool operator ==(DBBool x, DBBool y) 
  {
    if (x.value == 0 || y.value == 0) return dbNull;
    return x.value == y.value? dbTrue: dbFalse;
  }

  // Inequality operator. Returns dbNull if either operand is
  // dbNull, otherwise returns dbTrue or dbFalse:
  [Conditional("Debug")]
  public static DBBool operator !=(DBBool x, DBBool y) 
  {
    if (x.value == 0 || y.value == 0) return dbNull;
    return x.value != y.value? dbTrue: dbFalse;
  }

  // Logical negation operator. Returns dbTrue if the operand is 
  // dbFalse, dbNull if the operand is dbNull, or dbFalse if the
  // operand is dbTrue:
  [Conditional("Debug")]
  public static DBBool operator !(DBBool x) 
  {
    return new DBBool(-x.value);
  }

  // Logical AND operator. Returns dbFalse if either operand is 
  // dbFalse, dbNull if either operand is dbNull, otherwise dbTrue:
  [Conditional("Debug")]
  public static DBBool operator &(DBBool x, DBBool y) 
  {
    return new DBBool(x.value < y.value? x.value: y.value);
  }

  // Logical OR operator. Returns dbTrue if either operand is 
  // dbTrue, dbNull if either operand is dbNull, otherwise dbFalse:
  [Conditional("Debug")]
  public static DBBool operator |(DBBool x, DBBool y) 
  {
    return new DBBool(x.value > y.value? x.value: y.value);
  }

  // Definitely true operator. Returns true if the operand is 
  // dbTrue, false otherwise:
  [Conditional("Debug")]
  public static bool operator true(DBBool x) 
  {
    return x.value > 0;
  }

  // Definitely false operator. Returns true if the operand is 
  // dbFalse, false otherwise:
  //[Conditional("Debug")]
  public static bool operator false(DBBool x) 
  {
    return x.value < 0;
  }

  // Overload the conversion from DBBool to string:
  [Conditional("Debug")]
  public static implicit operator string(DBBool x) 
  {
    return x.value > 0 ? "dbTrue"
      : x.value < 0 ? "dbFalse"
      : "dbNull";
  }

  // Override the Object.Equals(object o) method:
  [Conditional("Debug")]
  public override bool Equals(object o) 
  {
    try 
    {
      return (bool) (this == (DBBool) o);
    }
    catch 
    {
      return false;
    }
  }

  // Override the Object.GetHashCode() method:
  [Conditional("Debug")]
  public override int GetHashCode() 
  {
    return value;
  }

  // Override the ToString method to convert DBBool to a string:
  [Conditional("Debug")]
  public override string ToString() 
  {
    switch (value) 
    {
      case -1:
        return "DBBool.False";
      case 0:
        return "DBBool.Null";
      case 1:
        return "DBBool.True";
      default:
        throw new InvalidOperationException();
    }
  }
}

class Test 
{
  public static int Main() 
  {
    return 1;
  }
}
`
(22,4): error CS0577: Conditional not valid on 'DBBool.implicit operator DBBool(bool)' because it is a constructor, destructor, operator, or explicit interface implementation
(31,4): error CS0577: Conditional not valid on 'DBBool.explicit operator bool(DBBool)' because it is a constructor, destructor, operator, or explicit interface implementation
(40,4): error CS0577: Conditional not valid on 'DBBool.operator ==(DBBool, DBBool)' because it is a constructor, destructor, operator, or explicit interface implementation
(49,4): error CS0577: Conditional not valid on 'DBBool.operator !=(DBBool, DBBool)' because it is a constructor, destructor, operator, or explicit interface implementation
(59,4): error CS0577: Conditional not valid on 'DBBool.operator !(DBBool)' because it is a constructor, destructor, operator, or explicit interface implementation
(67,4): error CS0577: Conditional not valid on 'DBBool.operator &(DBBool, DBBool)' because it is a constructor, destructor, operator, or explicit interface implementation
(75,4): error CS0577: Conditional not valid on 'DBBool.operator |(DBBool, DBBool)' because it is a constructor, destructor, operator, or explicit interface implementation
(83,4): error CS0577: Conditional not valid on 'DBBool.operator true(DBBool)' because it is a constructor, destructor, operator, or explicit interface implementation
(98,4): error CS0577: Conditional not valid on 'DBBool.implicit operator string(DBBool)' because it is a constructor, destructor, operator, or explicit interface implementation
(107,4): error CS0243: Conditional not valid on 'DBBool.Equals(object)' because it is an override method
(121,4): error CS0243: Conditional not valid on 'DBBool.GetHashCode()' because it is an override method
(128,4): error CS0243: Conditional not valid on 'DBBool.ToString()' because it is an override method
`
public class Test
{
   public static void Main()
   {
      int[,] a = new int[10,10];
      a[4][3][4] = 9;
   }
}
`
(6,7): error CS0022: Wrong number of indices inside [], expected '2'
`
struct myStruct
{
  public int x;
  public int y;
}

class A
{
  public static int Main()
  {
    myStruct[,] arr = new myStruct[3,2];
    
    myStruct ms;
    ms.x = 4;
    ms.y = 5;

    arr[2,0] = ms;

    if (arr[2,0].x == 4 && arr[2,0].y == 5)
      return 0;

    return 1;
  }
}
`
`
using System;
using System.Diagnostics;


public class A 
{
  [Conditional("Debug")]
  public static int Main()
  {
    return 1;
  }
}
`
(7,4): error CS0578: Conditional not valid on 'A.Main()' because its return type is not void
`
using System;

public class A 
{
  public static int Main()
  {
    Type t = typeof(void);
    if (t.Name == "Void")
      return 0;
    else
      return 1;
  }
}
`
`
using System;
using System.Diagnostics;


public class A 
{
  public static int Main()
  {
    Type t = typeof(void);
    if (t == System.Void)
      return 1;
    else
      return 1;
  }
}
`
(10,14): error CS0118: 'void' is a 'class' but is used like a variable
`
using System;

class A
{
  public static int Main()
  {
        int[,] arr = new int[,] { {1,2,3}, {4,5,6} };
        
        foreach (int i in arr)
        {
            Console.WriteLine(i);
        }

    return 0;
  }
}
`
1
2
3
4
5
6
`
using System;

[AttributeUsage(AttributeTargets.All)]
public class MyAtt : Attribute{}

public class Test
{
  private delegate int D([MyAtt]int ii);

  public static int Main()
  {
    D d = delegate(int ii)
    {   
      return ii;
    };
    int ret = d(1);
    if(ret == 1)
      return 0;
    else
      return 1;
  }
}
`
`
using System;

ref class C1 {}
ref struct S1 {}

namespace N {
    ref class C2 {}
    ref struct S2 {}
}

class Test {
  static void Main() {}
}
`
(3,1): error CS1519: Invalid token 'ref' in class, struct, or interface member declaration
(4,1): error CS1519: Invalid token 'ref' in class, struct, or interface member declaration
(7,5): error CS1519: Invalid token 'ref' in class, struct, or interface member declaration
(8,5): error CS1519: Invalid token 'ref' in class, struct, or interface member declaration
`
using System;
using System.Diagnostics;

public class A 
{
  [Conditional(null)]
  public void foo(){}

  public static int Main()
  {
    return 1;
  }
}
`
(6,16): error CS0591: Invalid value for argument to 'Conditional' attribute
`
using System;

public class Test
{
  unsafe delegate void D(int *pX); 
  
  unsafe public static void MyUnsafe(int *pX)
  {
    Console.WriteLine(*pX);
  }       
  public static int Main(String[] args)
      {
    D d = new D(Test.MyUnsafe);
    unsafe 
    {  
      int x = 10;
      d(&x);
    }
    return 1;
      }
}
`
(5,3): error CS0227: Unsafe code may only appear if compiling with /unsafe
`
using System;
using System.Runtime.CompilerServices;

public interface IA
{
  int this[int index]
  {
    get  ;
    set  ;
  }
}

public class A : IA
{
  [IndexerName("Item")]
  int IA.this[int index]
  {
    get  { return 0;  }
    set  {}
  }
  public static int Main()
  {
    return 1;
  }
}
`
(15,4): error CS0592: Attribute 'IndexerName' is not valid on this declaration type. It is valid on 'non interface implementation property' declarations only.
`
using System;
using System.Runtime.CompilerServices;

class Test
{
  [IndexerName("Item1")]
  public int this [int index]   
  {
    get{ return index; }
    set{}
  }

  [IndexerName("Item2")]
  public string this [string index]   
  {
    get{ return index; }
    set{}
  }

  public static int Main()
  {
    return 1;
  }
}
`
(13,16): error CS0668: Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type
`
using System;

namespace Microsoft.Conformance.Expressions {

  public struct base020 {

    String TestString;

    override public String ToString() {
      return "foobar";
    }

    public int SetInt {
      set {
        TestString = base.ToString();        
      }
    }

    public static int Main()
    {
      base020 TC = new base020();
      TC.SetInt = 3;  
      if (TC.TestString.Equals("Microsoft.Conformance.Expressions.base020")) {
        return 0;
      }
      else {
        return 1;
      }    
    }
  }
}
`
`
class base1 {}

class base2 {}

class MyClass : base1, base2 {
  public static int Main() {
    return 1;  
  }
}
`
(5,24): error CS0527: 'base2' : type in interface list is not an interface
(3,7): (Location of symbol related to previous error)
`
class MyClass
{
  public int xx;
}

class ArrayCovariance
{
  public static int Main()
  {
    MyClass[] mc = new MyClass[10];

    for (int x=0; x < 10; x++)
    {
      mc[x] = new MyClass();
      System.Console.WriteLine(x);
      mc[xx].xx = x;
    }

    object[] o = new MyClass[10];

    mc = (MyClass[])o;
    
    return 0;
  }
}
`
(16,10): error CS0103: The name 'xx' does not exist in the current context
`
class MyClass
{
  public int x;
}

class ArrayCovariance
{
  public static int Main()
  {
    MyClass[] mc = new MyClass[10];

    for (int x=0; x < 10; x++)
    {
      mc[x] = new MyClass();
      System.Console.WriteLine(x);
      mc[x].x = x;
    }

    object[] o = new MyClass[10];

    mc = (MyClass[])o;
    
    return 0;
  }
}
`
0
1
2
3
4
5
6
7
8
9
`
using System;
using System.Runtime.CompilerServices;

class Test
{
  [IndexerName("Item1")][IndexerName("Item2")]
  public int this [int index]   
  {
    get{ return index; }
    set{}
  }

  public static int Main()
  {
    return 1;
  }
}
`
(6,26): error CS0579: Duplicate 'IndexerName' attribute
`
using System;
[AttributeUsage(AttributeTargets.All)]
public class MyAtt : Attribute{}

public class Test
{
  [MyAtt][return:MyAtt]
  private delegate string D([MyAtt]Type t);

  public static int Main()
  {
    D d = delegate(Type t){return t.ToString();};
    if(d.GetType().ToString() == d(d.GetType()))
      return 0;
    else
      return 1;
  }
}
`
`
using System;
using System.Runtime.CompilerServices;

class Test
{
  // default is Item
  public int this [int index]   
  {
    get{ return index; }
    set{}
  }

  [IndexerName("Item1")]
  public string this [string index]   
  {
    get{ return index; }
    set{}
  }

  public static int Main()
  {
    return 1;
  }
}
`
(13,16): error CS0668: Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type
`
struct MyTest {}

class MyClass {

  const MyTest test = new MyTest();

  public static int Main() {
    return 1;
  }
}
`
(5,23): error CS0133: The expression being assigned to 'MyClass.test' must be constant
`
using System;
using System.Runtime.CompilerServices;

public class bug
{
  [IndexerName("123")]
  public int this [int index]
  {
    get
    {
      return 0;
    }
  }

  public static int Main()
  {
    return 1;
  }
}
`
(6,16): error CS0633: The argument to the IndexerName attribute must be a valid identifier
`
using System;

[AttributeUsage(AttributeTargets.Class, AllowMultiple=true, AllowMultiple=false)]
class MyAtt : Attribute
{}

[MyAtt]
public class Test
{
  public static int Main()
  {
    return 1;
  }
}
`
(3,61): error CS0643: 'AllowMultiple' duplicate named attribute argument
`
using System;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Assembly,Inherited=true,Inherited=AllowMultiple=false)]
class MyAtt : Attribute
{}

[MyAtt]
public class Test
{
  public static int Main()
  {
    return 1;
  }
}
`
(3,93): error CS0103: The name 'AllowMultiple' does not exist in the current context
(3,83): error CS0643: 'Inherited' duplicate named attribute argument
`
using System;

[AttributeUsage(AttributeTargets.Class)]
public class HelpAttribute : Attribute
{
  public HelpAttribute(decimal b1) {
      b = b1;
  }
  decimal b = 10;
  public decimal Verify {get {return b;} }
}

[HelpAttribute(100)] 
class Class1
    {
    }
    
public class MainClass
    {
    public static int Main ()
        {
        Class1 c1 = new Class1();
      object[] attrs = typeof(Class1).GetCustomAttributes(false);
    for (int i = 0; i < attrs.Length; i++)
        {
           HelpAttribute a = (HelpAttribute)attrs[i];
        Console.WriteLine("{0} : {1}", i, a.Verify);
      }

        return 0;
        }
    }
`
(13,16): error CS0182: An attribute argument must be a constant expression, typeof expression or array creation expression
`
using System;

[AttributeUsage(AttributeTargets.Class)]
public class HelpAttribute : Attribute
{
    public HelpAttribute(System.Type[] b1) {
        b = b1[1];
    }
    System.Type b = typeof(HelpAttribute);
    public System.Type Verify {get {return b;} }
}

[HelpAttribute(new System.Type[2] {typeof(Class1), typeof(MainClass)})] 
class Class1
    {
    }
    
public class MainClass
    {
    public static int Main ()
        {
//        Class1 c1 = new Class1();
        object[] attrs = typeof(Class1).GetCustomAttributes(false);
        for (int i = 0; i < attrs.Length; i++)
            {
            HelpAttribute a = attrs[i] as HelpAttribute;
            if (a == null) continue;
            Console.WriteLine("{0} : {1}", i, a.Verify);
            }

        return 0;
        }
    }
`
0 : MainClass
`
using System;
public class Test
{
    public static int Main(string [] args)
    {
    variant bits = (variant)8;
    bits = (variant)(bits << 1);
    if (bits != 16)
      return(1);
    bits = (variant)(bits >> 1);
    if (bits != 8)
      return(1);

    return(0);
    }
}
`
(6,5): error CS0246: The type or namespace name 'variant' could not be found (are you missing a using directive or an assembly reference?)
`
using System;

[AttributeUsage(AttributeTargets.Class)]
public class A : Attribute {
    object m_value;
    public A(object value) {
        this.m_value = value;
    }
    public object Value { get {return m_value;} }
}

class Class1 {
    public static int ReturnIntValue() {
        return 3;
    }
    public const int IntValue = 1;
    public static readonly int ReadOnlyIntValue = 2;
}

// Illegal examples
[A(Class1.ReturnIntValue())] class Example10 {}        // Error

public class MainClass
    {
    public static int Main ()
        {
        Console.WriteLine ("FAIL");
        return 1;
        }
    }
`
(21,4): error CS0182: An attribute argument must be a constant expression, typeof expression or array creation expression
`
using System;
using System.Diagnostics;

namespace a
{
    interface i 
        {
        void zz();
        }
        
  public class z : i
  {
    [Conditional("DEBUG")]
    public void zz() {}
  }
  public class a
  {
    public static int Main()
    {
        return 1;
    }
  }
}
`
(14,17): error CS0629: Conditional member 'a.z.zz()' cannot implement interface member 'a.i.zz()'
(8,14): (Location of symbol related to previous error)
`
using System;
using System.Text;
using System.Runtime.InteropServices;

public class C
    {
    [DllImport(1)]
    public static extern int GetCurrentDirectory(int bufSize, StringBuilder buf);
    }
    
public class MainClass
    {
    public static int Main ()
        {
        return 1;
        }
    }

`
(7,16): error CS0029: Cannot implicitly convert type 'int' to 'string'
`
using System;
using System.Runtime.InteropServices;

[Guid("00020810000000000C000000000000046")]
class Worksheet {}

public class MainClass
    {
    public static int Main ()
        {
        Worksheet w = new Worksheet();  // Creates an Excel worksheet
        Console.WriteLine ("FAIL");
        return 1;
        }
    }
`
(4,7): error CS0591: Invalid value for argument to 'Guid' attribute
`
using System;

[AttributeUsage(AttributeTargets.Class)]
public class A : Attribute {
    object m_value;
  public A(object value) {
    this.m_value = value;
  }
  public object Value { get {return m_value;} }
}
public enum Color { Red, Green, Blue }
public enum Weekday {Sun, Mon, Tue, Wed, Thu, Fri, Sat}
class Class1 {
  public static int ReturnIntValue() {
    return 3;
  }
  public const int IntValue = 1;
  public static readonly int ReadonlyIntValue = 2;
}

// Legal examples
[A(1)] class Example1 {}
[A(Class1.IntValue)] class Example2 {}
[A(1 + 2)] class Example3 {}
[A("hello" + "world")] class Example4 {}
[A(typeof(object))] class Example5 {}
[A(new int[] {1, 2, 3, 4})] class Example6 {}
[A(new string[] {"hello", "world"})] class Example7 {}
[A(new Type[] {typeof(object), typeof(string)})] class Example8 {}

public class MainClass
    {
    public static int Main ()
        {
        Example1 e1 = new Example1();
        Example2 e2 = new Example2();
        Example3 e3 = new Example3();
        Example4 e4 = new Example4();
        Example5 e5 = new Example5();
        Example6 e6 = new Example6();
        Example7 e7 = new Example7();
        Example8 e8 = new Example8();

      object[] attrs = typeof(Example1).GetCustomAttributes(false);
    for (int i = 0; i < attrs.Length; i++)
        {
           A a = attrs[i] as A;
           if (a == null) continue;
        Console.WriteLine("Example1 : {0}", a.Value);
      }

      attrs = typeof(Example2).GetCustomAttributes(false);
    for (int i = 0; i < attrs.Length; i++)
        {
           A a = attrs[i] as A;
           if (a == null) continue;
        Console.WriteLine("Example2 : {0}", a.Value);
      }

      attrs = typeof(Example3).GetCustomAttributes(false);
    for (int i = 0; i < attrs.Length; i++)
        {
           A a = attrs[i] as A;
           if (a == null) continue;
        Console.WriteLine("Example3 : {0}", a.Value);
      }

      attrs = typeof(Example4).GetCustomAttributes(false);
    for (int i = 0; i < attrs.Length; i++)
        {
           A a = attrs[i] as A;
           if (a == null) continue;
        Console.WriteLine("Example4 : {0}", a.Value);
      }

      attrs = typeof(Example5).GetCustomAttributes(false);
    for (int i = 0; i < attrs.Length; i++)
        {
           A a = attrs[i] as A;
           if (a == null) continue;
        Console.WriteLine("Example5 : {0}", a.Value);
      }

      attrs = typeof(Example6).GetCustomAttributes(false);
    for (int i = 0; i < attrs.Length; i++)
        {
           A a = attrs[i] as A;
           if (a == null) continue;
           int[] ia = (int[])a.Value;
        Console.WriteLine("Example6 : {0}", ia[0]);
        Console.WriteLine("Example6 : {0}", ia[1]);
        Console.WriteLine("Example6 : {0}", ia[2]);
        Console.WriteLine("Example6 : {0}", ia[3]);
      }

      attrs = typeof(Example7).GetCustomAttributes(false);
    for (int i = 0; i < attrs.Length; i++)
        {
           A a = attrs[i] as A;
           if (a == null) continue;
           string[] s = (string[])a.Value;
        Console.WriteLine("Example7 : {0}", s[0]);
        Console.WriteLine("Example7 : {0}", s[1]);
      }

      attrs = typeof(Example8).GetCustomAttributes(false);
    for (int i = 0; i < attrs.Length; i++)
        {
           A a = attrs[i] as A;
           if (a == null) continue;
           Type[] t = (Type[])a.Value;
        Console.WriteLine("Example8 : {0}", t[0]);
        Console.WriteLine("Example8 : {0}", t[1]);
      }

        return 0;
        }
    }
`
(35,18): warning CS0219: The variable 'e1' is assigned but its value is never used
(36,18): warning CS0219: The variable 'e2' is assigned but its value is never used
(37,18): warning CS0219: The variable 'e3' is assigned but its value is never used
(38,18): warning CS0219: The variable 'e4' is assigned but its value is never used
(39,18): warning CS0219: The variable 'e5' is assigned but its value is never used
(40,18): warning CS0219: The variable 'e6' is assigned but its value is never used
(41,18): warning CS0219: The variable 'e7' is assigned but its value is never used
(42,18): warning CS0219: The variable 'e8' is assigned but its value is never used
Example1 : 1
Example2 : 1
Example3 : 3
Example4 : helloworld
Example5 : System.Object
Example6 : 1
Example6 : 2
Example6 : 3
Example6 : 4
Example7 : hello
Example7 : world
Example8 : System.Object
Example8 : System.String
`
using System;
using System.Runtime.InteropServices;

[ComImport] //Must have guid. guid("00020810-0000-0000-C000-000000000046")]
class Worksheet {}

public class MainClass
    {
    public static int Main ()
        {
    Worksheet w = new Worksheet();  // Creates an Excel worksheet
        Console.WriteLine ("FAIL");
        return 1;
        }
    }
    
`
(5,7): error CS0596: The Guid attribute must be specified with the ComImport attribute
`
using System;

public class Test{
  class Bar{}
  public static void Main(string[] args){
    object ob = Test.Bar;
  }
}
`
(6,17): error CS0118: 'Test.Bar' is a 'class' but is used like a variable
`
using System;

public class Test {
     public static void h() {}
     
     static void Main() {
       Console.WriteLine(Test.h());
    }
}
`
(7,26): error CS0029: Cannot implicitly convert type 'void' to 'object'
`
using System;

public class Test {
  public static void Main( string[] args ) {
    int firstx = 0;
    Console.WriteLine(firstx);*/
  }
}
`
(6,31): error CS1525: Invalid expression term '*/'
`
using System;

public class Test {
  static void Main() {
    string s1 = "test";
    s1 += "lala";    
    Console.WriteLine("res: " + s1);
  }
}
`
res: testlala
`
using System;
using System.Reflection;

[assembly: AssemblyTitle("hello there")]

public class Test{
  public static void Main(string[] args){
    Console.WriteLine(((AssemblyTitleAttribute)(typeof(Test).Assembly.GetCustomAttributes(typeof(AssemblyTitleAttribute),false)[0])).Title);
  }
}
`
hello there
`
using System;

public class B<T, U> {}

internal class C
{
   protected class C1 {}
   public class C2 {}

   protected B<C1, C2> memberFunction() {return null;}

   public static int Main()
   {
      return 0;
   }
}
`
`
public enum context { context };

class Foo {
    static void Main() {}
}
`
`
using System;

struct Foo{
  public int x;
  public int X{
    get{return 0;}
    set{x = value;}
  }
  public int bar{
    get{
      return 1;
    }
  }
}

class Test {
  public static void Main() {
    Foo f;
    f.x = 5;
    f.X += f.bar;
    Console.WriteLine(f.x);
  }
}
`
1
`
using System;

public class Test {
  delegate int F(int a);
  public static int foo(int a){return 0;}
  static void Main() {
    const F f = new F(foo);
  }
}
`
(7,13): error CS0133: The expression being assigned to 'f' must be constant
`
public class MyClass {

  const float f1 = 2.0f;
  const float f2 = 2.0f;
  const float f3 = 3.0f;

  public static int Main() {

    if (!(f1 == f2)) return 1;
    if ((f1 == f3)) return 1;
    if ((f1 != f2)) return 1;
    if (!(f1 != f3)) return 1;
    if (f1 > f2) return 1;
    if (!(f3 > f1)) return 1;
    if (f1 > f3) return 1;
    if (f1 < f2) return 1;
    if (!(f1 < f3)) return 1;
    if (f3 < f1) return 1;
    if (!(f1 >= f2)) return 1;
    if (!(f3 >= f1)) return 1;
    if (f1 >= f3) return 1;
    if (!(f1 <= f2)) return 1;
    if (!(f1 <= f3)) return 1;
    if (f3 <= f1) return 1;
        
    return 0;
  }
}
`
`
using System;

    // two normal classes...
public class Res1: IDisposable
{
    public void Dispose()
    {
        Console.WriteLine("Res1.Dispose()");
    }
    public void Func()
    {
        Console.WriteLine("Res1.Func()");
    }
    public void Throw()
    {
        throw(new Exception("Res1"));
    }
}

public class Res2: IDisposable
{
    public void Dispose()
    {
        Console.WriteLine("Res2.Dispose()");
    }
    public void Func()
    {
        Console.WriteLine("Res2.Func()");
    }
    public void Throw()
    {
        throw(new Exception("Res2"));
    }
}

    // IDispose implemented explicitly
public class ResExplicit: IDisposable
{
    void IDisposable.Dispose()
    {
        Console.WriteLine("ResExplicit.Dispose()");
    }
    public void Func()
    {
        Console.WriteLine("ResExplicit.Func()");
    }
    public void Throw()
    {
        throw(new Exception("ResExplicit"));
    }
}

    // A class that doesn't implement IDisposable.
public class NonRes1
{
    public void GarbageDisposal()
    {
        Console.WriteLine("NonRes1.GarbageDisposal()");
    }
    public void Func()
    {
        Console.WriteLine("NonRes1.Func()");
    }
    public void Throw()
    {
        throw(new Exception("NonRes1"));
    }
}

    // Doesn't implement IDisposable, but has a Dispose() function...
public class NonRes2
{
    public void Dispose()
    {
        Console.WriteLine("NonRes2.Dispose()");
    }
    public void Func()
    {
        Console.WriteLine("NonRes2.Func()");
    }
    public void Throw()
    {
        throw(new Exception("NonRes2"));
    }
}

public class Test
{
    public static void Main()
    {
    try
    {
        using (Res1 res1 = new Res1())
        {
            res1.Throw();
        }
    }
    catch
    {
        Console.WriteLine("Exception caught");
    }
    }
}
`
Res1.Dispose()
Exception caught
`
using System;

public class Res1: IDisposable
{
    public void Dispose()
    {
    }
}

public class Test
{
    public static void Main()
    {
      using (Res1 res1 = new Res1())
      {
          res1 = null;
      }
    }
}
`
(16,11): error CS1604: Cannot assign to 'res1' because it is read-only
`
class MyClass {

  public int intI = 2;

  public static bool operator > (MyClass MyInt, MyClass MyInt2) {
    if (MyInt.intI == MyInt2.intI) {
      return true;
    }
    else {
      return false;
    }
  }

  public static bool operator < (MyClass MyInt, MyClass MyInt2) {
    return false;
  }

  public static int Main() {
    MyClass Test1 = new MyClass();
    MyClass Test2 = new MyClass();
    MyClass Test3 = new MyClass();
  
    Test2.intI = 3;    

    if ((Test1 > Test3) && (!(Test1 < Test2))) {
      return 0;
    }
    else {
      return 1;
    }    
  }

}
`
`
using System;

public class Test
{
  public static void Main()
  {
    int index = 0;
    int[] a = new int[12];
    a[index++] = 10;
    Console.WriteLine(a[--index]);
  }
}
`
10
`
`/r:System.Drawing.dll
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;

public class MyControl {

  public Size Size {
    get { return new Size(10,10); }
  }
  
}
public class MyGrid : MyControl {

  Size gridSize = Size.Empty;
  
  public static void Main(){
  }
 
}
`
`
using System;

public class Test {       
  static void Main() {
    SortDirection d = SortDirection.Ascending;
  }
}

public enum SortDirection { None, Ascending};
`
(5,19): warning CS0219: The variable 'd' is assigned but its value is never used
`
using System;

public class BaseTest {
    public void OnTextChanged(object sender, EventArgs e) {
    }   
}

public class Test : BaseTest {
    
    public Test() {
      EventHandler h = new EventHandler(this.OnTextChanged);    
    }    
    
    static void Main() {          
    }
}
`
(11,20): warning CS0219: The variable 'h' is assigned but its value is never used
`
using System;
class A{
  public static void Main()
  {
    int[,,] arr3 = new int[1,1,1] {{{1}}};
    Console.WriteLine(arr3[0,0,0]);
  }
}
`
1
`
using System;

public class Client
{
    public static void Main(String[] args)
    {
        float f = 0;
        f += 1;
        Console.WriteLine(f);
    }
}
`
1
`
using System;

struct A 
{
  private int a;

  public int MyMethod() 
  {
    // This code is here to avoid the "a not used" compiler warning
    a = 5;
    if (a == 5)
      a++;
    return a;
  }
}

class main 
{
  public static int Main() 
  {
    A a = new A();
    return a.MyMethod()-6;
  }
}
`
`
struct MyStruct {
  public int Test;
}

class MyClass {

  readonly MyStruct sctS = new MyStruct();  

  public static int Main() {

    MyClass MC = new MyClass();
    
    if (MC.sctS.Test == 0){
      return 0;
    } else {
      return 1;
    }
  }
}
`
`
using System;

class SBase 
{
}

class S : SBase
{
}

class SDer : S
{
}

class TBase 
{
  static public implicit operator TBase(SDer foo)
  {
    Console.WriteLine("SDer to TBase <Dest> implicit");
    return new TBase();
  }
}

class T : TBase
{
}

class TDer : T
{
}

class Convert
{
  public static void Main()
  {
    S s = new S();
    T t;

    try
    {
      t = (T) s;
    }
    catch (System.InvalidCastException e)
    {
      Console.WriteLine("Exception Caught");
    }
  }
}
`
(41,7): warning CS0219: The variable 't' is assigned but its value is never used
(43,40): warning CS0219: The variable 'e' is assigned but its value is never used
Exception Caught
`
using System;

public class Test {
    static void Main() {
      IntPtr ip = IntPtr.Zero;
      int i = (int)ip;
    }
}
`
(6,11): warning CS0219: The variable 'i' is assigned but its value is never used
`
using System;

public class Test {
    static void Main() {
      string s = "a b";
      string[] tokens = s.Split(null);
      foreach (string str in tokens)
        Console.WriteLine(str);
    }
}
`
a
b
`
using System;

public class Class
{

 public static void Main()
  {

  int msgnr = 1;
  Console.WriteLine((msgnr-1).ToString()); 
  }
}
`
0
`
public class Test     
{
    public struct Globals
    {
        public void doBug()
        {
            Test_s.WriteString();
        }
        public Test.myStruct Test_s;
    }
    public struct myStruct
    {
        public void WriteString()
        {
          System.Console.WriteLine("hello");
        }
    }
    public static void Main(){
      Globals glob = new Globals();
      glob.doBug();
    }
}
`
hello
`
using System;

public class C{}

public struct S 
{
  public C c;
  
  public S(C c)
  {
    this.c = c;
  }

  public static implicit operator S(C c)
  {
    return new S(c);
  }
}

public class Test
{
    
  public static int Main()
  {
    S s = null;
    return ((s.c == null) ? 0 : 1);
  }
}
`
`
using System;

public class MyClass {
  public static int Main() {

    ulong ul1 = 2;

    if ((0 ^ ul1) == 2) {
      return 0;
    }
    else {
      return 1;
    }
  }  
}
`
`
using System;

public class MyClass {
  public static int Main() {

    ulong ul1 = 2;

    if ((ul1 & 0) == 0) {
      return 0;
    }
    else {
      return 1;
    }
  }  
}
`
(6,11): warning CS0219: The variable 'ul1' is assigned but its value is never used
`
using System;

public class TestClass {}

public class MyClass {

  public static int Main() {

    TestClass tc = new TestClass();
    object o = tc;
    bool b = o is object;

    if (b == true) {
      o=null;
      if (o is object)
        return 1;
      else
        return 0;
    }
    else {
      return 1;
    }  
  }

}
`
`
using System;

public class MyBase {}

public class TestClass : MyBase {}

public class MyClass {

  public static int Main() {
    TestClass tc = new TestClass();
    bool b = tc is MyBase;

    if(b)
      return 0;
    else
      return 1;
  }

}
`
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
    Method();
        return(0);
    }

  public static void Method()
  {
    goto Label;
Label:
  }
}
`
(14,6): error CS1002: ; expected
`
using System;
public class Test
{  public static int counter = 0;
  public static bool result = true;
  public static void Eval(bool exp)
  {
    counter++;
    if (!exp){result = exp;Console.WriteLine("Test Failed at location: " + counter);}
  }
  public static object TestSwitch(short val)
  {
    switch(val)
    {
    case (short)short.MinValue: return (short)short.MinValue;
    case (short)short.MinValue+1: return (short)short.MinValue+1;
    case (short)sbyte.MinValue: return (short)sbyte.MinValue;
    case (short)-1: return (short)-1;
    case (short)0: return (short)0;
    case (short)1: return (short)1;
    case (short)0x7F: return (short)0x7F;
    case (short)0xFE: return (short)0xFE;
    case (short)0xFF: return (short)0xFF;
    case (short)0x7FFE: return (short)0x7FFE;
    case (short)0x7FFF: return (short)0x7FFF;
    default: return null;
    }
  }
  public static int Main()
  {
    Test.Eval(((short)short.MinValue).Equals(TestSwitch(short.MinValue)));
    Test.Eval(((short)short.MinValue+1).Equals(TestSwitch(short.MinValue+1)));
    Test.Eval(((short)sbyte.MinValue).Equals(TestSwitch(sbyte.MinValue)));
    Test.Eval(((short)-1).Equals(TestSwitch(-1)));
    Test.Eval(((short)0).Equals(TestSwitch(0)));
    Test.Eval(((short)1).Equals(TestSwitch(1)));
    Test.Eval(((short)0x7F).Equals(TestSwitch(0x7F)));
    Test.Eval(((short)0xFE).Equals(TestSwitch(0xFE)));
    Test.Eval(((short)0xFF).Equals(TestSwitch(0xFF)));
    Test.Eval(((short)0x7FFE).Equals(TestSwitch(0x7FFE)));
    Test.Eval(((short)0x7FFF).Equals(TestSwitch(0x7FFF)));
    if (result)
      return 0;
    return 1;
  }
}
`
`
static class Test
{
    // Declare types inside a static class
    class TypeClass
    {
        public int TypeMember;
    }

    struct TypeStruct
    {
        public TypeEnum TypeMember;
    }    

    enum TypeEnum
    {
        TypeMember
    }    

    delegate int TypeDelegate();

    // Declare usage of types inside a static class
    static TypeClass aClass;
    static TypeStruct aStruct;
    static event TypeDelegate aDelegate;
    
    static Test() 
    {
        // Instantiate types inside a static class
        aClass = new TypeClass();
        aStruct = new TypeStruct();
        aDelegate = new TypeDelegate(Main);

        // Use types inside a static class
        aClass.TypeMember = 1;
        aStruct.TypeMember = TypeEnum.TypeMember;
        aDelegate();
    }
    public static int Main()
    {
        return aClass.TypeMember - 1;
    }
}
`
`
partial class C {}
public partial class C {}
public partial class C { }


public class Test
{
  public static int Main()
  {
    return (new C().GetType().IsPublic ? 0 : 1);
  }
}
`
`
partial class C { partial class Nested {}}
public partial class C { partial class Nested {}}
partial class C { public partial class Nested {}}
public partial class C { public partial class Nested {}}
public partial class C { public partial class Nested {}}


public class Test
{
  public static int Main()
  {
    return (new C.Nested().GetType().IsNestedPublic ? 0 : 1);
  }
}
`
`
partial class C { partial class Nested { } }
partial class C { private partial class Nested { } }
public partial class C { partial class Nested { } }


public partial class C 
{ 
  private partial class Nested {}
  public static int Test()
  {
    return (new Nested().GetType().IsNestedPrivate ? 0 : 1);
  }
}


public class Test
{
  public static int Main()
  {
    return C.Test();
  }
}
`
`
public partial class C { }
abstract partial class C { }
partial class C { }


public class Test
{
  public static int Main()
  {
    return (typeof(C).IsPublic &&  typeof(C).IsAbstract ? 0 : 1);
  }
}
abstract public partial class C { }
public abstract partial class C { }
`
`
public class Test
{
  public static int Main()
  {
    return (typeof(C.Nested).IsNestedAssembly  && typeof(C.Nested).IsAbstract? 0 : 1);
  }
}
     
partial class C { partial class Nested { } }
partial class C { abstract partial class Nested { } }
partial class C { internal partial class Nested { } }
partial class C { internal abstract partial class Nested { } }
partial class C { abstract internal partial class Nested { } }
public partial class C { partial class Nested { } }
`
`
partial class C { }
sealed partial class C { }
public partial class C { }

public class Test
{
  public static int Main()
  {
    return (typeof(C).IsPublic &&  typeof(C).IsSealed ? 0 : 1);
  }
}
     

public sealed partial class C { }
sealed public partial class C { }
`
`
class C
{
  partial class Nested { } 
  public partial class Nested { } 
  sealed partial class Nested { } 
  public sealed partial class Nested { }
  sealed public partial class Nested { }
}


public class Test
{
  public static int Main()
  {
    return (typeof(C.Nested).IsNestedPublic && typeof(C.Nested).IsSealed? 0 : 1);
  }
}
`
`
partial class C { }
static partial class C { }
public partial class C { }

public class Test
{
  public static int Main()
  {
    return (typeof(C).IsPublic && typeof(C).IsSealed && typeof(C).IsAbstract ? 0 : 1);
  }
}
     

public static partial class C { }
static public partial class C { }
`
`
partial class C { abstract partial class Nested {} }
partial class C { sealed partial class Nested {} }


public class Test
{
  public static int Main()
  {
    return 1;
  }
}
`
(1,42): error CS0418: An abstract class cannot be sealed or static
(2,40): (Location of symbol related to previous error)
`
namespace TestClass {
  class Inner {
    public static int intI = 1;
  }
}

namespace MyNS
{
  class TestClass {
    public class Inner {
      public static int intI = 2;
    }
  }

  class MyClass {
    public static int Main() {
      if (TestClass.Inner.intI == 2) {
        System.Console.WriteLine("foo");
        return 0;
      }
      else {
        return 1;
      }
    }
  }

}
`
foo
`
namespace x{
  using foo;
  
  class A : B{
    public class C : D{}
  }
}
namespace x{
  using bar;
  
  class B : C{
    public class D : E{}
  }
}
namespace foo{
  class D{}
}
namespace bar{
  class E{}
  class C{
    public class E{}
  }
}
class Test{
  public static int Main(){
    if (typeof(x.A).BaseType != typeof(x.B)) return 1;
    if (typeof(x.A.C).BaseType != typeof(x.B.D)) return 2;
    if (typeof(x.B).BaseType != typeof(bar.C)) return 3;
    if (typeof(x.B.D).BaseType != typeof(bar.C.E)) return 4;
    return 0;
  }
}
`
`
using System;

interface I1 {}
interface I2 {}
interface I3 {}

class C1 {}
class C2 {}


partial class A : I1  {}

class Test
{
  public static bool VerifyBaseClassAndInterfaces(object obj, Type baseC, Type[] baseIArr)
  {
    bool res = true;
    Type type = obj.GetType();

    if (!(Object.ReferenceEquals(baseC,type.BaseType)))
    {
      Console.WriteLine("Failed To Verify base class {0} for specified type",baseC);
      res = false;
    }

    Type[] interfaces = type.GetInterfaces();

    for (int i = 0; (i<baseIArr.Length); i++)
    {
      int j;
      for (j = 0; (j<interfaces.Length);j++)
      {
        if (Object.ReferenceEquals(baseIArr[i],interfaces[j]))
          break;
      }
      if (j==interfaces.Length)
      {
        Console.WriteLine("Failed To Verify base interface {0} for specified type",baseIArr[i]);
        res = false;
      }
    }
    return res;
  }
  
  public static int Main()
  {
    if (VerifyBaseClassAndInterfaces(new A(),typeof(object),new Type[]{typeof(I1)}))
      return 0;
    else 
      return 1;
  }
}
`
`
using System;

interface I1 {}
interface I2 {}
interface I3 {}

class C1 {}
class C2 {}


partial class A {}
partial class A : C1 {}

class Test
{
  public static bool VerifyBaseClassAndInterfaces(object obj, Type baseC, Type[] baseIArr)
  {
    bool res = true;
    Type type = obj.GetType();

    if (!(Object.ReferenceEquals(baseC,type.BaseType)))
    {
      Console.WriteLine("Failed To Verify base class {0} for specified type",baseC);
      res = false;
    }

    Type[] interfaces = type.GetInterfaces();

    for (int i = 0; (i<baseIArr.Length); i++)
    {
      int j;
      for (j = 0; (j<interfaces.Length);j++)
      {
        if (Object.ReferenceEquals(baseIArr[i],interfaces[j]))
          break;
      }
      if (j==interfaces.Length)
      {
        Console.WriteLine("Failed To Verify base interface {0} for specified type",baseIArr[i]);
        res = false;
      }
    }
    return res;
  }
  
  public static int Main()
  {
    if (VerifyBaseClassAndInterfaces(new A(),typeof(C1),new Type[]{}))
      return 0;
    else 
      return 1;
  }
}
`
`
namespace partial
{
  partial interface partial
  {
    N1.partial Ipartial(N2.partial partial);
  }
}

namespace N1
{
  public partial class partial : global::partial.partial
  {
    static partial() { }
    public partial()
    {
      int partial = -1; partial++;
    }

    public partial Ipartial(N2.partial partial) { return new partial(); }
    ~partial() { }
  }
}

namespace N2
{
  public partial struct partial{}
  partial class Test
  {
    public const int partial = -1;

    static int Main()
    {
      N1.partial a = new N1.partial();
      partial b = new partial();
      N3.Test c = new N3.Test();
      N4.Test d = new N4.Test();
      N6.Test e = new N6.Test();
      N8.Test f = new N8.Test();

      return 0;
    }
  }

}

namespace N3
{
  class Test
  {
    int partial = +1;
  }
}

namespace N4
{
  partial class Test
  {
    int Partial = +1;

    int partial
    {
      get { return partial; }
      set { partial = value; }
    }
  }
}

namespace N5
{
  enum partial {partial, two}
}

namespace N6
{
  partial class Test
  {
    public event N7.partial partial;
  }
}

namespace N7
{
  public delegate N1.partial partial(N2.partial partial);
}

namespace N8
{
  partial class Test
  {
    public N1.partial partial(N2.partial partial)
    {
      return new N1.partial();
    }
  }
}

class Test
{
}
`
(33,18): warning CS0219: The variable 'a' is assigned but its value is never used
(34,15): warning CS0219: The variable 'b' is assigned but its value is never used
(35,15): warning CS0219: The variable 'c' is assigned but its value is never used
(36,15): warning CS0219: The variable 'd' is assigned but its value is never used
(37,15): warning CS0219: The variable 'e' is assigned but its value is never used
(38,15): warning CS0219: The variable 'f' is assigned but its value is never used
`
using System;

interface I1 
{
  int I1meth1();
  int I1meth2();
}

interface I2 
{
  int I2meth1();
  int I2meth2();
}

partial class A : I1  {}

partial class A
{
  int I1.I1meth1() 
  { 
    return 1;
  }
  
  public int I1meth2() 
  {
    return 1;
  }

  public int Test()
  {
    I1 Obj = this;
    return Obj.I1meth1() - Obj.I1meth2();
  }
}

class Test
{
  public static int Main()
  {
    return new A().Test();
  }
}
`
`
using System;
namespace N0.N1.N2.N3.N4.N5.N6.N7.N8.N9
{
  partial class Test
  {
    static public int i = N0.N1.N2.N3.N4.N5.N6.N7.N8.Test.I;

    static int Main()
    {
      if (i != 2*3*4*5*6*7*8*9)
        return 1;
      return 0;
    }
  }
}
namespace N0
{
  namespace N1
  {
    namespace N2
    {
      namespace N3
      {
        namespace N4
        {
          namespace N5
          {
            namespace N6
            {
              namespace N7
              {
                namespace N8
                {
                  partial class Test
                  {
                    static int i =  N0.N1.N2.N3.N4.N5.N6.N7.Test.I;
                  }
                }

                partial class Test
                {
                  static int i =  N0.N1.N2.N3.N4.N5.N6.Test.I;
                }
              }

              partial class Test
              {
                static int i =  N0.N1.N2.N3.N4.N5.Test.I;
              }
            }

            partial class Test
            {
              static int i =  N0.N1.N2.N3.N4.Test.I;
            }
          }

          partial class Test
          {
            static int i =  N0.N1.N2.N3.Test.I;
          }
        }

        partial class Test
        {
          static int i =  N0.N1.N2.Test.I;
        }
      }

      partial class Test
      {
        static int i =  N0.N1.Test.I;
      }
    }

    partial class Test
    {
      static int i =  N0.Test.I;
    }
  }

  partial class Test
  {
  }
}

namespace N0
{
  namespace N1
  {
    namespace N2
    {
      namespace N3
      {
        namespace N4
        {
          namespace N5
          {
            namespace N6
            {
              namespace N7
              {
                namespace N8
                {
                  partial class Test
                  {
                    static public int I { get { return 9*i; } }
                  }
                }

                partial class Test
                {
                  static public int I { get { return 8*i; } }
                }
              }

              partial class Test
              {
                static public int I { get { return 7*i; } }
              }
            }

            partial class Test
            {
              static public int I { get { return 6*i; } }
            }
          }

          partial class Test
          {
            static public int I { get { return 5*i; } }
          }
        }

        partial class Test
        {
          static public int I { get { return 4*i; } }
        }
      }

      partial class Test
      {
        static public int I { get { return 3*i; } }
      }
    }

    partial class Test
    {
      static public int I { get { return 2*i; } }
    }
  }

  partial class Test
  {
    static public int I { get { return 1; } }
  }
}

`
`
partial struct A {}
partial struct A {}
partial struct A {}

// --- Multiple non-empty partial struct declarations (each have a field)

partial struct B 
{
    public int X;
}

partial struct B
{
    public int Y;
}

partial struct B
{
    public int Z;
}

// --- Multiple non-empty partial struct declarations (each have a method)

partial struct C
{
    public void X() {}
}

partial struct C
{
    public void Y() {}
}

partial struct C
{
    public void Z() {}
}

// --- Multiple partial struct declarations each declaring a different type of member

partial struct D
{
    public D(int i) {m1 = i; m4 = null;}
}

partial struct D
{
    public int m1;
}

partial struct D
{
    public int m2() { return 0; }
}

partial struct D
{
    public int m3 { set {} }
}

partial struct D
{
    public int this[int x] { set {} }
}

partial struct D
{
    public event m5 m4;
}

partial struct D
{
    public delegate int m5();
}

partial struct D
{
    public enum m6 { one, two }
}

partial struct D
{
    public interface m7 {}
}

partial struct D
{
    public struct m8 {}
}

partial struct D
{
    public struct m9 {}
}

// --- Test Driver

struct Test
{
    static int Main() 
    {
        A a = new A();
        B b = new B();
        C c = new C();
        D d = new D(1);
        return 0;
    }
}
`
(102,11): warning CS0219: The variable 'a' is assigned but its value is never used
(103,11): warning CS0219: The variable 'b' is assigned but its value is never used
(104,11): warning CS0219: The variable 'c' is assigned but its value is never used
(105,11): warning CS0219: The variable 'd' is assigned but its value is never used
`
#undef DEBUG

using System;
using System.Diagnostics;

namespace a
    {
    public class Class1 
        {
      [Conditional("DEBUG")]
      public static void M() 
          {
          MainClass.retval++;
          Console.WriteLine("Executed Class1.M");
          }
        }
    public class Class2
        {
        public static void Test()
          {
            Class1.M();
          }
        }
  public class MainClass
      {
      public static int retval = 0;
      public static int Main()
        {
        Class2.Test();
        if (retval == 0) Console.WriteLine("PASS");
        else Console.WriteLine("FAIL");
            return retval;
        }
      }
    }

`
PASS
`
#define DEBUG1

using System;
using System.Diagnostics;

namespace a
    {
    public class Class1 
        {
        [Conditional("DEBUG1")]
        public static void M() 
           {
           MainClass.retval++;
           Console.WriteLine("Executed Class1.M");
           }
        }
    public class Class2
        {
        public static void Test()
           {
          Class1.M();
           }
        }
   public class MainClass
       {
       public static int retval = 0;
       public static int Main()
          {
          Class2.Test();
          if (retval != 0)
              {
              Console.WriteLine("PASS");
              return 0;
              }
             Console.WriteLine("FAIL");
            return 1;
          }
       }
    }
`
Executed Class1.M
PASS
`
using System;
using System.Reflection;
using System.Runtime.InteropServices;

namespace a {

public class C1 
    {
    public int mf([In] int i) 
        {
        if (typeof(C1).GetMethod("mf").GetParameters()[0].IsIn) 
            return 0x01;
        return 0;
        }
    }

public class C2 
    {
    public int mf([Out] int i)
        {
        if (typeof(C2).GetMethod("mf").GetParameters()[0].IsOut) 
            return 0x02;
        return 0;
        }
   }

public struct S1 
    {
    public int mf([In] int i)
        {
        if (typeof(S1).GetMethod("mf").GetParameters()[0].IsIn) 
            return 0x04;
        return 0;
        }
    }

public struct S2 
    {
    public int mf([Out] int i)
        {
        if (typeof(S2).GetMethod("mf").GetParameters()[0].IsOut) 
            return 0x08;
        return 0;
        }
    }


public interface I1 
    {
    int mf([In] int i);
    }

public interface I2 
    {
    int mf([Out] int i);
    }

public class CI1 : I1
    {
    public int mf([In] int i) 
        {
        if (typeof(CI1).GetMethod("mf").GetParameters()[0].IsIn) 
            return 0x10;
        return 0;
        }
    }

public class CI2 : I2
    {
    public int mf([Out] int i)
        {
        if (typeof(CI2).GetMethod("mf").GetParameters()[0].IsOut) 
            return 0x20;
        return 0;
        }
   }


public class MainClass
    {
    public static int Main ()
        {
        int retval = 0x3F;
        C1 c1 = new C1();
        retval -= c1.mf(retval);
        C2 c2 = new C2();
        retval -= c2.mf(retval);
        S1 s1 = new S1();
        retval -= s1.mf(retval);
        S2 s2 = new S2();
        retval -= s2.mf(retval);
        CI1 ci1 = new CI1();
        retval -= ci1.mf(retval);
        CI2 ci2 = new CI2();
        retval -= ci2.mf(retval);
        
        if (retval != 0) Console.WriteLine ("FAIL, {0}", retval);
        else Console.WriteLine ("PASS");
        return retval;
        }
    }
}
`
PASS
`
using System;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Collections;

namespace enum4
{

  public  interface ITrees
  {
    IEnumerator GetEnumerator();
  }

  public  class Garden : ITrees
  {

     [DispIdAttribute(-4)]
    IEnumerator ITrees.GetEnumerator()
    {
      return null;
    }
  }

  public class MainClass {
    public static int Main () {
      int retval = 1;
      Garden g = new Garden();
      try {
        MethodInfo[] mia = g.GetType().GetInterfaceMap(typeof(ITrees)).TargetMethods;
        foreach (MethodInfo mi in mia)
        {
          if ("enum4.ITrees.GetEnumerator" == mi.Name)
          {
            Console.WriteLine ("Matched");
            object[] aa = mi.GetCustomAttributes(false);
            foreach (object o in aa)
            {
              if ("System.Runtime.InteropServices.DispIdAttribute" == o.ToString())
              {
                DispIdAttribute dia = (DispIdAttribute)o;
                if (-4 == dia.Value)
                {
                  retval -= 1;
                }
              }
            }
          }
        }
      }
      catch (Exception e) {
        Console.WriteLine ("Failed to retrieve DispId: {0}", e.GetType().ToString());
      }
      if (retval == 0) Console.WriteLine ("PASS");
      else Console.WriteLine ("FAIL, retval=={0}", retval);
      return retval;
    }
  }
}
`
Matched
PASS
`
using System;
using System.Reflection;

public class C1 
    {
    [NonSerialized] public int i;
    }

public struct S1 
    {
    [NonSerialized] public int j;
    }

public class MainClass
    {
    public static int Main ()
        {
        int retval = 0x03;
        if ((typeof(C1).GetFields()[0].Attributes & FieldAttributes.NotSerialized) != 0)
            retval -= 0x01;
        if ((typeof(S1).GetFields()[0].Attributes & FieldAttributes.NotSerialized) != 0)
            retval -= 0x02;
        Console.WriteLine ("C1.i is {0}serialized", ((typeof(C1).GetFields()[0].Attributes & FieldAttributes.NotSerialized) != 0)?"not ":"");
        Console.WriteLine ("S1.j is {0}serialized", ((typeof(S1).GetFields()[0].Attributes & FieldAttributes.NotSerialized) != 0)?"not ":"");
        if (retval == 0) Console.WriteLine ("PASS");
        else Console.WriteLine ("FAIL");
        return retval;
        }
    }
`
C1.i is not serialized
S1.j is not serialized
PASS
`
using System;

namespace a {
[Obsolete]
class C1 {}

[Obsolete]
struct S1 {}

[Obsolete("Obsolescence message", true)]
interface I1 {}

public class CI1 : I1 {}

public class MainClass
    {
    public static int Main ()
        {
        object[] attrs = typeof(C1).GetCustomAttributes(false);
        attrs = typeof(S1).GetCustomAttributes(false);
        attrs = typeof(I1).GetCustomAttributes(false);
        Console.WriteLine ("FAIL");
        return 1;
        }
    }
}
`
(13,20): error CS0619: 'a.I1' is obsolete: 'Obsolescence message'
(19,33): warning CS0612: 'a.C1' is obsolete
(20,24): warning CS0612: 'a.S1' is obsolete
(21,24): error CS0619: 'a.I1' is obsolete: 'Obsolescence message'
`
namespace x.y{
  using foo;
  
  class A : B{
    public class C : D{}
  }
}
namespace x.y{
  using bar;
  
  class B : C{
    public class D : E{}
  }
}
namespace foo{
  class D{}
}
namespace bar{
  class E{}
  class C{
    public class E{}
  }
}
namespace test{
  class Test{
    public static int Main(){
      if (typeof(x.y.A).BaseType != typeof(x.y.B)) return 1;
      if (typeof(x.y.A.C).BaseType != typeof(x.y.B.D)) return 2;
      if (typeof(x.y.B).BaseType != typeof(bar.C)) return 3;
      if (typeof(x.y.B.D).BaseType != typeof(bar.C.E)) return 4;
      return 0;
    }
  }
}
`
`
public class MyClass {
  public static int Main() {
    decimal d1 = 1m;
    float f1 = 1.0f;
    decimal d2 = d1 + f1;
    return 1;
  }
}
`
(5,18): error CS0019: Operator '+' cannot be applied to operands of type 'decimal' and 'float'
`
struct pointer{
  uint val;
  static public implicit operator pointer(uint i) {pointer f = new pointer(); f.val = i; return f;}
  static public implicit operator uint(pointer x) {return x.val;}
  public static bool operator == (pointer x, pointer y){return x.val == y.val;}
  public static bool operator != (pointer x, pointer y){return x.val != y.val;}
  public override bool Equals(object x){return false;}
  public override int GetHashCode(){return 0;}
  public static int Main(){
    pointer f = new pointer();
    if (f == 0) return 0;
    return 1;
  }
}
`
`
using System;

[AttributeUsage(AttributeTargets.Method)]
public class NiftyAttribute: Attribute
{
    public NiftyAttribute(int i) {}
}

public class SwiftyAttribute: NiftyAttribute
{
    public SwiftyAttribute(int i): base(i) {}
}

class X
{
    [Swifty(4)]  // Should be legal.
    public static int Main()
    {return 1;}

    [Swifty(4)]
    public static int i;  // Should get failure here that attribute isn't valid on fields.

}
`
(20,6): error CS0592: Attribute 'Swifty' is not valid on this declaration type. It is valid on 'method' declarations only.
`
using System;
using System.Collections;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
public class Author  : Attribute
{
    string author;
  public Author(string value)
      {
      author = value;
      }
  public string Value { get {return author;} }
}

[Author("Brian Kernighan"), Author("Dennis Ritchie"),] 
class Class1
    {
    }
public class MainClass
    {
    public static int Main ()
        {
     //   Class1 c1 = new Class1();
      object[] attrs = typeof(Class1).GetCustomAttributes(false);
      SortedList authors = new SortedList();
    for (int i = 0; i < attrs.Length; i++)
        {
        if (string.Equals(attrs[i].ToString(), typeof(Author).ToString()))
            {
            authors.Add(((Author)attrs[i]).Value, ((Author)attrs[i]).Value);
            }
      }
    IEnumerator ie = authors.GetEnumerator ();
    while (ie.MoveNext())
        {
        Console.WriteLine (((DictionaryEntry)ie.Current).Value);
        }

        return 0;
        }
    }
`
Brian Kernighan
Dennis Ritchie
`
using System;
using System.Reflection;


[AttributeUsage(AttributeTargets.Method)]
public class MyAttribute : Attribute
{
  public Type TypeObject;
  public Type[] Types;

  public Type[] T
  {
    get{ return Types;}
    set{ Types = value;}
  }
} // class MyAttribute

[AttributeUsage(AttributeTargets.All,AllowMultiple=true)]
public class MyAttribute2 : MyAttribute
{
  public Type TT;
}

[MyAttribute2(
   TypeObject = typeof(int),
   Types = new Type[]{typeof(void), typeof(void)},
   T = new Type[]{typeof(byte), typeof(object)},
   TT = typeof(MyAttribute))
]
public enum elong : ulong{}


[MyAttribute2(
   TypeObject = typeof(int),
   Types = new Type[]{typeof(void), typeof(System.Byte)},
   T = new Type[]{typeof(byte), typeof(object)},
   TT = typeof(MyAttribute))
]
public class Test
{
  [method:MyAttribute2(
        TypeObject = typeof(int),
        T = new Type[]{typeof(byte), typeof(object)},
        Types = new Type[]{typeof(void), typeof(System.IntPtr)},
        TT = typeof(MyAttribute))
  ]
  [MyAttribute(
     TypeObject = typeof(elong),
     Types = new Type[]{typeof(elong), typeof(ulong)},
     T = new Type[]{typeof(sbyte), typeof(System.Object)})
  ]
  public void foo([MyAttribute2(
             TypeObject = typeof(System.String),
             Types = new Type[]{typeof(System.Byte), typeof(System.ValueType)},
             T = new Type[]{typeof(Type), typeof(Attribute)},
             TT = typeof(MyAttribute))
    ]int i)
  {
  }

  [MyAttribute(
     TypeObject = typeof(string),
     Types = new Type[]{typeof(string), typeof(void)},
     T = new Type[]{typeof(string), typeof(void)})
  ]
  public static int Main(String[] args)
  {
    Object[] attrs = typeof(Test).GetMethod("Main", BindingFlags.Public | BindingFlags.Static).GetCustomAttributes(false);
    if(((MyAttribute)attrs[0]).Types[0] != typeof(string))
      return 1;
    
    attrs = typeof(Test).GetCustomAttributes(false);
    if(((MyAttribute2)attrs[0]).Types[0] != typeof(byte))
      return 1;

    if(((MyAttribute2)attrs[0]).TT != typeof(MyAttribute))
      return 1;
  
    attrs = typeof(Test).GetMethod("foo").GetCustomAttributes(false);
    
    if(attrs == null)
      return 1;

    if(((MyAttribute)attrs[0]).Types[0] != typeof(void))
      return 1;

    if(((MyAttribute)attrs[1]).Types[0] != typeof(sbyte))
      return 1;

    return 0;
  }
}
`
`
using System;

[Derived.Foo]
[Derived.FooAttribute]
[Base.FooAttribute]
[Base.Foo]
public class X
{  
  static int Main()
  {
    if(typeof(X).GetCustomAttributes(typeof(Derived.FooAttribute),false).Length == 4)
      return 0;
    else
      return 1;
  }
}

public class Derived : Base {}

public class Base
{
  [AttributeUsage(AttributeTargets.Class,AllowMultiple=true)]
    public class FooAttribute : Attribute {}
}
`
`
using System;

[AttributeUsage(System.AttributeTargets.All,AllowMultiple=true,Inherited=true)]
class MyAtt : Attribute
{  
}

[AttributeUsage(System.AttributeTargets.All,AllowMultiple=true,Inherited=true)]
class Att : Attribute
{
  public Att()
  {
    Console.WriteLine("Att");
  }

  public Att(params int[] i)
  {
    foreach(int ii in i)
      Console.WriteLine(ii);
  }

  public Att([MyAtt]params object[] i)
  {
    foreach(object ii in i)
      Console.WriteLine(ii);
  }
}

[Att()]
[Att(1,2,3,4,5)]
class A
{
  public void boo([param:Att] params int[] i)
  {

  }
  public void too([Att] params string[] s)
  {

  }

  public void foo([param:Att][Att()] params string[] s)
  {

  }

  public void foo([param:Att][Att(1,2,3,4,5)] string[] s,[param:Att][Att()] params string[] ss)
  {

  }
  
  public static int Main()
  {
    A a = new A();
    a.foo("1","3","4");
    a.foo("1");
    
    return 0;
  }

}
`
`
using System;

[AttributeUsage(AttributeTargets.All)]
public class MyAtt  
{}

class Test
{
  public static int Main()
  {
    return 1;
  }
}
`
(3,2): error CS0641: 'AttributeUsage' : attribute is only valid on classes derived from System.Attribute
`
using System;

class MyAtt : Attribute
{
  public delegate void D();
  public D d;
}

[MyAtt(d = null)]
class Test
{
  public static int Main()
  {
    return 1;
  }
}
`
(9,8): error CS0655: 'MyAtt.d' may not be initialized in an attribute argument list because its type is not a valid attribute parameter type.
(6,12): (Location of symbol related to previous error)
`
using System;

public enum E{}

[E]
public class Test
{
  public static int Main()
  {
    return 1;
  }
}
`
(5,2): error CS0616: 'E': is not an attribute class
(3,13): (Location of symbol related to previous error)
`
using System;

public abstract class A : Attribute
{}

[A]
public class Test
{
  public static int Main()
  {
    return 1;
  }
}
`
(6,2): error CS0653: Cannot apply attribute class 'A' because it is abstract
`
using System;
[AttributeUsage(AttributeTargets.All)]
public class X : Attribute
{
}


[AttributeUsage(AttributeTargets.All)]
public class XAttributeAttribute : Attribute
{
}

[XAttribute]      // Refers to XAttribute
class Class2 
{
}

[@X]            // Refers to X
class Class3
{
}

[@XAttribute]      // Refers to XAttribute
class Class4
{
}

public class Test
{
  public static int Main()
  {
    return 1;
  }
}
`
(23,2): error CS0246: The type or namespace name 'XAttribute' could not be found (are you missing a using directive or an assembly reference?)
`
using System;
using System.Reflection;

[AttributeUsage(AttributeTargets.All)]
public class MyAttribute : Attribute
{
  public Type TypeObject;
  public Type[] Types;

  public Type[] T
  {
    get{ return Types;}
    set{ Types = value;}
  }
} // class MyAttribute

[MyAttribute(T = new Type[]{new MyAttribute().GetType()})]
public class Test
{
  [MyAttribute(T = new Type[]{ string.GetType()})]
  public Test()
  {
  }

  [method:MyAttribute( TypeObject = new int[1].GetType())]
  public void foo()
  {
  }
  
  public static int Main()
  {
    return 1;  
  }
}
`
(17,18): error CS0182: An attribute argument must be a constant expression, typeof expression or array creation expression
(20,32): error CS0120: An object reference is required for the nonstatic field, method, or property 'object.GetType()'
(20,20): error CS0182: An attribute argument must be a constant expression, typeof expression or array creation expression
(25,37): error CS0182: An attribute argument must be a constant expression, typeof expression or array creation expression
`
using System;
using System.Reflection;
using System.Runtime.InteropServices;

[ComImport, Guid("acf36ecb-8a7c-4a04-8987-cb7afbcc4e1f")]
public interface IComInterface
{
  int Foo([In, Optional] object param1);
}

public class MainClass {
    public static int Main() {
        int retval = 1;
        
        Type t = typeof(IComInterface);
        ParameterInfo[] pia = t.GetMethod("Foo").GetParameters();
        if ((pia[0].Attributes & ParameterAttributes.Optional) != 0)
            retval -= 1;

        if (0 == retval) Console.WriteLine ("PASS");
        else Console.WriteLine ("FAIL");

        return retval;
    }
}
`
PASS
`
using System;
using System.Runtime.InteropServices;

[ComAliasName("Alias")]
public class MainClass
{
  [method:ComAliasName("Alias")]
  public static int m1 ()
    {
      return 1;
    }
  [ComAliasName("Alias")]
  public static int Main ()
    {
      return 1;
    }
}
`
(4,2): error CS0592: Attribute 'ComAliasName' is not valid on this declaration type. It is valid on 'field, param, property, return' declarations only.
(7,11): error CS0592: Attribute 'ComAliasName' is not valid on this declaration type. It is valid on 'field, param, property, return' declarations only.
(12,4): error CS0592: Attribute 'ComAliasName' is not valid on this declaration type. It is valid on 'field, param, property, return' declarations only.
`
public class Test
{
  class hAttribute : System.Attribute
  {
    public hAttribute(int a)
    {
      b=a;
    }
    private static int b;
    public static int c
    {
      get{return b;}
      set{}
    }
  }

  [h(1,c=2)]class CT // error
  {
  } 

  public static int Main()
  {
    return 1;
  }
}
`
(17,8): error CS0617: 'c' is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static or const, or read-write properties which are not static.
(10,23): (Location of symbol related to previous error)
`
using System;
using System.Reflection;

[assembly: AssemblyKeyFile(@"bug.xss")]

public class Test{
  
  public static void Main(string[] args){
    Console.WriteLine("Hello");
  }
}
`
Hello
`
using System;

public struct ValX0 {}
public struct ValY0 {}
public struct ValX1<T> {}
public struct ValY1<T> {}
public struct ValX2<T,U> {}
public struct ValY2<T,U>{}
public struct ValX3<T,U,V>{}
public struct ValY3<T,U,V>{}
public class RefX0 {}
public class RefY0 {}
public class RefX1<T> {}
public class RefY1<T> {}
public class RefX2<T,U> {}
public class RefY2<T,U>{}
public class RefX3<T,U,V>{}
public class RefY3<T,U,V>{}


public class Gen<T>
{
  public void InstVerify(System.Type t1)
  {
    Test.Eval(typeof(T).Equals(t1));
  }
}

public class Test
{
  public static int counter = 0;
  public static bool result = true;
  public static void Eval(bool exp)
  {
    counter++;
    if (!exp)
    {
      result = exp;
      Console.WriteLine("Test Failed at location: " + counter);
    }
  
  }
  
  public static int Main()
  {
    new Gen<int>().InstVerify(typeof(int));
    new Gen<double>().InstVerify(typeof(double));
    new Gen<string>().InstVerify(typeof(string));
    new Gen<object>().InstVerify(typeof(object));
    new Gen<Guid>().InstVerify(typeof(Guid));

    new Gen<int[]>().InstVerify(typeof(int[]));
    new Gen<double[,]>().InstVerify(typeof(double[,]));
    new Gen<string[][][]>().InstVerify(typeof(string[][][]));
    new Gen<object[,,,]>().InstVerify(typeof(object[,,,]));
    new Gen<Guid[][,,,][]>().InstVerify(typeof(Guid[][,,,][]));

    new Gen<RefX1<int>[]>().InstVerify(typeof(RefX1<int>[]));
    new Gen<RefX1<double>[,]>().InstVerify(typeof(RefX1<double>[,]));
    new Gen<RefX1<string>[][][]>().InstVerify(typeof(RefX1<string>[][][]));
    new Gen<RefX1<object>[,,,]>().InstVerify(typeof(RefX1<object>[,,,]));
    new Gen<RefX1<Guid>[][,,,][]>().InstVerify(typeof(RefX1<Guid>[][,,,][]));

    new Gen<RefX2<int,int>[]>().InstVerify(typeof(RefX2<int,int>[]));
    new Gen<RefX2<double,double>[,]>().InstVerify(typeof(RefX2<double,double>[,]));
    new Gen<RefX2<string,string>[][][]>().InstVerify(typeof(RefX2<string,string>[][][]));
    new Gen<RefX2<object,object>[,,,]>().InstVerify(typeof(RefX2<object,object>[,,,]));
    new Gen<RefX2<Guid,Guid>[][,,,][]>().InstVerify(typeof(RefX2<Guid,Guid>[][,,,][]));

    new Gen<ValX1<int>[]>().InstVerify(typeof(ValX1<int>[]));
    new Gen<ValX1<double>[,]>().InstVerify(typeof(ValX1<double>[,]));
    new Gen<ValX1<string>[][][]>().InstVerify(typeof(ValX1<string>[][][]));
    new Gen<ValX1<object>[,,,]>().InstVerify(typeof(ValX1<object>[,,,]));
    new Gen<ValX1<Guid>[][,,,][]>().InstVerify(typeof(ValX1<Guid>[][,,,][]));

    new Gen<ValX2<int,int>[]>().InstVerify(typeof(ValX2<int,int>[]));
    new Gen<ValX2<double,double>[,]>().InstVerify(typeof(ValX2<double,double>[,]));
    new Gen<ValX2<string,string>[][][]>().InstVerify(typeof(ValX2<string,string>[][][]));
    new Gen<ValX2<object,object>[,,,]>().InstVerify(typeof(ValX2<object,object>[,,,]));
    new Gen<ValX2<Guid,Guid>[][,,,][]>().InstVerify(typeof(ValX2<Guid,Guid>[][,,,][]));
    
    new Gen<RefX1<int>>().InstVerify(typeof(RefX1<int>));
    new Gen<RefX1<ValX1<int>>>().InstVerify(typeof(RefX1<ValX1<int>>));
    new Gen<RefX2<int,string>>().InstVerify(typeof(RefX2<int,string>));
    new Gen<RefX3<int,string,Guid>>().InstVerify(typeof(RefX3<int,string,Guid>));

    new Gen<RefX1<RefX1<int>>>().InstVerify(typeof(RefX1<RefX1<int>>));
    new Gen<RefX1<RefX1<RefX1<string>>>>().InstVerify(typeof(RefX1<RefX1<RefX1<string>>>));
    new Gen<RefX1<RefX1<RefX1<RefX1<Guid>>>>>().InstVerify(typeof(RefX1<RefX1<RefX1<RefX1<Guid>>>>));

    new Gen<RefX1<RefX2<int,string>>>().InstVerify(typeof(RefX1<RefX2<int,string>>));
    new Gen<RefX2<RefX2<RefX1<int>,RefX3<int,string, RefX1<RefX2<int,string>>>>,RefX2<RefX1<int>,RefX3<int,string, RefX1<RefX2<int,string>>>>>>().InstVerify(typeof(RefX2<RefX2<RefX1<int>,RefX3<int,string, RefX1<RefX2<int,string>>>>,RefX2<RefX1<int>,RefX3<int,string, RefX1<RefX2<int,string>>>>>));
    new Gen<RefX3<RefX1<int[][,,,]>,RefX2<object[,,,][][],Guid[][][]>,RefX3<double[,,,,,,,,,,],Guid[][][][,,,,][,,,,][][][],string[][][][][][][][][][][]>>>().InstVerify(typeof(RefX3<RefX1<int[][,,,]>,RefX2<object[,,,][][],Guid[][][]>,RefX3<double[,,,,,,,,,,],Guid[][][][,,,,][,,,,][][][],string[][][][][][][][][][][]>>));

    new Gen<ValX1<int>>().InstVerify(typeof(ValX1<int>));
    new Gen<ValX1<RefX1<int>>>().InstVerify(typeof(ValX1<RefX1<int>>));
    new Gen<ValX2<int,string>>().InstVerify(typeof(ValX2<int,string>));
    new Gen<ValX3<int,string,Guid>>().InstVerify(typeof(ValX3<int,string,Guid>));

    new Gen<ValX1<ValX1<int>>>().InstVerify(typeof(ValX1<ValX1<int>>));
    new Gen<ValX1<ValX1<ValX1<string>>>>().InstVerify(typeof(ValX1<ValX1<ValX1<string>>>));
    new Gen<ValX1<ValX1<ValX1<ValX1<Guid>>>>>().InstVerify(typeof(ValX1<ValX1<ValX1<ValX1<Guid>>>>));

    new Gen<ValX1<ValX2<int,string>>>().InstVerify(typeof(ValX1<ValX2<int,string>>));
    new Gen<ValX2<ValX2<ValX1<int>,ValX3<int,string, ValX1<ValX2<int,string>>>>,ValX2<ValX1<int>,ValX3<int,string, ValX1<ValX2<int,string>>>>>>().InstVerify(typeof(ValX2<ValX2<ValX1<int>,ValX3<int,string, ValX1<ValX2<int,string>>>>,ValX2<ValX1<int>,ValX3<int,string, ValX1<ValX2<int,string>>>>>));
    new Gen<ValX3<ValX1<int[][,,,]>,ValX2<object[,,,][][],Guid[][][]>,ValX3<double[,,,,,,,,,,],Guid[][][][,,,,][,,,,][][][],string[][][][][][][][][][][]>>>().InstVerify(typeof(ValX3<ValX1<int[][,,,]>,ValX2<object[,,,][][],Guid[][][]>,ValX3<double[,,,,,,,,,,],Guid[][][][,,,,][,,,,][][][],string[][][][][][][][][][][]>>));
    
    if (result)
    {
      return 0;
    }
    else
    {
      return 1;
    }
  }
    
}
`
`
using System;

public struct ValX0 {}
public struct ValY0 {}
public struct ValX1<T> {}
public struct ValY1<T> {}
public struct ValX2<T,U> {}
public struct ValY2<T,U>{}
public struct ValX3<T,U,V>{}
public struct ValY3<T,U,V>{}
public class RefX0 {}
public class RefY0 {}
public class RefX1<T> {}
public class RefY1<T> {}
public class RefX2<T,U> {}
public class RefY2<T,U>{}
public class RefX3<T,U,V>{}
public class RefY3<T,U,V>{}


public class GenBase<T>
{
  public T Fld1;
  
  public GenBase(T fld1)
  {
    Fld1 =  fld1;
  }

  public bool InstVerify(System.Type t1)
  {
    bool result = true;

    if (!(Fld1.GetType().Equals(t1)))
    {  
      result = false;
      Console.WriteLine("Failed to verify type of Fld1 in: " + typeof(GenBase<T>) );
    }
    
    return result;
  }
}
  
public class GenInt : GenBase<int>
{  
  public GenInt() : base(1) {}

  public bool InstVerify()
  {
    return base.InstVerify(typeof(int));  
  }
}

public class GenDouble: GenBase<double>
{  
  public GenDouble() : base(1) {}

  public bool InstVerify()
  {
    return base.InstVerify(typeof(double));  
  }
}

public class GenString : GenBase<String>
{  
  public GenString() : base("string") {}

  public bool InstVerify()
  {
    return base.InstVerify(typeof(string));  
  }
}

public class GenObject : GenBase<object>
{  
  public GenObject() : base(new object()) {}

  public bool InstVerify()
  {
    return base.InstVerify(typeof(object));  
  }
}

public class GenGuid : GenBase<Guid>
{  
  public GenGuid() : base(new Guid()) {}

  public bool InstVerify()
  {
    return base.InstVerify(typeof(Guid));  
  }
}

public class GenConstructedReference : GenBase<RefX1<int>>
{  
  public GenConstructedReference() : base(new RefX1<int>()) {}

  public bool InstVerify()
  {
    return base.InstVerify(typeof(RefX1<int>));  
  }
}

public class GenConstructedValue: GenBase<ValX1<string>>
{  
  public GenConstructedValue() : base(new ValX1<string>()) {}

  public bool InstVerify()
  {
    return base.InstVerify(typeof(ValX1<string>));  
  }
}


public class GenInt1DArray : GenBase<int[]>
{  
  public GenInt1DArray() : base(new int[1]) {}

  public bool InstVerify()
  {
    return base.InstVerify(typeof(int[]));  
  }
}

public class GenString2DArray : GenBase<string[,]>
{  
  public GenString2DArray() : base(new string[1,1]) {}

  public bool InstVerify()
  {
    return base.InstVerify(typeof(string[,]));  
  }
}

public class GenIntJaggedArray : GenBase<int[][]>
{  
  public GenIntJaggedArray() : base(new int[1][]) {}

  public bool InstVerify()
  {
    return base.InstVerify(typeof(int[][]));  
  }
}


public class Test
{
  public static int counter = 0;
  public static bool result = true;
  public static void Eval(bool exp)
  {
    counter++;
    if (!exp)
    {
      result = exp;
      Console.WriteLine("Test Failed at location: " + counter);
    }
  
  }
  
  public static int Main()
  {
    Eval(new GenInt().InstVerify());
    Eval(new GenDouble().InstVerify());
    Eval(new GenString().InstVerify());
    Eval(new GenObject().InstVerify());
    Eval(new GenGuid().InstVerify());
    Eval(new GenConstructedReference().InstVerify());
    Eval(new GenConstructedValue().InstVerify());
    Eval(new GenInt1DArray().InstVerify());
    Eval(new GenString2DArray().InstVerify());
    Eval(new GenIntJaggedArray().InstVerify());
    
    if (result)
    {
      Console.WriteLine("Test Passed");
      return 0;
    }
    else
    {
      Console.WriteLine("Test Failed");
      return 1;
    }
  }
    
}
`
Test Passed
`
using System;

public class C{}

public struct S 
{
  public C c;
  
  public S(C c)
  {
    this.c = c;
  }

  public static explicit operator S(C c)
  {
    return new S(c);
  }
}

public class Test
{
    
  public static int Main()
  {
    S s = (S)null;
    return ((s.c == null) ? 0 : 1);
  }
}
`
`
using System;

public struct ValX0 {}
public struct ValY0 {}
public struct ValX1<T> {}
public struct ValY1<T> {}
public struct ValX2<T,U> {}
public struct ValY2<T,U>{}
public struct ValX3<T,U,V>{}
public struct ValY3<T,U,V>{}
public class RefX0 {}
public class RefY0 {}
public class RefX1<T> {}
public class RefY1<T> {}
public class RefX2<T,U> {}
public class RefY2<T,U>{}
public class RefX3<T,U,V>{}
public class RefY3<T,U,V>{}


public class GenBase<T>
{
  public T Fld1;
  
  public GenBase(T fld1)
  {
    Fld1 =  fld1;
  }

  public bool InstVerify(System.Type t1)
  {
    bool result = true;

    if (!(Fld1.GetType().Equals(t1)))
    {  
      result = false;
      Console.WriteLine("Failed to verify type of Fld1 in: " + typeof(GenBase<T>) );
    }
    
    return result;
  }
}
  
public class Gen<T> : GenBase<T>
{  
  public Gen(T fld1) : base(fld1) {}

  new public bool InstVerify(System.Type t1)
  {
    return base.InstVerify(t1);  
  }
}

public class Test
{
  public static int counter = 0;
  public static bool result = true;
  public static void Eval(bool exp)
  {
    counter++;
    if (!exp)
    {
      result = exp;
      Console.WriteLine("Test Failed at location: " + counter);
    }
  
  }
  
  public static int Main()
  {
    Eval((new Gen<int>(new int())).InstVerify(typeof(int)));   
    Eval((new Gen<double>(new double())).InstVerify(typeof(double))); 
    Eval((new Gen<string>("string")).InstVerify(typeof(string)));
    Eval((new Gen<object>(new object())).InstVerify(typeof(object))); 
    Eval((new Gen<Guid>(new Guid())).InstVerify(typeof(Guid))); 

    Eval((new Gen<int[]>(new int[1])).InstVerify(typeof(int[]))); 
    Eval((new Gen<double[,]>(new double[1,1])).InstVerify(typeof(double[,])));
    Eval((new Gen<string[][][]>(new string[1][][])).InstVerify(typeof(string[][][]))); 
    Eval((new Gen<object[,,,]>(new object[1,1,1,1])).InstVerify(typeof(object[,,,])));
    Eval((new Gen<Guid[][,,,][]>(new Guid[1][,,,][])).InstVerify(typeof(Guid[][,,,][])));

    Eval((new Gen<RefX1<int>[]>(new RefX1<int>[]{})).InstVerify(typeof(RefX1<int>[]))); 
    Eval((new Gen<RefX1<double>[,]>(new RefX1<double>[1,1])).InstVerify(typeof(RefX1<double>[,])));
    Eval((new Gen<RefX1<string>[][][]>(new RefX1<string>[1][][])).InstVerify(typeof(RefX1<string>[][][]))); 
    Eval((new Gen<RefX1<object>[,,,]>(new RefX1<object>[1,1,1,1])).InstVerify(typeof(RefX1<object>[,,,])));
    Eval((new Gen<RefX1<Guid>[][,,,][]>(new RefX1<Guid>[1][,,,][])).InstVerify(typeof(RefX1<Guid>[][,,,][])));

    Eval((new Gen<RefX2<int,int>[]>(new RefX2<int,int>[]{})).InstVerify(typeof(RefX2<int,int>[]))); 
    Eval((new Gen<RefX2<double,double>[,]>(new RefX2<double,double>[1,1])).InstVerify(typeof(RefX2<double,double>[,])));
    Eval((new Gen<RefX2<string,string>[][][]>(new RefX2<string,string>[1][][])).InstVerify(typeof(RefX2<string,string>[][][]))); 
    Eval((new Gen<RefX2<object,object>[,,,]>(new RefX2<object,object>[1,1,1,1])).InstVerify(typeof(RefX2<object,object>[,,,])));
    Eval((new Gen<RefX2<Guid,Guid>[][,,,][]>(new RefX2<Guid,Guid>[1][,,,][])).InstVerify(typeof(RefX2<Guid,Guid>[][,,,][])));

    Eval((new Gen<ValX1<int>[]>(new ValX1<int>[]{})).InstVerify(typeof(ValX1<int>[]))); 
    Eval((new Gen<ValX1<double>[,]>(new ValX1<double>[1,1])).InstVerify(typeof(ValX1<double>[,])));
    Eval((new Gen<ValX1<string>[][][]>(new ValX1<string>[1][][])).InstVerify(typeof(ValX1<string>[][][]))); 
    Eval((new Gen<ValX1<object>[,,,]>(new ValX1<object>[1,1,1,1])).InstVerify(typeof(ValX1<object>[,,,])));
    Eval((new Gen<ValX1<Guid>[][,,,][]>(new ValX1<Guid>[1][,,,][])).InstVerify(typeof(ValX1<Guid>[][,,,][])));

    Eval((new Gen<ValX2<int,int>[]>(new ValX2<int,int>[]{})).InstVerify(typeof(ValX2<int,int>[]))); 
    Eval((new Gen<ValX2<double,double>[,]>(new ValX2<double,double>[1,1])).InstVerify(typeof(ValX2<double,double>[,])));
    Eval((new Gen<ValX2<string,string>[][][]>(new ValX2<string,string>[1][][])).InstVerify(typeof(ValX2<string,string>[][][]))); 
    Eval((new Gen<ValX2<object,object>[,,,]>(new ValX2<object,object>[1,1,1,1])).InstVerify(typeof(ValX2<object,object>[,,,])));

    Eval((new Gen<ValX2<Guid,Guid>[][,,,][]>(new ValX2<Guid,Guid>[1][,,,][])).InstVerify(typeof(ValX2<Guid,Guid>[][,,,][])));
    
    Eval((new Gen<RefX1<int>>(new RefX1<int>())).InstVerify(typeof(RefX1<int>)));
    Eval((new Gen<RefX1<ValX1<int>>>(new RefX1<ValX1<int>>())).InstVerify(typeof(RefX1<ValX1<int>>)));
    Eval((new Gen<RefX2<int,string>>(new RefX2<int,string>())).InstVerify(typeof(RefX2<int,string>)));
    Eval((new Gen<RefX3<int,string,Guid>>(new RefX3<int,string,Guid>())).InstVerify(typeof(RefX3<int,string,Guid>)));

    Eval((new Gen<RefX1<RefX1<int>>>(new RefX1<RefX1<int>>())).InstVerify(typeof(RefX1<RefX1<int>>)));
    Eval((new Gen<RefX1<RefX1<RefX1<string>>>>(new RefX1<RefX1<RefX1<string>>>())).InstVerify(typeof(RefX1<RefX1<RefX1<string>>>)));
    Eval((new Gen<RefX1<RefX1<RefX1<RefX1<Guid>>>>>(new RefX1<RefX1<RefX1<RefX1<Guid>>>>())).InstVerify(typeof(RefX1<RefX1<RefX1<RefX1<Guid>>>>)));

    Eval((new Gen<RefX1<RefX2<int,string>>>(new RefX1<RefX2<int,string>>())).InstVerify(typeof(RefX1<RefX2<int,string>>)));
    Eval((new Gen<RefX2<RefX2<RefX1<int>,RefX3<int,string, RefX1<RefX2<int,string>>>>,RefX2<RefX1<int>,RefX3<int,string, RefX1<RefX2<int,string>>>>>>(new RefX2<RefX2<RefX1<int>,RefX3<int,string, RefX1<RefX2<int,string>>>>,RefX2<RefX1<int>,RefX3<int,string, RefX1<RefX2<int,string>>>>>())).InstVerify(typeof(RefX2<RefX2<RefX1<int>,RefX3<int,string, RefX1<RefX2<int,string>>>>,RefX2<RefX1<int>,RefX3<int,string, RefX1<RefX2<int,string>>>>>)));
    Eval((new Gen<RefX3<RefX1<int[][,,,]>,RefX2<object[,,,][][],Guid[][][]>,RefX3<double[,,,,,,,,,,],Guid[][][][,,,,][,,,,][][][],string[][][][][][][][][][][]>>>(new RefX3<RefX1<int[][,,,]>,RefX2<object[,,,][][],Guid[][][]>,RefX3<double[,,,,,,,,,,],Guid[][][][,,,,][,,,,][][][],string[][][][][][][][][][][]>>())).InstVerify(typeof(RefX3<RefX1<int[][,,,]>,RefX2<object[,,,][][],Guid[][][]>,RefX3<double[,,,,,,,,,,],Guid[][][][,,,,][,,,,][][][],string[][][][][][][][][][][]>>)));

    Eval((new Gen<ValX1<int>>(new ValX1<int>())).InstVerify(typeof(ValX1<int>)));
    Eval((new Gen<ValX1<RefX1<int>>>(new ValX1<RefX1<int>>())).InstVerify(typeof(ValX1<RefX1<int>>)));
    Eval((new Gen<ValX2<int,string>>(new ValX2<int,string>())).InstVerify(typeof(ValX2<int,string>)));
    Eval((new Gen<ValX3<int,string,Guid>>(new ValX3<int,string,Guid>())).InstVerify(typeof(ValX3<int,string,Guid>)));

    Eval((new Gen<ValX1<ValX1<int>>>(new ValX1<ValX1<int>>())).InstVerify(typeof(ValX1<ValX1<int>>)));
    Eval((new Gen<ValX1<ValX1<ValX1<string>>>>(new ValX1<ValX1<ValX1<string>>>())).InstVerify(typeof(ValX1<ValX1<ValX1<string>>>)));
    Eval((new Gen<ValX1<ValX1<ValX1<ValX1<Guid>>>>>(new ValX1<ValX1<ValX1<ValX1<Guid>>>>())).InstVerify(typeof(ValX1<ValX1<ValX1<ValX1<Guid>>>>)));

    Eval((new Gen<ValX1<ValX2<int,string>>>(new ValX1<ValX2<int,string>>())).InstVerify(typeof(ValX1<ValX2<int,string>>)));
    Eval((new Gen<ValX2<ValX2<ValX1<int>,ValX3<int,string, ValX1<ValX2<int,string>>>>,ValX2<ValX1<int>,ValX3<int,string, ValX1<ValX2<int,string>>>>>>(new ValX2<ValX2<ValX1<int>,ValX3<int,string, ValX1<ValX2<int,string>>>>,ValX2<ValX1<int>,ValX3<int,string, ValX1<ValX2<int,string>>>>>())).InstVerify(typeof(ValX2<ValX2<ValX1<int>,ValX3<int,string, ValX1<ValX2<int,string>>>>,ValX2<ValX1<int>,ValX3<int,string, ValX1<ValX2<int,string>>>>>)));
    Eval((new Gen<ValX3<ValX1<int[][,,,]>,ValX2<object[,,,][][],Guid[][][]>,ValX3<double[,,,,,,,,,,],Guid[][][][,,,,][,,,,][][][],string[][][][][][][][][][][]>>>(new ValX3<ValX1<int[][,,,]>,ValX2<object[,,,][][],Guid[][][]>,ValX3<double[,,,,,,,,,,],Guid[][][][,,,,][,,,,][][][],string[][][][][][][][][][][]>>())).InstVerify(typeof(ValX3<ValX1<int[][,,,]>,ValX2<object[,,,][][],Guid[][][]>,ValX3<double[,,,,,,,,,,],Guid[][][][,,,,][,,,,][][][],string[][][][][][][][][][][]>>)));
    


    if (result)
    {
      Console.WriteLine("Test Passed");
      return 0;
    }
    else
    {
      Console.WriteLine("Test Failed");
      return 1;
    }
  }
    
}
`
Test Passed
`
using System;
using System.Threading;

delegate T GenDelegate<T> (T p1, out T p2);

class Foo 
{
  public int Function(int i, out int j)
  {
    j = i;
    return i;
  }
    
}

class Test
{
  public static int Main()
  {
    int i,j; 
    Foo inst = new Foo();  
    GenDelegate<int> MyDelegate = new GenDelegate<int>(inst.Function);
    i  = MyDelegate(10,out j);

    if ((i != 10) || (j != 10))
    {
      Console.WriteLine("Failed Sync Invokation");
      return 1;
    }
    
    IAsyncResult ar = MyDelegate.BeginInvoke(20, out j,null,null);
    WaitHandle.WaitAll(new System.Threading.WaitHandle[] { ar.AsyncWaitHandle });
    i = MyDelegate.EndInvoke(out j,ar);

    if ((i != 20) || (j != 20))
    {
      Console.WriteLine("Failed Async Invokation");
      return 1;
    }

    Console.WriteLine("Test Passes");
    return 0;
    
  }
}
`
Test Passes
`
using System;
using System.Threading;

delegate T GenDelegate<T> (T p1, out T p2);

class Foo 
{
  public T Function<T>(T i, out T j)
  {
    j = i;
    return i;
  }
    
}

class Test
{
  public static int Main()
  {
    int i,j; 
    Foo inst = new Foo();  
    GenDelegate<int> MyDelegate = new GenDelegate<int>(inst.Function<int>);
    i  = MyDelegate(10,out j);

    if ((i != 10) || (j != 10))
    {
      Console.WriteLine("Failed Sync Invokation");
      return 1;
    }
    
    IAsyncResult ar = MyDelegate.BeginInvoke(20, out j,null,null);
    WaitHandle.WaitAll(new System.Threading.WaitHandle[] { ar.AsyncWaitHandle });
    i = MyDelegate.EndInvoke(out j,ar);

    if ((i != 20) || (j != 20))
    {
      Console.WriteLine("Failed Async Invokation");
      return 1;
    }

    Console.WriteLine("Test Passes");
    return 0;
    
  }
}
`
Test Passes
`
using System;
using System.Threading;

delegate T GenDelegate<T> (T p1, out T p2);

class Foo<T> 
{
  public T Function<U>(U i, out U j)
  {
    j = i;
    return (T)(Object)i;
  }
    
}

class Test
{
  public static int Main()
  {
    int i,j; 
    Foo<int> inst = new Foo<int>();  
    GenDelegate<int> MyDelegate = new GenDelegate<int>(inst.Function<int>);
    i  = MyDelegate(10,out j);

    if ((i != 10) || (j != 10))
    {
      Console.WriteLine("Failed Sync Invokation");
      return 1;
    }
    
    IAsyncResult ar = MyDelegate.BeginInvoke(20, out j,null,null);
    WaitHandle.WaitAll(new System.Threading.WaitHandle[] { ar.AsyncWaitHandle });
    i = MyDelegate.EndInvoke(out j,ar);

    if ((i != 20) || (j != 20))
    {
      Console.WriteLine("Failed Async Invokation");
      return 1;
    }

    Console.WriteLine("Test Passes");
    return 0;
    
  }
}
`
Test Passes
`
using System;

public struct ValX0 {}
public struct ValY0 {}
public struct ValX1<T> {}
public struct ValY1<T> {}
public struct ValX2<T,U> {}
public struct ValY2<T,U>{}
public struct ValX3<T,U,V>{}
public struct ValY3<T,U,V>{}
public class RefX0 {}
public class RefY0 {}
public class RefX1<T> {}
public class RefY1<T> {}
public class RefX2<T,U> {}
public class RefY2<T,U>{}
public class RefX3<T,U,V>{}
public class RefY3<T,U,V>{}


public class Gen<T,U>
{

  public void InstVerify(System.Type t1, System.Type t2)
  {
    Test.Eval(typeof(T).Equals(t1) && typeof(U).Equals(t2));
  }
}

public class Test
{
  public static int counter = 0;
  public static bool result = true;
  public static void Eval(bool exp)
  {
    counter++;
    if (!exp)
    {
      result = exp;
      Console.WriteLine("Test Failed at location: " + counter);
    }
  
  }
  
  public static int Main()
  {
    new Gen<int,int>().InstVerify(typeof(int),typeof(int));   
    new Gen<int,double>().InstVerify(typeof(int),typeof(double)); 
    new Gen<int,string>().InstVerify(typeof(int),typeof(string));   
    new Gen<int,object>().InstVerify(typeof(int),typeof(object)); 
    new Gen<int,Guid>().InstVerify(typeof(int),typeof(Guid));
    new Gen<int,RefX1<int>>().InstVerify(typeof(int),typeof(RefX1<int>));
    new Gen<int,RefX1<string>>().InstVerify(typeof(int),typeof(RefX1<string>));
    new Gen<int,RefX1<int[][,,,][]>>().InstVerify(typeof(int),typeof(RefX1<int[][,,,][]>));
    new Gen<int,ValX1<int>>().InstVerify(typeof(int),typeof(ValX1<int>));
    new Gen<int,ValX1<string>>().InstVerify(typeof(int),typeof(ValX1<string>));
    new Gen<int,ValX1<int[][,,,][]>>().InstVerify(typeof(int),typeof(ValX1<int[][,,,][]>));
    
    new Gen<double,int>().InstVerify(typeof(double),typeof(int));   
    new Gen<double,double>().InstVerify(typeof(double),typeof(double)); 
    new Gen<double,string>().InstVerify(typeof(double),typeof(string));   
    new Gen<double,object>().InstVerify(typeof(double),typeof(object)); 
    new Gen<double,Guid>().InstVerify(typeof(double),typeof(Guid));
    new Gen<double,RefX1<double>>().InstVerify(typeof(double),typeof(RefX1<double>));
    new Gen<double,RefX1<string>>().InstVerify(typeof(double),typeof(RefX1<string>));
    new Gen<double,RefX1<double[][,,,][]>>().InstVerify(typeof(double),typeof(RefX1<double[][,,,][]>));
    new Gen<double,ValX1<double>>().InstVerify(typeof(double),typeof(ValX1<double>));
    new Gen<double,ValX1<string>>().InstVerify(typeof(double),typeof(ValX1<string>));
    new Gen<double,ValX1<double[][,,,][]>>().InstVerify(typeof(double),typeof(ValX1<double[][,,,][]>));

    new Gen<string,int>().InstVerify(typeof(string),typeof(int));   
    new Gen<string,double>().InstVerify(typeof(string),typeof(double)); 
    new Gen<string,string>().InstVerify(typeof(string),typeof(string));   
    new Gen<string,object>().InstVerify(typeof(string),typeof(object)); 
    new Gen<string,Guid>().InstVerify(typeof(string),typeof(Guid));
    new Gen<string,RefX1<string>>().InstVerify(typeof(string),typeof(RefX1<string>));
    new Gen<string,RefX1<string>>().InstVerify(typeof(string),typeof(RefX1<string>));
    new Gen<string,RefX1<string[][,,,][]>>().InstVerify(typeof(string),typeof(RefX1<string[][,,,][]>));
    new Gen<string,ValX1<string>>().InstVerify(typeof(string),typeof(ValX1<string>));
    new Gen<string,ValX1<string>>().InstVerify(typeof(string),typeof(ValX1<string>));
    new Gen<string,ValX1<string[][,,,][]>>().InstVerify(typeof(string),typeof(ValX1<string[][,,,][]>));

    new Gen<object,int>().InstVerify(typeof(object),typeof(int));   
    new Gen<object,double>().InstVerify(typeof(object),typeof(double)); 
    new Gen<object,string>().InstVerify(typeof(object),typeof(string));   
    new Gen<object,object>().InstVerify(typeof(object),typeof(object)); 
    new Gen<object,Guid>().InstVerify(typeof(object),typeof(Guid));
    new Gen<object,RefX1<object>>().InstVerify(typeof(object),typeof(RefX1<object>));
    new Gen<object,RefX1<string>>().InstVerify(typeof(object),typeof(RefX1<string>));
    new Gen<object,RefX1<object[][,,,][]>>().InstVerify(typeof(object),typeof(RefX1<object[][,,,][]>));
    new Gen<object,ValX1<object>>().InstVerify(typeof(object),typeof(ValX1<object>));
    new Gen<object,ValX1<string>>().InstVerify(typeof(object),typeof(ValX1<string>));
    new Gen<object,ValX1<object[][,,,][]>>().InstVerify(typeof(object),typeof(ValX1<object[][,,,][]>));

    new Gen<Guid,int>().InstVerify(typeof(Guid),typeof(int));   
    new Gen<Guid,double>().InstVerify(typeof(Guid),typeof(double)); 
    new Gen<Guid,string>().InstVerify(typeof(Guid),typeof(string));   
    new Gen<Guid,object>().InstVerify(typeof(Guid),typeof(object)); 
    new Gen<Guid,Guid>().InstVerify(typeof(Guid),typeof(Guid));
    new Gen<Guid,RefX1<Guid>>().InstVerify(typeof(Guid),typeof(RefX1<Guid>));
    new Gen<Guid,RefX1<string>>().InstVerify(typeof(Guid),typeof(RefX1<string>));
    new Gen<Guid,RefX1<Guid[][,,,][]>>().InstVerify(typeof(Guid),typeof(RefX1<Guid[][,,,][]>));
    new Gen<Guid,ValX1<Guid>>().InstVerify(typeof(Guid),typeof(ValX1<Guid>));
    new Gen<Guid,ValX1<string>>().InstVerify(typeof(Guid),typeof(ValX1<string>));
    new Gen<Guid,ValX1<Guid[][,,,][]>>().InstVerify(typeof(Guid),typeof(ValX1<Guid[][,,,][]>));

    new Gen<RefX1<int>,int>().InstVerify(typeof(RefX1<int>),typeof(int));   
    new Gen<RefX1<long>,double>().InstVerify(typeof(RefX1<long>),typeof(double)); 
    new Gen<RefX1<long>,string>().InstVerify(typeof(RefX1<long>),typeof(string));   
    new Gen<RefX1<long>,object>().InstVerify(typeof(RefX1<long>),typeof(object)); 
    new Gen<RefX1<long>,Guid>().InstVerify(typeof(RefX1<long>),typeof(Guid));
    new Gen<RefX1<long>,RefX1<RefX1<long>>>().InstVerify(typeof(RefX1<long>),typeof(RefX1<RefX1<long>>));
    new Gen<RefX1<long>,RefX1<string>>().InstVerify(typeof(RefX1<long>),typeof(RefX1<string>));
    new Gen<RefX1<long>,RefX1<RefX1<long[][,,,][]>>>().InstVerify(typeof(RefX1<long>),typeof(RefX1<RefX1<long[][,,,][]>>));
    new Gen<RefX1<long>,ValX1<RefX1<long>>>().InstVerify(typeof(RefX1<long>),typeof(ValX1<RefX1<long>>));
    new Gen<RefX1<long>,ValX1<string>>().InstVerify(typeof(RefX1<long>),typeof(ValX1<string>));
    new Gen<RefX1<long>,ValX1<RefX1<long>[][,,,][]>>().InstVerify(typeof(RefX1<long>),typeof(ValX1<RefX1<long>[][,,,][]>));

    new Gen<ValX1<string>,int>().InstVerify(typeof(ValX1<string>),typeof(int));   
    new Gen<ValX1<string>,double>().InstVerify(typeof(ValX1<string>),typeof(double)); 
    new Gen<ValX1<string>,string>().InstVerify(typeof(ValX1<string>),typeof(string));   
    new Gen<ValX1<string>,object>().InstVerify(typeof(ValX1<string>),typeof(object)); 
    new Gen<ValX1<string>,Guid>().InstVerify(typeof(ValX1<string>),typeof(Guid));
    new Gen<ValX1<string>,RefX1<ValX1<string>>>().InstVerify(typeof(ValX1<string>),typeof(RefX1<ValX1<string>>));
    new Gen<ValX1<string>,RefX1<string>>().InstVerify(typeof(ValX1<string>),typeof(RefX1<string>));
    new Gen<ValX1<string>,RefX1<ValX1<string>[][,,,][]>>().InstVerify(typeof(ValX1<string>),typeof(RefX1<ValX1<string>[][,,,][]>));
    new Gen<ValX1<string>,ValX1<ValX1<string>>>().InstVerify(typeof(ValX1<string>),typeof(ValX1<ValX1<string>>));
    new Gen<ValX1<string>,ValX1<string>>().InstVerify(typeof(ValX1<string>),typeof(ValX1<string>));
    new Gen<ValX1<string>,ValX1<ValX1<string>[][,,,][]>>().InstVerify(typeof(ValX1<string>),typeof(ValX1<ValX1<string>[][,,,][]>));

    if (result)
    {
      return 0;
    }
    else
    {
      return 1;
    }
  }
    
}
`
`
using System;
using System.Threading;

delegate T GenDelegate<T> (T p1, out T p2);

interface IFoo<T>
{
  T Function(T i, out T j);
}
  
class Foo<T> : IFoo<T>
{
  public T Function(T i, out T j)
  {
    j = i;
    return i;
  }
    
}

class Test
{
  public static int Main()
  {
    int i,j; 
    IFoo<int> inst = new Foo<int>();  
    GenDelegate<int> MyDelegate = new GenDelegate<int>(inst.Function);
    i  = MyDelegate(10,out j);

    if ((i != 10) || (j != 10))
    {
      Console.WriteLine("Failed Sync Invokation");
      return 1;
    }
    
    IAsyncResult ar = MyDelegate.BeginInvoke(20, out j,null,null);
    WaitHandle.WaitAll(new System.Threading.WaitHandle[] { ar.AsyncWaitHandle });
    i = MyDelegate.EndInvoke(out j,ar);

    if ((i != 20) || (j != 20))
    {
      Console.WriteLine("Failed Async Invokation");
      return 1;
    }

    Console.WriteLine("Test Passes");
    return 0;
    
  }
}
`
Test Passes
`
using System;

public class Test{
  public static void Main(string[] args){
    int i = 5;
    Test.foo(ref i);
    Console.WriteLine(i);
  }
  public static void foo(ref int i){
    i = -i;
  }
}
`
-5
`
namespace MyNS {
  class MyClass {

    public static void Main() {
      Sistem.Assert(false, "foo");
    }
  }
}
`
(5,7): error CS0246: The type or namespace name 'Sistem' could not be found (are you missing a using directive or an assembly reference?)
`
namespace MyNS {
  class MyClass {

    public static void Main() {
      System.Assert(false, "foo");
    }
  }
}
`
(5,7): error CS0234: The type or namespace name 'Assert' does not exist in the namespace 'System' (are you missing an assembly reference?)
`
namespace MyNS {
  class MyClass {

    public static void Main() {
      System.Diagnostics.Debug.Assert(false, "foo");
    }
  }
}
`
(5,26): error CS0234: The type or namespace name 'Debug' does not exist in the namespace 'System.Diagnostics' (are you missing an assembly reference?)
`
`/r:System.dll
namespace MyNS {
  class MyClass {

    public static void Main() {
      System.Diagnostics.Debug.Assert(false, "foo");
    }
  }
}
`
`
`/r:System.dll /d:DEBUG
namespace MyNS {
  class MyClass {

    public static void Main() {
      System.Diagnostics.Debug.Assert(false, "foo");
    }
  }
}
`
Fail: foo
`
using System;

  // two normal classes...
public class Res1: IDisposable
{
  public void Dispose()
  {
    Console.WriteLine("Res1.Dispose()");
  }
  public void Func()
  {
    Console.WriteLine("Res1.Func()");
  }
  public void Throw()
  {
    throw(new Exception("Res1"));
  }
}

public class Res2: IDisposable
{
  public void Dispose()
  {
    Console.WriteLine("Res2.Dispose()");
  }
  public void Func()
  {
    Console.WriteLine("Res2.Func()");
  }
  public void Throw()
  {
    throw(new Exception("Res2"));
  }
}

  // IDispose implemented explicitly
public class ResExplicit: IDisposable
{
  void IDisposable.Dispose()
  {
    Console.WriteLine("ResExplicit.Dispose()");
  }
  public void Func()
  {
    Console.WriteLine("ResExplicit.Func()");
  }
  public void Throw()
  {
    throw(new Exception("ResExplicit"));
  }
}

  // A class that doesn't implement IDisposable.
public class NonRes1
{
  public void GarbageDisposal()
  {
    Console.WriteLine("NonRes1.GarbageDisposal()");
  }
  public void Func()
  {
    Console.WriteLine("NonRes1.Func()");
  }
  public void Throw()
  {
    throw(new Exception("NonRes1"));
  }
}

  // Doesn't implement IDisposable, but has a Dispose() function...
public class NonRes2
{
  public void Dispose()
  {
    Console.WriteLine("NonRes2.Dispose()");
  }
  public void Func()
  {
    Console.WriteLine("NonRes2.Func()");
  }
  public void Throw()
  {
    throw(new Exception("NonRes2"));
  }
}

public class Test
{
    public static void Main()
    {
      using (Res1 res1)
      {
        res1.Func();
      }
    }
}
`
(91,19): error CS0210: You must provide an initializer in a fixed or using statement declaration
`
interface first 
{
    first() {}  
    
}

class main 
{
  public static void Main() {}
}
`
(3,5): error CS0526: Interfaces cannot contain constructors
`
using System;

interface test 
{
  static int this [ int ident1 ] { get; set; }
}

class main
{
  public static void Main() {}
}
`
(5,14): error CS0106: The modifier 'static' is not valid for this item
`
using System;

interface test 
{
  static int testMethod();
}

class main
{
  public static void Main() {}
}
`
(5,14): error CS0106: The modifier 'static' is not valid for this item
`
public delegate void MyEvent(object sender);

interface test 
{
  static event MyEvent Click;
}

class main
{
  public static void Main() {}
}
`
(5,24): error CS0106: The modifier 'static' is not valid for this item
`
class A{int aa; public A(int i){}}
 
class X:A{
  int a, b;
  X(int i): base(a)                        // base is not allowed to use a.
  {}
  static void Main() {    
  }  
}
`
(5,18): error CS0120: An object reference is required for the nonstatic field, method, or property 'X.a'
`
class A{int aa; public A(int i){}}
 
class X:A{
  int a, b;
  X(int i): base(this.a)                        // base is not allowed to use a.
  {}
  static void Main() {    
  }  
}
`
(5,18): error CS0027: Keyword this is not available in the current context
`
class A{int aa; public A(int i){}}
 
class X:A{
  int a, b;
  X(int i): base(base.aa)
  {}
  static void Main() {    
  }  
}
`
(5,18): error CS1512: Keyword base is not available in the current context
`
using System;

public class Test{
  void Foo<Bar>(){}
  void Foo2<Bar>(){}
 
  public static void Main(string[] args){
  }    
}
`
`
using System;

public class Test{
  static void foo<T>(){
    object ob = default(T);
    Console.WriteLine(ob == null ? "null" : ob.GetType().ToString());
  }
  public static void Main(string[] args){
    Console.WriteLine(default(TypeCode));
    Console.WriteLine(default(string));
    foo<int>();
    foo<string>();
    Console.WriteLine(default(double));
  }    
}
`
Empty

System.Int32
null
0
`
using System;

namespace foo{
  class x{}
}
namespace foo.bar{
  class x{}
}

namespace foo.bar.bas{
  
  public class Test{
    public static void Main(string[] args){
      Console.WriteLine(typeof(x));
    }
      
  }
}
`
foo.bar.x
`
using System;

namespace foo{
  class x{}
}
namespace foo.bar{
  class x{}
}

namespace foo.bar.bas{
  using foo;

  public class Test{
    public static void Main(string[] args){
      Console.WriteLine(typeof(x));
    }
      
  }
}
`
foo.x
`
using System;

namespace MyNS {
  class MyClass {

    public static void Main() {
      IDisposable disp = null;
      using (IDisposable foo = disp){
      }
      using (IDisposable foo = disp){
      }
    }
  }
}
`
`
using System;

public class Test{
  public static void Main(string[] args){
    int i = 0;
    while (i++ < 1)
      Console.WriteLine("Hello");
  }
    
}
`
Hello
`
namespace foo{
  using System;
  using StringBuilder = System.Text.StringBuilder;

  public class Test{
    public static void Main(string[] args){
      StringBuilder sb = new StringBuilder("Hello");
      Console.WriteLine(sb);
    }      
  }
}
`
Hello
`
namespace foo.bar{
  public class one{}
}
namespace foo.kroeg{
  using System;
  
  public class Test{
    public static void Main(string[] args){
      Console.WriteLine(typeof(bar.one));
    }
      
  }
}
`
foo.bar.one
`
using System;

public class Test{
  static void Foo<T>(T t, T t2){
    Console.WriteLine(typeof(T));
  }
  public static void Main(string[] args){
    Test.Foo("bar", 1);
  }    
}
`
(8,5): error CS0411: The type arguments for method 'Test.Foo<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
`
using System;
using System.Threading;

delegate T GenDelegate<T> (T p1, out T p2);

class Foo<T> 
{
  static public T Function(T i, out T j)
  {
    j = i;
    return i;
  }
    
}

class Test
{
  public static int Main()
  {
    int i,j; 
    GenDelegate<int> MyDelegate = new GenDelegate<int>(Foo<int>.Function);
    i  = MyDelegate(10,out j);

    if ((i != 10) || (j != 10))
    {
      Console.WriteLine("Failed Sync Invokation");
      return 1;
    }
    
    IAsyncResult ar = MyDelegate.BeginInvoke(20, out j,null,null);
    WaitHandle.WaitAll(new System.Threading.WaitHandle[] { ar.AsyncWaitHandle });
    i = MyDelegate.EndInvoke(out j,ar);

    if ((i != 20) || (j != 20))
    {
      Console.WriteLine("Failed Async Invokation");
      return 1;
    }

    Console.WriteLine("Test Passes");
    return 0;
    
  }
}
`
Test Passes
`
using System;
using System.Threading;

delegate T GenDelegate<T> (T p1, out T p2);

class NotFoo{
  static public int Function(int i, out int j)
  {
    j = i;
    return i;
  }
}
class Foo<T> 
{
  static public T Function(T i, out T j)
  {
    j = i;
    return i;
  }
    
}

class Test
{
  public static int Main()
  {
    int i,j; 
    GenDelegate<int> MyDelegate = new GenDelegate<int>(NotFoo<int>.Function);
    i  = MyDelegate(10,out j);

    if ((i != 10) || (j != 10))
    {
      Console.WriteLine("Failed Sync Invokation");
      return 1;
    }
    
    IAsyncResult ar = MyDelegate.BeginInvoke(20, out j,null,null);
    WaitHandle.WaitAll(new System.Threading.WaitHandle[] { ar.AsyncWaitHandle });
    i = MyDelegate.EndInvoke(out j,ar);

    if ((i != 20) || (j != 20))
    {
      Console.WriteLine("Failed Async Invokation");
      return 1;
    }

    Console.WriteLine("Test Passes");
    return 0;
    
  }
}
`
(28,56): error CS0308: The non-generic type 'NotFoo' cannot be used with type arguments
(6,7): (Location of symbol related to previous error)
`
using System;

class Gen<T>{
}

public class Test{
  public static void Main(string[] args){
    Console.WriteLine(default(Gen<int>) == null);
  }
    
}
`
True
`
delegate void foo();

public class Test{
  public static void Main(string[] args){
    Test.bar += (foo)null;
  }
  
  static void meth(){}

  static event foo bar{
    add{
    }
    remove{
    }
  }  
}
`
`
using System;

public class Test : bar{
  public static void Main(string[] args){
  }
  void t(){
    ev += (foo)null;
    ev -= (foo)null;
  }
}
public delegate void foo();
public class bar{
  public event foo ev;
  void x(){ev();}
}
`
`
using System;

public class Test : bar{
  public static void Main(string[] args){
  }
  void t(){
    Test.ev += (foo)null;
    Test.ev -= (foo)null;
  }
}
public delegate void foo();
public class bar{
  protected static event foo ev;
  void x(){ev();}
}
`
`
using System;

public class Gen<T>{
  protected class Nested{}
}

public class Test : Gen<int>{
  public static void Main(string[] args){
    Gen<int>.Nested foo = default(Nested); args.Equals(foo);
  }   
}
`
`
using System;

public class Gen<T>{
  private int foo;
  private int bar(){
    Gen<int> gi = null;
    gi.foo = 1;
    int x = gi.foo; return x;
  }
}

public class Test : Gen<int>{
  public static void Main(string[] args){
  }   
}
`
`
using System;

public class Gen{
  public void foo(){
    del1 del = delegate (int y){object ob = y;};
  }
}

public class Test{
  public static void Main(string[] args){
    //Gen<int> foo = null;
  } 
}
delegate int del1(int z);
`
(5,16): error CS1662: Cannot convert anonymous method block to delegate type 'del1' because some of the return types in the block are not implicitly convertible to the delegate return type
`
using System;

public class Gen{
  public void foo(){
    del1 del = delegate (long y){object ob = y;};
  }
}

public class Test{
  public static void Main(string[] args){
    //Gen<int> foo = null;
  } 
}
delegate void del1(int z);
`
(5,16): error CS1661: Cannot convert anonymous method block to delegate type 'del1' because the specified block's parameter types do not match the delegate parameter types
`
using System;

public class Test{
  public static void Main(string[] args){
    uint stateStack = 0x10;
    int counter = 3;
    stateStack |= ((uint)counter)&0xF;
    Console.WriteLine(stateStack);
  }
}
`
19
`
using System;

public class Test{
  public static void Main(string[] args){
    loop: int i = 1;
    Console.WriteLine(i);
    if (i != 1 && i == 1) goto loop;
  }
}
`
1
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
    if (true)
Label:    return(0);

        return(1);
    }
}
`
(8,1): error CS1023: Embedded statement cannot be a declaration or labeled statement
(8,1): warning CS0164: This label has not been referenced
`
using System;

public class Test{
  public static void Main(string[] args){
    foo fum = 0;
    switch (fum){
      case foo.bar: break;
    }
    fum = foo.bar;
  }
}

public enum foo{
  bar = 1
}
`
`
using System;

public class Test{
  public static void Main(string[] args){
    foo bar = new foo();
    fee fum = new fee();
    fum |= bar;    
  }
}

public enum foo{
  bar = 1
}

public struct fee{
  public static fee operator |(fee ts, foo t){
    Console.WriteLine("success");
    return new fee();
  }
  public static fee operator |(fee ts1, fee ts2){
    Console.WriteLine("failure");
    return new fee();
  }
}
`
success
`
using System;

public class Test{
  public static void Main(string[] args){
    int i = int.Parse("123", null);
    Console.WriteLine(i);
  }
    
}
`
123
`
using System;

public interface ifoo{
  void bar();
}

public class Test : ifoo{
  void ifoo.bar(){Console.WriteLine("bug!");}
  
  public static void Main(string[] args){
    Test t = new Test();
    t.bar();
  }
    
}
`
(12,7): error CS0117: 'Test' does not contain a definition for 'bar'
`
using System;

public interface ifoo{
  void bar();
}

public class Test : ifoo{
  void ifoo.bar(){Console.WriteLine("bug!");}
  
  void foo(){
    bar();
  }
  
  public static void Main(string[] args){
    Test t = new Test();
    t.foo();
  }
    
}
`
(11,5): error CS0103: The name 'bar' does not exist in the current context
`
using System;

public class Comments
{
  public static void Main(String[] args) {}
  */
}
`
(6,3): error CS1519: Invalid token '*/' in class, struct, or interface member declaration
`
using System;

public delegate void SuperFunc(params int[] numbers);

public class MyClass {
  public void Test(params int[] numbers) {
    Console.WriteLine ("Called with "+numbers.Length.ToString()+" args");
  }
}

public class App {
  public static void Main()   {
    MyClass cls = new MyClass();
    SuperFunc f1 = new SuperFunc(cls.Test);

    f1();
    f1(1);
    f1(1,2);
    f1(1,2,3);
  }
}
`
Called with 0 args
Called with 1 args
Called with 2 args
Called with 3 args
`
using System;

public class MyClass {
  public static void Main(string[] args){
    bool b;
    if (args == null){
      b = false;
    }else{
      if (args.Length == 0){
        Console.WriteLine("args.Length == 0");
      }else{
        Console.WriteLine("args.Length != 0");
      }
      b = true;
    }
    Console.WriteLine(b);
  }
}
`
args.Length == 0
True
`
using System;

struct foo{
  int i;
  public int this[int j]{
    get{return this.i+j;}
    set{this.i = j+value;}
  }
}

public class MyClass {
  public static void Main(string[] args){
    foo fee = new foo();
    fee[1] = 2;
    Console.WriteLine(fee[1]);
  }
}
`
4
`
using System;
namespace N {
 
  interface I { int f(int x); }
  interface J { int f(int x); }
  class C : I, J {
    int I.f(int x) { return x; }
  }
}
`
(6,9): error CS0535: 'N.C' does not implement interface member 'N.J.f(int)'
(5,21): (Location of symbol related to previous error)
`
using System;
namespace N {
 
  interface I { int f(int x); }
  class C : I{
    float f(int x) { return x; }
  }
}
`
(5,9): error CS0536: 'N.C' does not implement interface member 'N.I.f(int)'. 'N.C.f(int)' is either static, not public, or has the wrong return type.
(4,21): (Location of symbol related to previous error)
(6,11): (Location of symbol related to previous error)
`
using System;
namespace N {
 
  interface I { int f{get; set;} }
  class C : I {
    public int g{ get { return 1; }}
  }
}
`
(5,9): error CS0535: 'N.C' does not implement interface member 'N.I.f.get'
(4,23): (Location of symbol related to previous error)
(5,9): error CS0535: 'N.C' does not implement interface member 'N.I.f.set'
(4,28): (Location of symbol related to previous error)
`
#if BLAH
 #if FOO
 using System.IO;
 #else 
 using System.IO;
 #endif
#else
 #if FOO
 using System.IO;
 #else 
 using System.IO;
 #endif
#endif
public class Test{
  public static void Main(){
  }
}
`
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
  int i = 2;

#if false
#error false is true?
#elif true
  i--;
#else
#error Else shouldn't trigger here
#endif

#if false
#error false is still true?
#elif foobar
#error foobar wasn't supposed to be defined
#else
  i--;
#endif

  return(i > 0 ? 1 : 0);
    }
}
`
`
using System;

public class Test{
  public static void Main(string[] args){
    ulong foo = 1;
    Console.WriteLine(foo & 0x1);
  }
    
}
`
1
`
using System;

public class Test{
  public static void Main(string[] args){
    bool isAlive1 = true;
    bool isAlive2 = false;
    isAlive2 |= isAlive1;
    Console.WriteLine(isAlive2);
  }    
}
`
True
`
using System;

public class Test{
  public static void Main(string[] args){
    bool found = true;
    int n = 0;
    for (int j = 0; !found && j < n; j++) {}
  }    
}
`
`
using System;
 
public class Static
{
 public static string DoSomething(){ return "foo";}
}
 
public class Test
{
 Static m_static = new Static();
 public Static Static { get { return m_static; } }
 
 static void Main() 
 {
   string test = Static.DoSomething();
   Console.WriteLine(test);
 }
}
`
foo
`
using System;

public delegate void del();
public class Test{
  public event del ev{
    add{Console.WriteLine("add");}
    remove{}
  }
  public void test(){
    ev += (del)null;
  }
  public static void Main(string[] args){
    new Test().test();
  }
    
}
`
add
`
using System;

public delegate void del();
public class Test{
  public static event del ev{
    add{Console.WriteLine("add");}
    remove{}
  }
  public void test(){
    ev += (del)null;
  }
  public static void Main(string[] args){
    new Test().test();
  }
    
}
`
add
`
using System;

public delegate void del();
public class Base{
  public event del ev;
}
public class Test : Base{
  public void test(){
    ev += (del)null;
  }
  public static void Main(string[] args){
    new Test().test();
  }
    
}
`
`
using System;

public class Gen<T>{
  public void test(){
    try{
      Console.WriteLine("trying");
      throw new NullReferenceException();
    }catch(NullReferenceException){
      Console.WriteLine("and succeeding");
    }
  }
}
public class Test{
  public static void Main(string[] args){
    try{
      new Gen<int>().test();
    }catch(NullReferenceException){
      Console.WriteLine("but not hard enough it seems");
    }
  }    
}
`
trying
and succeeding
`
using System;

public delegate Type del();
public class Base<T>{
  public del getdel(){
    del foo = delegate(){return typeof(T);};
    return foo;
  }
}
public class Gen<T> : Base<T>{
  public void test(){
    del d = this.getdel();
    Console.WriteLine(d());
  }
}
public class Test{
  public static void Main(string[] args){
    new Gen<int>().test();
  }    
}
`
System.Int32
`
using System;

public class Gen<T>{
  public void foo(params T[] args){
    Console.WriteLine(args.Length);
    Console.WriteLine(args[0]);
  }
  public void test(T t){
    this.foo(t);
  }
}
public class Test{
  public static void Main(string[] args){
    new Gen<int>().test(2);
  }    
}
`
1
2
`
using System;

public delegate T GenDlg<T>(T t);
public class GC1<T>
{
  public object foo() 
  { 
    object bar = typeof(GC1<T>); return bar;
  }
}
public class GenericClass<T>
{
  GenDlg<GC1<T>> Foo;
}
public class SpecializedSubGenericClassGC1T<T> : GenericClass<GC1<T>>
{
}
public class Test
{
  public static void Main()
  {
  }
}
`
`
using System;
using System.Threading;

public delegate T D<T>(T t);
  
public class GenInt<T>
{  
  public static event D<int> Ev = new D<int>(OnEv<int>);

  public static U OnEv<U>(U u) { return u; } 

  public static void SyncFireEv(int t)
  {
    Test.Eval(t.Equals(Ev(t)));
  }

  public static void AsyncFireEv(int t)
  {
    IAsyncResult ar = Ev.BeginInvoke(t,null,null);
    WaitHandle.WaitAll(new System.Threading.WaitHandle[] { ar.AsyncWaitHandle });
    Test.Eval(t.Equals(Ev.EndInvoke(ar)));
  }

}

public class GenString<T>
{  
  public static event D<string> Ev = new D<string>(OnEv<string>);

  public static U OnEv<U>(U u) { return u; }

  public static void SyncFireEv(string t)
  {
    Test.Eval(t.Equals(Ev(t)));
  }

  public static void AsyncFireEv(string t)
  {
    IAsyncResult ar = Ev.BeginInvoke(t,null,null);
    WaitHandle.WaitAll(new System.Threading.WaitHandle[] { ar.AsyncWaitHandle });
    Test.Eval(t.Equals(Ev.EndInvoke(ar)));
  }

}

public class GenGuid<T>
{  
  public static event D<Guid> Ev = new D<Guid>(OnEv<Guid>);

  public static U OnEv<U>(U u) { return u; }

  public static void SyncFireEv(Guid t)
  {
    Test.Eval(t.Equals(Ev(t)));
  }

  public static void AsyncFireEv(Guid t)
  {
    IAsyncResult ar = Ev.BeginInvoke(t,null,null);
    WaitHandle.WaitAll(new System.Threading.WaitHandle[] { ar.AsyncWaitHandle });
    Test.Eval(t.Equals(Ev.EndInvoke(ar)));
  }

}
    
public class Test
{
  public static int counter = 0;
  public static bool result = true;
  public static void Eval(bool exp)
  {
    counter++;
    if (!exp)
    {
      result = exp;
      Console.WriteLine("Test Failed at location: " + counter);
    }
  
  }
  
  public static int Main()
  {
    GenInt<int>.SyncFireEv(1);
    GenInt<int>.AsyncFireEv(2);

    GenString<string>.SyncFireEv("1");
    GenString<string>.AsyncFireEv("2");

    GenGuid<Guid>.SyncFireEv(new Guid(1,2,3,4,5,6,7,8,9,10,11));
    GenGuid<Guid>.AsyncFireEv(new Guid(1,2,3,4,5,6,7,8,9,10,0));
    
              if (result)
              {
      return 0;
    }
    else
    {
      return 1;
    }
  }
}
`
`
using System;
using System.Collections.Generic;

class C{
  public static int Minimum(IEnumerable<int> vs) { return 0; }
  public static IComparable Minimum(IEnumerable<IComparable> vs) { return null; }
}

class Test{
  public static void Main(){
    IEnumerable<int> foo = null;
    C.Mininum<IEnumerable<int>>(foo);
  }
}
`
(12,7): error CS0117: 'C' does not contain a definition for 'Mininum'
`
using System;
public class Test{
  public static void Main(string[] args){
    int i = 1, j = 2;
    Console.WriteLine(foo(ref i, ref j));
  }
  public static bool foo(ref int i, ref int j){
    return i < j;
  }
    
}
`
True
`
class C {

    public enum Flags : uint
    {
        KEY_UP              = 0x40000000,
    }

    private static void SetModifier(uint data)
    {
      if ((data & (uint)Flags.KEY_UP) != 0) {
        System.Console.WriteLine("pass");
      }
    }
    
    public static void Main(){
      C.SetModifier(0x40000000);
    }
}
`
pass
`
class C {
 
  public enum Flags : uint {
    KEY_UP              = 0x40000000,
    KEY_EXTENDED        = 0x00000080,
  }
 
  private static void SetModifier(uint data) {
      switch ((data & ~(uint)Flags.KEY_UP)) {
        case (uint)Flags.KEY_EXTENDED | 0x14:     // Right Control
          System.Console.WriteLine("pass");
          break;  
        default: break;
      }
  }
    public static void Main(){
      C.SetModifier(0x00000094);
    }
}
`
pass
`
class C {

  private class Nested<T> {

    internal void M(Nested<T> x) { }

  }
  public static void Main(){
    Nested<int> ni = new Nested<int>();
    ni.M(ni);
  }
}
`
`
public class MyContract{

  public struct ParamState<T> {
      public void Epsilon(ParamState<T> x) { } 
  }

  public static void Main() {
    ParamState<int> x = new ParamState<int>();     
    x.Epsilon(x);
  }
}
`
`
class C {
  public static int f(params object[] xs) { return 1; }
  public static int f(int xs) { return 2; }
}

class D { 
  public static void Main(){
    System.Console.WriteLine(C.f());
  }
}
`
1
`
public class T {

  static void M(uint type) {
    System.Console.WriteLine((type & 0x20000000)==0);
  }
  public static void Main(){
    T.M(1);
  }
   
}
`
True
`
class T {
  public static void Main(){
    byte bt = 0xff;
    bt ^= 0x00;
    System.Console.WriteLine(bt);
  }
}
`
255
`
using System;

public class T {

  public static void Main() {
    uint i = 1;
    uint [] bt_count = new uint[2];
    bt_count[i]++;
    System.Console.WriteLine(bt_count[i]);
  }
}
`
1
`
using System;

class MyClass {

  int intI;

  public int MyInt {
    set {
      intI = value;
    }

  }


  public static int Main() {

    MyClass MC1 = new MyClass();
    ++MC1.MyInt;
    return 1;
  }
}
`
(18,7): error CS0154: The property or indexer 'MyClass.MyInt' cannot be used in this context because it lacks the get accessor
`
using System;

class MyClass {

  int intI;

  public int MyInt {
    get {
      return intI;
    }
    set {
      intI = value;      
    }
  }


  public static int Main() {

    MyClass MC1 = new MyClass();
    MyClass MC2 = new MyClass();

    MC1.MyInt = 2;
    MC2.MyInt = 2;

    ++MC1.MyInt;
    --MC2.MyInt;

    if ((MC1.MyInt == 3) && (MC2.MyInt == 1)) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
class T {
  public static void Main(){
    byte bt = 0xff;
    bt &= 0x00;
    System.Console.WriteLine(bt);
  }
}
`
0
`
class T {

  public enum Settings : byte
  {
      // DMA MODE
      DemandMode          = 0x00,
      SingleMode          = 0x40,
      BlockMode           = 0x80,
      CascadeMode         = 0xC0,

      // ADDRESS INCREMENT DECREMENT
      AddressIncrement    = 0x00,
      AddresssDecrement   = 0x20,

      SingleCycle         = 0x00,
      AutoInit            = 0x10,

      // TRANSFER TYPE
      VerifyTransfer      = 0x00,
      WriteTransfer       = 0x04,
      ReadTransfer        = 0x08,
  }

  public static void Main() {
    System.Console.WriteLine(Settings.SingleMode |
            Settings.AddressIncrement |
            Settings.AutoInit);
  }
}
`
80
`
class T {

  private enum DspCommands : byte
  {
      BMODE_STEREO    = 0x20, // Stereo bit.
      BMODE_SIGNED    = 0x10, // Signed bit.
  }

  public static void Main() {
    bool stereo = true; bool signed = false;
    System.Console.WriteLine((byte)((stereo ? DspCommands.BMODE_STEREO : 0) |
                             (signed ? DspCommands.BMODE_SIGNED : 0)));
  }

}
`
32
`
using System;
 
class T {
  public static void Main() {
    uint b = 0xFFFFFFFF;
    int i = -1;
    if (i == b)
      Console.WriteLine("Fail");
    else
      Console.WriteLine("Pass");
  }
}
`
Pass
`
using System;
 
class T{
  public static void Main(){
    UIntPtr p = 0xa0000;
  }
}
`
(5,17): error CS0029: Cannot implicitly convert type 'int' to 'System.UIntPtr'
`
using System;
 
class T{
  public static void A(UIntPtr p){
  }
  public static void A(object p){
    Console.WriteLine("Pass");
  }
 
  public static void Main() {
    A(0xa0000);
  }
}
`
Pass
`
using System;

public class Test{
  public static void Main(string[] args){
    const byte b = 0x10;
    object foo = b >> 2;
    Console.WriteLine(foo);
    Console.WriteLine(foo.GetType());
  }
    
}
`
4
System.Int32
`
using System;

public class Test{
  public static void Main(string[] args){
    const uint b = 0x10;
    object foo = b >> 2;
    Console.WriteLine(foo);
    Console.WriteLine(foo.GetType());
  }
    
}
`
4
System.UInt32
`
using System;

namespace Tests{
  public class Driver{
    public static int Main(){
      int    var;
      int    var2;
      var = -2147483648;
      var2 = var;
      return var2<0?0:1;
    } 
  }
}
`
`
using System;

public class MyClass{

  public static int Main() {
  
    long lngL = 3 >> 2L;
    return 1;
  }
}
`
(7,17): error CS0019: Operator '>>' cannot be applied to operands of type 'int' and 'long'
`
class A
{
  public static int Main()
  {
      int[][] arr = new int[3][] {new int[] {6,7}, new int[] {8,9}, new int[] {10,11}};
    
        arr[1][1] = (long)45;

    return 0;
  }
}
`
(7,21): error CS0029: Cannot implicitly convert type 'long' to 'int'
`
using System;

class T {


        public static void DebugPrint(int i)
        {
          Console.WriteLine("Pass");
        }
        public static void DebugPrint(ulong l)
        {
          Console.WriteLine("Fail");
        }

}


class Test {

  public static void Main() {
    byte b = 0;
    T.DebugPrint(b); 
  }

}
`
Pass
`
class C {
  public override bool Equals(object obj) { return true; }
  public override int GetHashCode() { return 3; }
  public static bool operator == (C v1, C v2) { return true; }
  public static bool operator != (C v1, C v2) { return true; }
  void f(C c) { if (c != null) return; }
  public static void Main(){}
}
`
`
using System;
public class Base<T>{
  public class Nested{}
}
public class Test{
  public static void Main(string[] args){
    Base<int>.Nested n = new Base<int>.Nested();
    Console.WriteLine(n.GetType() == typeof(Base<int>.Nested));
  }    
}
`
True
`
using System;

class T {
 
  static void foo(string s, params object[] obs){
    Console.WriteLine("fail");
  }
  static void foo(string s, object ob){
    Console.WriteLine("pass");
  }
  public static void Main() {
    foo("bar", 5);
  }
}
`
pass
`
namespace foo{

class C<T> {
}

class B {
  C x;
  public static int Main(){
  }
}

}
`
(7,3): error CS0305: Using the generic type 'foo.C<T>' requires '1' type arguments
(3,7): (Location of symbol related to previous error)
`
class C<T> {

  D d;

  E<T> f;

  D<T> q;

  I i;

  J<T> j;
}



class D<T,S> {
}

public class E {
}

interface I<T> {
}

interface J { }
`
(3,3): error CS0305: Using the generic type 'D<T,S>' requires '2' type arguments
(16,7): (Location of symbol related to previous error)
(5,3): error CS0308: The non-generic type 'E' cannot be used with type arguments
(19,14): (Location of symbol related to previous error)
(7,3): error CS0305: Using the generic type 'D<T,S>' requires '2' type arguments
(16,7): (Location of symbol related to previous error)
(9,3): error CS0305: Using the generic type 'I<T>' requires '1' type arguments
(22,11): (Location of symbol related to previous error)
(11,3): error CS0308: The non-generic type 'J' cannot be used with type arguments
(25,11): (Location of symbol related to previous error)
`
using System;
using System.Reflection;


[assembly : A]
[foo: A]
[module:A]

[A]
public class foo 
{
  [method:A][foo:A]//[param:A]

  public static int Main() 
  {
    object[] o = Assembly.GetExecutingAssembly().GetCustomAttributes(typeof(A),false);
    if(o.Length != 1)
      return 1;
    
    o = typeof(foo).GetProperty ("Foo").GetCustomAttributes (typeof(A), false);
    if(o.Length != 1)
      return 1;

    o = typeof(foo).GetMethod ("Boo").GetCustomAttributes (typeof(A), false);
    if(o.Length != 1)
      return 1;

    return 0;
  }
  
    [foo:A]//[param:A]
  [property:A]
    public static int Foo
  {
        [method:A][foo:A]//[param:A]
        get { return 0; }
        [method:A][foo:A][param:A]
        set {}
  }

  [boo:A][method:A][foo:A][return:A][foo:A]
  public int Boo([param:A]int i)
  {
    return 1;
  }
}

[AttributeUsage(AttributeTargets.All,AllowMultiple=true)]
public class A : Attribute
{
}
`
(6,7): warning CS0658: 'foo' is not a recognized attribute location. All attributes in this block will be ignored.
(12,18): warning CS0658: 'foo' is not a recognized attribute location. All attributes in this block will be ignored.
(31,10): warning CS0658: 'foo' is not a recognized attribute location. All attributes in this block will be ignored.
(35,24): warning CS0658: 'foo' is not a recognized attribute location. All attributes in this block will be ignored.
(37,24): warning CS0658: 'foo' is not a recognized attribute location. All attributes in this block will be ignored.
(41,8): warning CS0658: 'boo' is not a recognized attribute location. All attributes in this block will be ignored.
(41,25): warning CS0658: 'foo' is not a recognized attribute location. All attributes in this block will be ignored.
(41,42): warning CS0658: 'foo' is not a recognized attribute location. All attributes in this block will be ignored.
`
`
using System;
[AttributeUsage(AttributeTargets.Method)]
public sealed class A : Attribute{}
class C{
  [A] void M(){}
  [return:A] void N(){}
  public static void Main(){}
}
`
(6,11): error CS0592: Attribute 'A' is not valid on this declaration type. It is valid on 'method' declarations only.
`
public class B { int x; }
class C : B { C() { x = 0; } }
`
(2,21): error CS0122: 'B.x' is inaccessible due to its protection level
(1,22): (Location of symbol related to previous error)
`
public class B { int x; }
class C : B { int y = x; }
`
(2,23): error CS0122: 'B.x' is inaccessible due to its protection level
(1,22): (Location of symbol related to previous error)
`
using System; 
class Test {
  static string Use2 (params object[] a){return string.Format("{0} {1} {2}", a);}
  static void Main() {
    Console.WriteLine(Use2("foo", "bar", "bas"));
  }
}
`
foo bar bas
`
using System;

public struct foo{
  public int bar;
  public foo(int b){
    this.bar = b;
  }
  public void bad(){
    this.bar = 5;
  }
}

public class Test{
  public static readonly foo f = new foo(1);
  public static void Main(){
    Console.WriteLine(Test.f.bar);
    Test.f.bad();
    Console.WriteLine(Test.f.bar);
  }
}
`
1
1
`
`
class Region {
}

interface IDo {
}

class Doer : IDo {}

class S {

  public static void MethodWithBaseConstraint<R>(R r) where R:Region
  {
  }

  public static void MethodWithIntfConstraint<P>(P r) where P:IDo
  {
  }

  public static void MethodWithoutConstraint<Q>(Q r) 
  {
    MethodWithBaseConstraint<Q>(r);

    MethodWithIntfConstraint<Q>(r);
    
  }

  public static void Test() {
    S.MethodWithBaseConstraint<int,int>(5);

    S.MethodWithIntfConstraint<int,int>(5);

    S.MethodWithBaseConstraint<int>(5);

    S.MethodWithIntfConstraint<int>(5);

    S.MethodWithBaseConstraint<Region>(new Region());

    S.MethodWithBaseConstraint(new Region());

    S.MethodWithIntfConstraint<IDo>(new Doer());

    S.MethodWithIntfConstraint(new Doer());
  }
}


class ClassWithBaseConstraint<R> where R : Region {
}

class ClassWithIntfConstraint<T> where T : IDo {
}


class TestMe {

  public void Foo<R>() {
    
    ClassWithBaseConstraint<R> r = new ClassWithBaseConstraint<R>();

    ClassWithIntfConstraint<R> r2 = new ClassWithIntfConstraint<R>();
  }

  public void Bar<S>() where S:Region
  {    
    ClassWithBaseConstraint<S> r = new ClassWithBaseConstraint<S>();
  }

  public void Baz<T>() where T:IDo
  {    
    ClassWithIntfConstraint<T> r = new ClassWithIntfConstraint<T>();
  }

  public static void Main() {

    ClassWithBaseConstraint<Region> tc = new ClassWithBaseConstraint<Region>();

    ClassWithBaseConstraint<int> bad = new ClassWithBaseConstraint<int>();

    ClassWithIntfConstraint<IDo> ic = new ClassWithIntfConstraint<IDo>();

    ClassWithIntfConstraint<int> bad2 = new ClassWithIntfConstraint<int>();
  }
}
`
(21,30): error CS0309: The type 'Q' must be convertible to 'Region' in order to use it as parameter 'R' in the generic type or method 'S.MethodWithBaseConstraint<R>(R)'
(23,30): error CS0309: The type 'Q' must be convertible to 'IDo' in order to use it as parameter 'P' in the generic type or method 'S.MethodWithIntfConstraint<P>(P)'
(28,5): error CS0305: Using the generic method 'S.MethodWithBaseConstraint<R>(R)' requires '1' type arguments
(30,5): error CS0305: Using the generic method 'S.MethodWithIntfConstraint<P>(P)' requires '1' type arguments
(32,32): error CS0309: The type 'int' must be convertible to 'Region' in order to use it as parameter 'R' in the generic type or method 'S.MethodWithBaseConstraint<R>(R)'
(34,32): error CS0309: The type 'int' must be convertible to 'IDo' in order to use it as parameter 'P' in the generic type or method 'S.MethodWithIntfConstraint<P>(P)'
(58,64): error CS0309: The type 'R' must be convertible to 'Region' in order to use it as parameter 'R' in the generic type or method 'ClassWithBaseConstraint<R>'
(60,65): error CS0309: The type 'R' must be convertible to 'IDo' in order to use it as parameter 'T' in the generic type or method 'ClassWithIntfConstraint<T>'
(77,68): error CS0309: The type 'int' must be convertible to 'Region' in order to use it as parameter 'R' in the generic type or method 'ClassWithBaseConstraint<R>'
(81,69): error CS0309: The type 'int' must be convertible to 'IDo' in order to use it as parameter 'T' in the generic type or method 'ClassWithIntfConstraint<T>'
`
public class Region {

  public void Dispose() {}
}

public interface IDo {

  void DoIt();
}

public class Gen<T> {}


class ClashTwoGenericMethodParameters {

  public static void M2<S>(S t) where S:IDo
  {    
    t.DoIt();     // should work
    t.Dispose();  // should not work
  }

  public static void M1<S>() where S:Region
  {
    Gen<S> r = new Gen<S>();
  }

  public static void Main() {}
}
`
(19,7): error CS0117: 'S' does not contain a definition for 'Dispose'
`
`
delegate void TestDelegate();

class Test{
  static void Main(){
    new TestDelegate(Foo)();
  }
  
  void Foo(){
  }
}
`
(5,22): error CS0120: An object reference is required for the nonstatic field, method, or property 'Test.Foo()'
`
using System;

public class Test{
  public static int Foo{
    get{
      Console.WriteLine("Hello");
      return 1;
    }
  }
  public static void Main(string[] args){
    Console.WriteLine(Test.Foo*0);
  }
}
`
Hello
0
`
public class T {
    private static volatile inPit = 0;
}
`
(2,35): error CS1519: Invalid token '=' in class, struct, or interface member declaration
(3,1): error CS1001: Identifier expected
(2,38): error CS1002: ; expected
(2,29): error CS0246: The type or namespace name 'inPit' could not be found (are you missing a using directive or an assembly reference?)
`
#define RTC_NO_GO
 
using System;
 
class T {
 
 
        private void WriteRtc(byte addr, byte val)
        {
#if TIMER_NO_GO
            return true;
#endif
        }
 
        public void Start() {
#if RTC_NO_GO
 
#else
            // A #else does not work here???
            //
            // I've added this random BAD_STATEMENT just to show the 
            //preprocessing is going through this branch.  
            BAD_STATEMENT;
#endif
        }
 
   public static void Main(){}
}
`
`
public class T {
  static S s;
    public static void Main() {
        s = (S)null;
    }
}
 
struct S {
}
`
(4,16): error CS0037: Cannot convert null to 'S' because it is a value type
`
namespace Microsoft.Singularity
{
    public class Tulip
    {
        // Mode Bits
        private const int  CSR0_PBL_ROLL = 8;      // Programmable burst len
        private const int  CSR0_DSL_ROLL = 2;       // Descriptor Skip len
 
        private static void Write(object value) {System.Console.WriteLine(value.GetType());}
 
        public static void Main()
        {
            uint cls = 5;
            Write(       (cls << CSR0_PBL_ROLL) |
                         ( 0 << CSR0_DSL_ROLL));
 
        }
    }
}
`
System.UInt32
`
using System;
 
class T {
 
    public static void Main() {
        UIntPtr[] a = new UIntPtr[1];
        a[0] = UIntPtr.Zero;
        UIntPtr p = a[0];
        Console.WriteLine(p);
    } 
}
`
0
`
using System;
 
enum Tag {
    Finalize,
}
 
class T {
 
    public static void Main() {
    }
 
}
`
`
public class T<K> {

    public class N<R> {
    }
    public struct S<Q> {
    }

    public static void F() {
        N<float> n = new N<float>();
        S<string> s = new S<string>();
        System.Console.WriteLine(n.GetType().Name[0]);
        System.Console.WriteLine(s.GetType().Name[0]);
    }
}
class Test{
  public static void Main(){
    T<Test>.F();
  }
}
`
N
S
`
class T {

    public static void Main() {
    }

    public void Test(int x) {
        switch(x) {
        case 0:
            x = 0;
        case 1:
        case 2:
            break;
        }
    }
}
`
(8,9): error CS0163: Control cannot fall through from this case label to another
`
class T {

    public static void Main() {
    }

    public void Test(int x) {
        switch(x) {
        case 0:
            break;
        case 1:
        }
    }
}
`
(10,9): error CS0163: Control cannot fall through from this case label to another
`
class T {

    public static void Main() {
    }

    public void Test(int x) {
        switch(x) {
        default:
            x = 0;
        case 1:
        case 2:
            break;
        }
    }
}
`
(8,9): error CS0163: Control cannot fall through from this case label to another
`
class T {

    public static void Main() {
    }

    public void Test(int x) {
        switch(x) {
        case 0:
            break;
        default:
        }
    }
}
`
(10,9): error CS0163: Control cannot fall through from this case label to another
`
using System;
using System.Collections;

class S : ISet {
    
    void ICollection.CopyTo(Array target, int index) {
    }

    public int Count { get { return 0; } }

    public object SyncRoot { get { return this; } }

    public bool IsSynchronized { get { return false; } }

    public IEnumerator GetEnumerator() { return null; }
    
    public static void Main(){}
}


interface ISet : ICollection {
}
`
`
class H {
    protected int hash = 1;

    public class HE {
        public HE(H h) {
            int x = h.hash;
            System.Console.WriteLine(x);
        }
    }
    
    public static void Main(){
      H h = new H();
      new HE(h);      
    }
}
`
1
`
interface I {
    void M();
}

public abstract class X : I {
}

public class Y : X, I {
}
`
(5,23): error CS0535: 'X' does not implement interface member 'I.M()'
(2,10): (Location of symbol related to previous error)
(8,14): error CS0535: 'Y' does not implement interface member 'I.M()'
(2,10): (Location of symbol related to previous error)
`
interface I {
    void M();
}

public abstract class X : I {
}

public class Y : X {
}
`
(5,23): error CS0535: 'X' does not implement interface member 'I.M()'
(2,10): (Location of symbol related to previous error)
`
public class ReturnValue
{
  public void M()
  {
    int m;
    m = a[0];
  }
}
`
(6,9): error CS0103: The name 'a' does not exist in the current context
`
using System;
 
class T {
  public static void Main() {
    bool x;
    int a, pcmLeft, samplesPerSec;
    lock {
        a = 0;
        pcmLeft = 0;
        samplesPerSec = 0;
        if (x){
        }
        else
        {
        }
    }
  }
}
`
(7,10): error CS1003: Syntax error, '(' expected
`
namespace A {

    interface I {
        void M();
    }
}

class T : A.I {

    void A.I.M() {
      System.Console.WriteLine("hello");
    }
    
    public static void Main(){
      A.I ai = new T();
      ai.M();
    }

}
`
hello
`
delegate void MyDelegate(object args);
class T{
    public static void Main(){
      MyDelegate myDel = (MyDelegate)delegate (object arg){};
    }
}
`
`
using System; 
class Class1
{
   public int Value = 0;
} 
class Test
{
   static void Main() {
      int val1 = 0;
      int val2 = val1;
      val2 = 123; 
      Class1 ref1 = new Class1();
      Class1 ref2 = ref1;
      ref2.Value = 123; 
      Console.WriteLine("Values: {0}, {1}", val1, val2);
      Console.WriteLine("Refs: {0}, {1}", ref1.Value, ref2.Value);
   }
}
`
Values: 0, 123
Refs: 123, 123
`
using System;
public class Test{
  public static void Main(string[] args){
    int i = args.Length;
    if (i = 0)  // Bug: the test should be (i == 0)
      Console.WriteLine("Oh dear");
  }
}
`
(5,9): error CS0029: Cannot implicitly convert type 'int' to 'bool'
`
using System;
class Test
{
   static void Main() {
      string s = "Test";
      string t = string.Copy(s);
      Console.WriteLine(s == t);
      Console.WriteLine((object)s == (object)t);
   }
}
`
True
False
`
using System;
class Test
{
   static void Main() {
      int intValue = 123;
      long longValue = intValue;
      Console.WriteLine("{0}, {1}", intValue, longValue);
   }
}
`
123, 123
`
using System;
class Test
{
   static void Main() {
      long longValue = Int64.MaxValue;
      int intValue = (int) longValue;
      Console.WriteLine("(int) {0} = {1}", longValue, intValue);
   }
}
`
(int) 9223372036854775807 = -1
`
using System; 
class Test
{
   static void Main() {
      int[] arr = new int[5]; 
      for (int i = 0; i < arr.Length; i++)
         arr[i] = i * i; 
      for (int i = 0; i < arr.Length; i++)
         Console.WriteLine("arr[{0}] = {1}", i, arr[i]);
   }
}
`
arr[0] = 0
arr[1] = 1
arr[2] = 4
arr[3] = 9
arr[4] = 16
`
class Test
{
   static void Main() {
      short[] a = {1, 2, 3};
      int[] b = {1, 2, 3};
      long[] c = {1, 2, 3}; 
   }
}
`
(4,15): warning CS0219: The variable 'a' is assigned but its value is never used
(5,13): warning CS0219: The variable 'b' is assigned but its value is never used
(6,14): warning CS0219: The variable 'c' is assigned but its value is never used
`
using System;
class Test
{
   static void Main() {
      Console.WriteLine(3.ToString());
   }
}
`
3
`
using System;
class Test {
   static void Swap(ref int a, ref int b) {
      int t = a;
      a = b;
      b = t;
   } 
   static void Main() {
      int x = 1;
      int y = 2;
      Console.WriteLine("pre:  x = {0}, y = {1}", x, y);
      Swap(ref x, ref y);
      Console.WriteLine("post: x = {0}, y = {1}", x, y);
   }
}
`
pre:  x = 1, y = 2
post: x = 2, y = 1
`
using System;
class Test
{
   static void F(params int[] args) {
      Console.WriteLine("# of arguments: {0}", args.Length);
      for (int i = 0; i < args.Length; i++)
         Console.WriteLine("  args[{0}] = {1}", i, args[i]);
   } 
   static void Main() {
      F();
      F(1);
      F(1, 2);
      F(1, 2, 3);
      F(new int[] {1, 2, 3, 4});
   }
}
`
# of arguments: 0
# of arguments: 1
  args[0] = 1
# of arguments: 2
  args[0] = 1
  args[1] = 2
# of arguments: 3
  args[0] = 1
  args[1] = 2
  args[2] = 3
# of arguments: 4
  args[0] = 1
  args[1] = 2
  args[2] = 3
  args[3] = 4
`
using System;
class Test{
  static void Main(string[] args) {
      if (args.Length == 0)
          goto done;
      Console.WriteLine(args.Length);

  done:
      Console.WriteLine("Done");
  }
}
`
Done
`
using System;
class Test{
  static void Main() {
      const float pi = 3.14f;
      const int r = 123;
      Console.WriteLine((pi * r * r).ToString(System.Globalization.CultureInfo.InvariantCulture));
  }
}
`
47505.06
`
:=a
using System;
class Test{
  static void Main(string[] args) {
      int i = 0;
      while (true) {
          if (i == args.Length)
              break;
          Console.WriteLine(args[i++]);
      }
  }
}
`
a
`
:=one =two
using System;
class Test{
  static void Main(string[] args) {
      int i = 0;
      while (true) {
        Console.WriteLine(args[i++]);
        if (i < args.Length)
              continue;
        break;
      }
  }
}
`
one
two
`
using System;
class Test{
  static int F(int a, int b) {
      if (b == 0)
          throw new Exception("Divide by zero");
      return a / b;
  }
  static void Main() {
      try {
          Console.WriteLine(F(5, 0));
      }
      catch(Exception e) {
          Console.WriteLine(e.Message);
      }
  }
}
`
Divide by zero
`
using System;
class Test{
  static void Main() {
      int x = Int32.MaxValue;
      Console.WriteLine(x + 1);      // Overflow
      checked {
        unchecked {
          Console.WriteLine(x + 1);  // Overflow
        }
        Console.WriteLine(x + 1);  // Exception
      }     
  }
}
`
-2147483648
-2147483648
Arithmetic operation resulted in an overflow.
`
using System;
class A{
int P = 0;
  static void Main() {
      A a = new A();
      lock(a) {
          a.P = a.P + 1;
      }
  }
}
`
`
using System;
class MyClass
{
   public MyClass() {
      Console.WriteLine("Instance constructor");
   } 
   public MyClass(int value) {
      MyField = value;
      Console.WriteLine("Instance constructor");
   } 
   ~MyClass() {
   } 
   public const int MyConst = 12; 
   public int MyField = 34; 
   public void MyMethod(){
      Console.WriteLine("MyClass.MyMethod");
   } 
   public int MyProperty {
      get {
         return MyField;
      } 
      set {
         MyField = value;
      }
   } 
   public int this[int index] {
      get {
         return 0;
      } 
      set {
         Console.WriteLine("this[{0}] = {1}", index, value);
      }
   } 
   public event EventHandler MyEvent; 
   public static MyClass operator+(MyClass a, MyClass b) {
      return new MyClass(a.MyField + b.MyField);
   } 
   internal class MyNestedClass
   {}
}
class Test
{
   static void Main() {
     // Instance constructor usage
      MyClass a = new MyClass();
      MyClass b = new MyClass(123); 
     // Constant usage
      Console.WriteLine("MyConst = {0}", MyClass.MyConst); 
     // Field usage
      a.MyField++;
      Console.WriteLine("a.MyField = {0}", a.MyField); 
     // Method usage
      a.MyMethod(); 
     // Property usage
      a.MyProperty++;
      Console.WriteLine("a.MyProperty = {0}", a.MyProperty); 
     // Indexer usage
      a[3] = a[1] = a[2];
      Console.WriteLine("a[3] = {0}", a[3]); 
     // Event usage
      a.MyEvent += new EventHandler(MyHandler); 
     // Overloaded operator usage
      MyClass c = a + b;
   } 
   static void MyHandler(object sender, EventArgs e) {
      Console.WriteLine("Test.MyHandler");
   } 
   internal class MyNestedClass
   {}
}
`
(63,15): warning CS0219: The variable 'c' is assigned but its value is never used
Instance constructor
Instance constructor
MyConst = 12
a.MyField = 35
MyClass.MyMethod
a.MyProperty = 36
this[1] = 0
this[3] = 0
a[3] = 0
Instance constructor
`
using System;
class Test
{
   static void F() {
      Console.WriteLine("F()");
   } 
   static void F(object o) {
      Console.WriteLine("F(object)");
   } 
   static void F(int value) {
      Console.WriteLine("F(int)");
   } 
   static void F(ref int value) {
      Console.WriteLine("F(ref int)");
   } 
   static void F(int a, int b) {
      Console.WriteLine("F(int, int)");
   } 
   static void F(int[] values) {
      Console.WriteLine("F(int[])");
   } 
   static void Main() {
      F();
      F(1);
      int i = 10;
      F(ref i);
      F((object)1);
      F(1, 2);
      F(new int[] {1, 2, 3});
   }
}
`
F()
F(int)
F(ref int)
F(object)
F(int, int)
F(int[])
`
class A 
{ 
   int x; 
   static void F(B b) { 
      b.x = 1;   // Ok 
   } 
} 
class B: A 
{ 
   static void F(B b) { 
      b.x = 1;   // Error, x not accessible 
   } 
}
`
(11,7): error CS0122: 'A.x' is inaccessible due to its protection level
(3,8): (Location of symbol related to previous error)
`
public class A 
{ 
   protected int x; 
   static void F(A a, B b) { 
      a.x = 1;   // Ok 
      b.x = 1;   // Ok 
   } 
} 
public class B: A 
{ 
   static void F(A a, B b) { 
      a.x = 1;   // Error, must access through instance of B 
      b.x = 1;   // Ok 
   } 
}
`
(12,7): error CS1540: Cannot access protected member 'A.x' via a qualifier of type 'A'; the qualifier must be of type 'B' (or derived from it)
`
using System; 
class A {} 
class Test 
{ 
   static void Main() { 
      string A = "hello, world"; 
      string s = A;                      // expression context 
      Type t = typeof(A);                // type context 
      Console.WriteLine(s);              // writes "hello, world" 
      Console.WriteLine(t.ToString());   // writes "A" 
   } 
}
`
hello, world
A
`
public interface J {
  const int x = 1;
  static J j;
}
`
(2,3): error CS0525: Interfaces cannot contain fields
(3,3): error CS0525: Interfaces cannot contain fields
`
/*
using System;
public delegate T GenDlg<T>(T t);

public class TestDriver
{
  public static void TestMemberAccessOfSubGenericClass<X>(X x)
  {

    GenDlg<X> DFldEv = delegate(X x){return x;};
    Console.WriteLine(DFldEv(x));

  }
  

  public static void Main()
  {
    
    TestDriver.TestMemberAccessOfSubGenericClass<string>("hello");
    
  }
}

hello
*/
using System;


public struct GS1<T>
{
  public int foo;
}

public class GenericClass<T>
{
  
  public static explicit operator GS1<T> (GenericClass<T> G)
  {
    return default(GS1<T>);
  }

  
}

public class SubGenericClass<T>
{
  
  public void TestBaseMemberAccessWithNoQualifiers()
  {
    GS1<T> GenericClassGS1T = (GS1<T>) default(GenericClass<T>);  
    Console.WriteLine(GenericClassGS1T.foo);
  }

}
public class Test
{

  public static void Main()
  {
    
    new SubGenericClass<int>().TestBaseMemberAccessWithNoQualifiers();
  }
}
`
0
`
using System;

[AttributeUsage(AttributeTargets.Class)]
public class HelpAttribute : Attribute
{
    public HelpAttribute(bool[] b1) {
        b = b1[1];
    }
    bool b = false;
    public bool Verify {get {return b;} }
}

[HelpAttribute(new bool[2] {false, true})] 
class Class1
{
}
    
public class MainClass
{
    public static int Main ()
    {
        object[] attrs = typeof(Class1).GetCustomAttributes (typeof(HelpAttribute), false);
        for (int i = 0; i < attrs.Length; i++)
        {
            HelpAttribute a = (HelpAttribute)attrs[i];
            Console.WriteLine("{0} : {1}", i, a.Verify);
        }
        return 0;
    }
}
`
0 : True
`
using L = A.B.T;
 
namespace A {
    class Foo : L {
    }
    public class B {
      public class T {
      }
      public static void Main(){}
    }
}
`
`
using System;
 
class T {
 
    private const long dirty_extent_size = 256 * 1024;
    
    public static ulong segSize = 0;
 
    public static int Main(){
        ulong offset = 0;
        return (int)Math.Min(dirty_extent_size, 
                                    segSize - offset);
    }
}
`
`
public class MyBase {
  public int this[long lngL] {
    get {
      return (int)lngL;
    }
  }
}

public class MyClass : MyBase {

  public int this[int intI] {
    get {
      return intI + 1;
    }
  }

  public static int Main() {
    MyClass test = new MyClass();
    if ((test[(long)3] == 3) && (test[(int)3] == 4)) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
class MyTest {}

class MyClass {

  const MyTest test = null;

  public static int Main() {
    if (test == null) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
using CoreNetSocket = System.IntPtr;
 
class T {
 
    public static void Main() {
        CoreNetSocket s = (CoreNetSocket)0;
        System.Console.WriteLine(s);
    }
}
`
0
`
struct S {
    int x;
}
 
 
class T {
 
    public static void Main() {
        S[] retval = new S[50];
 
        for(int i=0; i<50; i++) {
 
            retval[i] = new S();
        }
    }
}
`
`
using System.Collections.Generic;
public struct Seq<T>{
  public C foo(){ return new C(this); }
  public class C {
    public C(Seq<T> s){
      System.Console.WriteLine("constructing");
    }
  }
}
public class M { 
  public static void Main(){
    Seq<int> seq = new Seq<int>();
    Seq<int>.C c = seq.foo();
    System.Console.WriteLine(c != null);
  } 
}
`
constructing
True
`
public struct Seq<T> {
  public static Seq<T> operator + (Seq<T> s, Seq<T> t){ return s; }
  public static Seq<Seq<T>> foo;
}
 
public class M { 
  public static void Main(){
    Seq<int> x = new Seq<int>();
    x =+ x;
  } 
}
`
(3,29): error CS0523: Struct member 'Seq<T>.foo' of type 'Seq<Seq<T>>' causes a cycle in the struct layout
`
using System;

public class Gen<T>
{
  public void GenMeth<U>()
  {
    Console.WriteLine(typeof(U));
  }
}

public class Test
{
  public static void Main()
  {
    Gen<string> x = new Gen<string>();
    x.GenMeth<int>();
  }    
}
`
System.Int32
`
using System.Collections.Generic;
 
  public struct Pair<S,T>{
    public readonly S First;
    public readonly T Second;
 
    public Pair(S first, T second) { First = first; Second = second;}
}
 
public struct Seq<T> {
 
  public static Seq<Pair<T,S>> Zip<S>(Seq<T> s, Seq<S> t) {
    Seq<Pair<T,S>> r = new Seq<Pair<T,S>>();
    return r;
  }
 
}
 
public class M { public static void Main(){} }
`
`
public class GenericSyntax1 {
  public static void Main() {
    System.Collections.Generic.List<bool> list = new System.Collections.Generic.List<bool>(5);
    System.Console.WriteLine(list.Capacity);
  }
}
`
5
`
struct bar{}
class foo<T> where T : class{
}

public class GenericSyntax1 {
  public static void Main() {
    foo<bar> bad = null;
  }
}
`
(7,9): error CS0452: The type 'bar' must be a reference type in order to use it as parameter 'T' in the generic type or method 'foo<T>'
(2,7): (Location of symbol related to previous error)
(1,8): (Location of symbol related to previous error)
`
class bar{public bar(int one){}}
class foo<T> where T : new(){
}

public class GenericSyntax1 {
  public static void Main() {
    foo<bar> bad = null;
  }
}
`
(7,9): error CS0310: The type 'bar' must have a public parameterless constructor in order to use it as parameter 'T' in the generic type or method 'foo<T>'
(2,7): (Location of symbol related to previous error)
(1,7): (Location of symbol related to previous error)
`
class bar{public bar(int one){}}
class foo<T> where T : bar, new(){
}

public class GenericSyntax1 {
  public static void Main() {
    foo<bar> bad = null;
  }
}
`
(7,9): error CS0310: The type 'bar' must have a public parameterless constructor in order to use it as parameter 'T' in the generic type or method 'foo<T>'
(2,7): (Location of symbol related to previous error)
(1,7): (Location of symbol related to previous error)
`
class bar{}
class foo<T> where T : struct{
}

public class GenericSyntax1 {
  public static void Main() {
    foo<bar> bad = null;
  }
}
`
(7,9): error CS0453: The type 'bar' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'foo<T>'
(2,7): (Location of symbol related to previous error)
(1,7): (Location of symbol related to previous error)
`
class bar{}
class foo<T> where T : new(), GenericSyntax1{
}

public class GenericSyntax1 {
  public static void Main() {
    foo<bar> bad = null;
  }
}
`
(2,29): error CS0401: The new() constraint must be last
`
class bar{}
class foo<T> where T : bar, class{
}

public class GenericSyntax1 {
  public static void Main() {
    foo<bar> bad = null;
  }
}
`
(2,29): error CS0449: The 'class' or 'struct' constraint must come before any other constraints
`
static class AStaticClass
{
}

class AGenericClass<T> where T : AStaticClass //error
{
}

class AnotherGenericClass<T> where T : AStaticClass, new() //error
{
}

class Test
{
    public static int Main()
    {
        return 1;
    }
}
`
(5,34): error CS0717: 'AStaticClass': static classes cannot be used as constraints
(9,40): error CS0717: 'AStaticClass': static classes cannot be used as constraints
`
struct Seq<T>{
  public static void Zip<S>(Seq<S> s) {
  }
}
class Test{
  public static void Main(){
    Seq<int> s1;
    Seq<string>.Zip<int>(s1);
  }
}
`
`
using System;

class Foo<T> 
{
  public T Function<U>(U i)
  {
    return default(T);
  }
    
}
class Test
{
  public static void Main()
  {
    Foo<int> inst = new Foo<int>();  
    inst.Function<string>("hello");
  }
}
`
`
using System;
  public struct Pair<S,T>{
  }

  public struct Seq<T>{

    private class SeqEnumerator{
      public SeqEnumerator(Seq<T> s){
      }
    }
    
    public static object Zip<S>() {
      return new Seq<Pair<S,T>>();
    }
}

public class Test{
  static void Main(){
  }
}
`
`
public class Expr {}

public class StringConcat {
  public static void Main(string[]! args) {}

  public string P(string! s, Expr e) {
    return s + e;
  }
}
`
`
namespace Microsoft.Conformance.Expressions {
  public class arith011 {
    public static void Main()
    {
      int i1 = 11 + "5";
      i1++;
    }
  }
}
`
(5,16): error CS0029: Cannot implicitly convert type 'string' to 'int'
`
namespace Microsoft.Conformance.Expressions {
  public class arith011 {
    public static void Main()
    {
      int i1 = "11" + "5";
      i1++;
    }
  }
}
`
(5,16): error CS0029: Cannot implicitly convert type 'string' to 'int'
`
public interface I<T> {
  T m(T x);
}
public class C<T> : I<T> {
  T I<T>.m(T x) { return x; }
}
public class M { public static void Main(){} }
`
`
using System.Collections.Generic;
public class C<T> {
  public void foo(){
    C<T> local = this;
    local = local;
  }
}
class M { public static void Main(){} }
`
`
class C<T> : IEnumerator {}
`
(1,14): error CS0246: The type or namespace name 'IEnumerator' could not be found (are you missing a using directive or an assembly reference?)
`
`/d:WHIDBEYwithGenerics
#if WHIDBEYwithGenerics

  #if CCINamespace
    using Microsoft.Cci;
  #else
    using System.Compiler;
  #endif
    public interface IConstrainedType{}
    
#else

    public interface IConstrainedType{}
    
#endif
public class M { public static void Main(){} }
`
`
using System;

[module:A((int) "ANSI")]
class C { 
  
  static void Main() {}
}

[AttributeUsage(AttributeTargets.Module)]
public class A : Attribute
{
  public A(int charSet){}
}
`
(3,17): error CS0030: Cannot convert type 'string' to 'int'
`
using System;

public class A
{
    protected string p = "A";
    public virtual string P
    {       
        get { return p; }
        set { p = value; }
    }
}

public class B1 : A
{
    public override string P
    {
        set { }
    }
}

public class B2 : A
{
    public override string P
    {
        set { p = value; }
    }
}

public class C1 : B1
{
    public string F() { return base.P += "Hi"; }  
}

public class C2 : B2
{
    public string F() { return base.P += "Hi"; }
}

class Test
{
    static int Main()
    {
        A a = new A();
        if (a.P != "A") return 1;
        a = new B1();
        if (a.P != "A") return 1;
        a = new C1();
        if (a.P != "A") return 1;
        ((C1)a).F();
        if (a.P != "A") return 1;

        a = new B2();
        if (a.P != "A") return 1;
        a = new C2();
        if (a.P != "A") return 1;
        ((C2)a).F();
        if (a.P != "AHi") return 1;

        
        return 0;
    }

}
`
`
using System;
using System.Collections.Generic;

public struct Struct { }
public class BaseClass { }
public class DerClass : BaseClass { }

public struct GenStruct<T> { }
public class GenBaseClass<T> { }
public class GenDerClass<T> : GenBaseClass<T> { }

public class Test
{
  public static void Main()
  {
    foreach (BaseClass X in (IList<Struct>) new List<Struct>()){}
    foreach (Struct X in (IList<BaseClass>) new List<BaseClass>()){}
    foreach (GenStruct<Struct> X in (IList<GenStruct<BaseClass>>) new List<GenStruct<BaseClass>>()){}
    foreach (GenStruct<BaseClass> X in (IList<GenStruct<DerClass>>) new List<GenStruct<DerClass>>()){}
    foreach (GenStruct<DerClass> X in (IList<GenStruct<BaseClass>>) new List<GenStruct<BaseClass>>()){}
    foreach (GenBaseClass<Struct> X in (IList<GenBaseClass<BaseClass>>) new List<GenBaseClass<BaseClass>>()){}
    foreach (GenBaseClass<BaseClass> X in (IList<GenBaseClass<DerClass>>) new List<GenBaseClass<DerClass>>()){}
    foreach (GenBaseClass<DerClass> X in (IList<GenBaseClass<BaseClass>>) new List<GenBaseClass<BaseClass>>()){}

    foreach (BaseClass X in (IEnumerable<Struct>) new List<Struct>()){}
    foreach (Struct X in (IEnumerable<BaseClass>) new List<BaseClass>()){}
    foreach (GenStruct<Struct> X in (IEnumerable<GenStruct<BaseClass>>) new List<GenStruct<BaseClass>>()){}
    foreach (GenStruct<BaseClass> X in (IEnumerable<GenStruct<DerClass>>) new List<GenStruct<DerClass>>()){}
    foreach (GenStruct<DerClass> X in (IEnumerable<GenStruct<BaseClass>>) new List<GenStruct<BaseClass>>()){}
    foreach (GenBaseClass<Struct> X in (IEnumerable<GenBaseClass<BaseClass>>) new List<GenBaseClass<BaseClass>>()){}
    foreach (GenBaseClass<BaseClass> X in (IEnumerable<GenBaseClass<DerClass>>) new List<GenBaseClass<DerClass>>()){}
    foreach (GenBaseClass<DerClass> X in (IEnumerable<GenBaseClass<BaseClass>>) new List<GenBaseClass<BaseClass>>()){}

    foreach (BaseClass X in new List<Struct>()){}
    foreach (Struct X in new List<BaseClass>()){}
    foreach (GenStruct<Struct> X in new List<GenStruct<BaseClass>>()){}
    foreach (GenStruct<BaseClass> X in new List<GenStruct<DerClass>>()){}
    foreach (GenStruct<DerClass> X in new List<GenStruct<BaseClass>>()){}
    foreach (GenBaseClass<Struct> X in new List<GenBaseClass<BaseClass>>()){}
    foreach (GenBaseClass<BaseClass> X in new List<GenBaseClass<DerClass>>()){}
    foreach (GenBaseClass<DerClass> X in new List<GenBaseClass<BaseClass>>()){}


    foreach (BaseClass X in new Struct[2]){}
    foreach (Struct X in new BaseClass[2]){}
    foreach (GenStruct<Struct> X in new GenStruct<BaseClass>[2]){}
    foreach (GenStruct<BaseClass> X in new GenStruct<DerClass>[2]){}
    foreach (GenStruct<DerClass> X in new GenStruct<BaseClass>[2]){}
    foreach (GenBaseClass<Struct> X in new GenBaseClass<BaseClass>[2]){}
    foreach (GenBaseClass<BaseClass> X in new GenBaseClass<DerClass>[2]){}
    foreach (GenBaseClass<DerClass> X in new GenBaseClass<BaseClass>[2]){}
  }
}
`
(16,29): error CS0030: Cannot convert type 'Struct' to 'BaseClass'
(17,26): error CS0030: Cannot convert type 'BaseClass' to 'Struct'
(18,37): error CS0030: Cannot convert type 'GenStruct<BaseClass>' to 'GenStruct<Struct>'
(19,40): error CS0030: Cannot convert type 'GenStruct<DerClass>' to 'GenStruct<BaseClass>'
(20,39): error CS0030: Cannot convert type 'GenStruct<BaseClass>' to 'GenStruct<DerClass>'
(21,40): error CS0030: Cannot convert type 'GenBaseClass<BaseClass>' to 'GenBaseClass<Struct>'
(22,43): error CS0030: Cannot convert type 'GenBaseClass<DerClass>' to 'GenBaseClass<BaseClass>'
(23,42): error CS0030: Cannot convert type 'GenBaseClass<BaseClass>' to 'GenBaseClass<DerClass>'
(25,29): error CS0030: Cannot convert type 'Struct' to 'BaseClass'
(26,26): error CS0030: Cannot convert type 'BaseClass' to 'Struct'
(27,37): error CS0030: Cannot convert type 'GenStruct<BaseClass>' to 'GenStruct<Struct>'
(28,40): error CS0030: Cannot convert type 'GenStruct<DerClass>' to 'GenStruct<BaseClass>'
(29,39): error CS0030: Cannot convert type 'GenStruct<BaseClass>' to 'GenStruct<DerClass>'
(30,40): error CS0030: Cannot convert type 'GenBaseClass<BaseClass>' to 'GenBaseClass<Struct>'
(31,43): error CS0030: Cannot convert type 'GenBaseClass<DerClass>' to 'GenBaseClass<BaseClass>'
(32,42): error CS0030: Cannot convert type 'GenBaseClass<BaseClass>' to 'GenBaseClass<DerClass>'
(34,29): error CS0030: Cannot convert type 'Struct' to 'BaseClass'
(35,26): error CS0030: Cannot convert type 'BaseClass' to 'Struct'
(36,37): error CS0030: Cannot convert type 'GenStruct<BaseClass>' to 'GenStruct<Struct>'
(37,40): error CS0030: Cannot convert type 'GenStruct<DerClass>' to 'GenStruct<BaseClass>'
(38,39): error CS0030: Cannot convert type 'GenStruct<BaseClass>' to 'GenStruct<DerClass>'
(39,40): error CS0030: Cannot convert type 'GenBaseClass<BaseClass>' to 'GenBaseClass<Struct>'
(40,43): error CS0030: Cannot convert type 'GenBaseClass<DerClass>' to 'GenBaseClass<BaseClass>'
(41,42): error CS0030: Cannot convert type 'GenBaseClass<BaseClass>' to 'GenBaseClass<DerClass>'
(44,29): error CS0030: Cannot convert type 'Struct' to 'BaseClass'
(45,26): error CS0030: Cannot convert type 'BaseClass' to 'Struct'
(46,37): error CS0030: Cannot convert type 'GenStruct<BaseClass>' to 'GenStruct<Struct>'
(47,40): error CS0030: Cannot convert type 'GenStruct<DerClass>' to 'GenStruct<BaseClass>'
(48,39): error CS0030: Cannot convert type 'GenStruct<BaseClass>' to 'GenStruct<DerClass>'
(49,40): error CS0030: Cannot convert type 'GenBaseClass<BaseClass>' to 'GenBaseClass<Struct>'
(50,43): error CS0030: Cannot convert type 'GenBaseClass<DerClass>' to 'GenBaseClass<BaseClass>'
(51,42): error CS0030: Cannot convert type 'GenBaseClass<BaseClass>' to 'GenBaseClass<DerClass>'
`
`/unsafe
using System;

class Test
{
  static unsafe int Main()
  {
    int* p;
    int i;
    p = (int*)5;

    checked 
    {
      i = (int)p;
    }
    
    if (i != 5)
      return 1;

    return 0;    
  }
}
`
`
`/unsafe
using System;
namespace nms {
     public enum E1 { a=0x01, b=0x02, c=0x04, d=0x08, e=0x10, f=0x20 };
     public enum E2 : byte { a, b, c, d, e, f };
     public enum E3 : short { a, b, c, d, e, f };
     public enum E4 : int { a, b, c, d, e, f };
     public enum E5 : long { a, b, c, d, e, f };
     public enum E6 : sbyte { a, b, c, d, e, f };
     public enum E7 : ushort { a, b, c, d, e, f };
     public enum E8 : uint { a, b, c, d, e, f };
     public enum E9 : ulong { a, b, c, d, e, f };


    public class mine {

        public static int retval = 0x1FF;
    
      public static unsafe int Main()
        {
        if (sizeof(E1) == sizeof (int))
            retval -= 0x01;
        if (sizeof(E2) == sizeof (byte))
            retval -= 0x02;
        if (sizeof(E3) == sizeof (short))
            retval -= 0x04;
        if (sizeof(E4) == sizeof (int))
            retval -= 0x08;
        if (sizeof(E5) == sizeof (long))
            retval -= 0x10;
        if (sizeof(E6) == sizeof (sbyte))
            retval -= 0x20;
        if (sizeof(E7) == sizeof (ushort))
            retval -= 0x40;
        if (sizeof(E8) == sizeof (uint))
            retval -= 0x80;
        if (sizeof(E9) == sizeof (ulong))
            retval -= 0x100;
            
            if (retval == 0) Console.WriteLine ("PASS");
            else Console.WriteLine ("FAIL, retval=="+retval.ToString());
            return retval;
            }
        };
    }
`
PASS
`
`/unsafe
using System;

class Test {
  static volatile int x;
  unsafe static void foo (int *pX) { }
  static int Main() { 
    unsafe {
      Test.foo(&x);
    }
    return 1;
  }
}
`
(8,17): warning CS0420: 'Test.x': a reference to a volatile field will not be treated as volatile
(8,17): error CS0212: You can only take the address of unfixed expression inside of a fixed statement initializer
`
`/unsafe
class Test
{
    static unsafe int Main() 
    {
        sbyte baseline = 5;
        sbyte equiv = 5;
        sbyte *ptr = &baseline;

        if (*ptr == equiv)
            return 0;
        else 
            return 1;
    }
}
`
`
`/unsafe
class Test
{
    static unsafe int Main() 
    {
        int baseline = 5;
        void* ptr = &baseline;
        int test = *ptr;            // should cause the error

        return 0;
    }
}
`
(7,20): error CS0242: The operation in question is undefined on void pointers
`
struct S {
  static int s;
  static S() { s = 17; }
  S(int x) {}
}

class Test{public static void Main(){}}
`
`
`/unsafe
class Test
{
  static unsafe int Main() 
    {
        void* voidPtr;
        
        sbyte val = 5;

        sbyte* valPtr = &val;

        // cast from Type* to void*
        voidPtr = valPtr;

        // cast from void* to Type* and use indirection
        if (*(sbyte*)voidPtr != 5)
            return 1;

        return 0;
    }
}
`
`
`/unsafe
using System;

public class test
{
  public unsafe void MyMethod()
    {
    int a = 0;
    a = sizeof(int);
    Console.WriteLine(a);
  }
}

public class main
{
  public static int Main() 
    {
    return 0;
    }
}
`
`
`/unsafe
using System;

public unsafe class TestClass
{
    public int PerformTest()
    {
        int val = 40000;
        int* intPtr = &val;
        char* charPtr = (char*)intPtr;
        intPtr = (int*)charPtr;
        if (*intPtr == 40000)
            return 0;
        else
            return 1;
    }
}

public class TestDriver
{
  unsafe static int Main() 
    {
        return new TestClass().PerformTest();
    }
}
`
`
`/unsafe
using System;

public unsafe class TestClass
{
    public int PerformTest()
    {
        long num;
        int* ptr;

        num = 100;
        ptr = (int*)num;
        if ((long)ptr != 100)
            return 1;

        num = long.MaxValue;            
        ptr = (int*)num;
        if ((long)ptr != (long.MaxValue & 0xFFFFFFFF))
            return 2;

        num = long.MinValue;            
        ptr = (int*)num;
        if ((long)ptr != (long.MinValue & 0xFFFFFFFF))
            return 3;
        
        return 0;
    }
}

public class TestDriver
{
  unsafe static int Main() 
    {
        return new TestClass().PerformTest();
    }
}
`
`
`/unsafe
using System;

public unsafe class TestClass
{
    public int PerformTest()
    {
        uint num;
        int* ptr;

        num = 100;
        ptr = (int*)num;
        if ((uint)ptr != 100)
            return 1;

        num = uint.MaxValue;            
        ptr = (int*)num;
        if ((uint)ptr != uint.MaxValue)
            return 1;

        num = uint.MinValue;            
        ptr = (int*)num;
        if ((uint)ptr != uint.MinValue)
            return 1;
        
        return 0;
    }
}

public class TestDriver
{
  unsafe static int Main() 
    {
        return new TestClass().PerformTest();
    }
}
`
`
`/unsafe
public class test
{
    public int* ptr;

    public unsafe void SetPtrToNull()
    {
        ptr = null;
    }
}

public class main
{
  public static int Main() 
    {
        test t = new test();
        t.SetPtrToNull();

        return 0;
    }
}
`
(3,12): error CS0214: Pointers and fixed buffers may only be used in an unsafe context
`
`/unsafe
public class test
{
    public unsafe int* ptr;

    public unsafe void SetPtrToNull()
    {
        ptr = null;
    }

    public int MethWithPtrArg(int* p)
    {
        if (p == null)
            return 0;
        else
            return 1;    
    }
}

public class main
{
  public static int Main() 
    {
        test t = new test();
        t.SetPtrToNull();

        return 0;
    }
}
`
(10,31): error CS0214: Pointers and fixed buffers may only be used in an unsafe context
(12,13): error CS0214: Pointers and fixed buffers may only be used in an unsafe context
`
`/unsafe
using System;

public class TestClass
{
  public static unsafe int Main() 
    {
        int* ip = null;

        object obj1 = (object)ip;
        object obj2 = ip;

        return 0;
    }
}
`
(9,23): error CS0030: Cannot convert type 'int*' to 'object'
(10,23): error CS0029: Cannot implicitly convert type 'int*' to 'object'
`
`/unsafe
class Driver
{
    unsafe static int Main() 
    {
        string s = "hello, world";
        string* sPtr = &s;
        return 1;
    }
}
`
(6,9): error CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type ('string')
(6,24): error CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type ('string')
`
`/unsafe
enum MyEnum
{
    One, Two, Three
}

class Test
{
    static unsafe int Main() 
    {
        MyEnum baseline = MyEnum.Two;
        MyEnum equiv = MyEnum.Two;
        MyEnum *ptr = &baseline;

        if (*ptr == equiv)
            return 0;
        else 
            return 1;
    }
}
`
`
`/unsafe
class Test
{
    static unsafe int Main()
    {
        sbyte[] ia = new sbyte[5] {2,4,6,8,10};
        fixed (sbyte* ptr = ia) 
        {
            if (ptr[0] != 2)  return 1;
            if (ptr[2] != 6)  return 1;
            if (ptr[4] != 10) return 1;
        }

        return 0;
    }
}
`
`
class A : A.B
{
  public class B{}
}

class MyClass
{
  public static int Main() 
  {
    return 1;    
  }
}
`
(1,7): error CS0146: Circular dependency between 'A' and 'A.B'
(3,16): (Location of symbol related to previous error)
`
delegate void D();

class MyClass 
{

  public static int Main() 
  {
    bool b = false;
    D d;
        d = (b ? delegate { } : (D) delegate { });
        d = (b ? (D) delegate { } : delegate { });
    return 0;
  }
}
`
`
public class foo
{

  public static int Main()
  {
    decimal m1 = 0m;
    decimal m2 = 0000000000000000000000000000000.0m;
    decimal m3 = 0.0000000000000000000000000000000m;

    decimal m4 = -0m;
    decimal m5 = -0000000000000000000000000000000.0m;
    decimal m6 = -0.0000000000000000000000000000000m;

    if ((m1 + m2 + m3 == 0) && (m4 + m5 + m6 == 0) && (m1 + m2 + m3 + m4 + m5 + m6 == 0))
      return 0;

    return 1;

  }
}
`
`
public class foo {
  
  public static int Main() {

    decimal m1;
    m1 = 0.000000000000000000000000000001m; // 1e-30
    m1 = 0.000000000000000000000000000010m; // 1e-29
    m1 = 0.000000000000000000000000000040m;
    m1 = 0.000000000000000000000000000050m;
    m1 = 0.000000000000000000000000000060m;

    if (m1 > 0.0m)
      return 0;
  
    return 1;

  }
}
`
`
public class GenBaseClass<T> { }
public class GenRecClass<T> : GenBaseClass<GenRecClass<T>> { }
public class Test{public static void Main(){}}
`
`
public class test
{
    public void MethWithLocalPtr()
    {
        int* test;
        test = null;
    }
}

public class main
{
  public static int Main() 
    {
        test t = new test();

        return 0;
    }
}
`
(5,9): error CS0214: Pointers and fixed buffers may only be used in an unsafe context
(6,9): error CS0214: Pointers and fixed buffers may only be used in an unsafe context
`
`/unsafe
public class test
{
    public int ptr;
}

public class main
{
    unsafe static int Main() 
    {
        test t = new test();
        test* tPtr = &t;
        return 0;
    }
}
`
(11,9): error CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type ('test')
(11,22): error CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type ('test')
`
`/unsafe
using System;

public class testClass
{
    public int x;
}

public class main
{
  public unsafe static int Main() 
    {
        int x = sizeof(testClass);
        
        return 0;
    }
}
`
(12,24): error CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type ('testClass')
`
`/unsafe
using System;

public class main
{
  public unsafe static int Main() 
    {
        const int x = sizeof(int);
        
        return x == 4 ? 0 : 1;
    }
}
`
`
`/unsafe
class Test
{
    static unsafe int Main()
    {
        short[] ia = new short[5] {2,4,6,8,10};
        fixed (short* ptr = ia) 
        {
            if (ptr[0] != 2)  return 1;
            if (ptr[2] != 6)  return 1;
            if (ptr[4] != 10) return 1;
        }

        return 0;
    }
}
`
`
`/unsafe
struct TestStruct
{
    public int X;

    public override string ToString()
    {
        return X.ToString();

    }
}

class Test
{
    static unsafe int Main()
    {
        TestStruct[] ia = new TestStruct[5];
        ia[0].X = 2;
        ia[1].X = 4;
        ia[2].X = 6;
        ia[3].X = 8;
        ia[4].X = 10;

        fixed (TestStruct* ptr = ia) 
        {
            if (ptr[0].X != 2)  return 1;
            if (ptr[2].X != 6)  return 1;
            if (ptr[4].X != 10) return 1;
        }

        return 0;
    }
}
`
`
`/unsafe
public class main
{
    unsafe static int Main() 
    {
        return 0;
    }
}
 
unsafe class C {
 
    void SendM(int i, Rep* b) {}
 
    public struct Rep {
        int x;
    }
}
`
`
`/unsafe
using System;

class ElementAccess
{
    static unsafe void Main()
    {
        short[] ia = new short[5] {2,4,6,8,10};
        fixed (void* ptr = ia)
        {
            Console.WriteLine(ptr[3]);
        }
    }
}
`
(10,31): error CS0242: The operation in question is undefined on void pointers
`
`/unsafe
class Test
{
    static unsafe int Main()
    {
        char[] ia = new char[5] {'a','b','c','d','e'};
        fixed (char* ptr = ia)
        {
            char x;

            x = (char)0; if (ptr[x] != 'a') return 1;
            x = (char)2; if (ptr[x] != 'c') return 1;
            x = (char)4; if (ptr[x] != 'e') return 1;
        }

        return 0;
    }
}
`
`
`/unsafe
using System;

class ElementAccess
{
    static unsafe int Main()
    {
        char[] ia = new char[5] {'a','b','c','d','e'};
        fixed (char* ptr = ia)
        {
            for (double x = 0; x < ia.Length; x++)
                Console.WriteLine(ptr[x]);
        }

        return 1;
    }
}
`
(11,39): error CS0029: Cannot implicitly convert type 'double' to 'int'
`
`/unsafe
class Test
{
    static unsafe int Main()
    {
        char[] ia = new char[5] {'a','b','c','d','e'};
        fixed (char* ptr = ia)
        {
            uint x;

            x = 0; if (ptr[x] != 'a') return 1;
            x = 2; if (ptr[x] != 'c') return 1;
            x = 4; if (ptr[x] != 'e') return 1;
        }

        return 0;
    }
}
`
`
`/unsafe
using System;

class Test
{
    static unsafe void Main()
    {
        int *i = null;
        int j = i[1,2];
    }
}
`
(8,17): error CS0196: A pointer must be indexed by only one value
`
`/unsafe
using System;

class PointerArithmetic
{
    static unsafe int Main()
    {
        int* a = (int*)10;
        int* b = (int*)5;
        
        checked 
        {
            object d1 = a - b;
            if (!(d1 is long)) return 1;
            long diff1 = (long)d1;
            long diff2 = ((byte*)a) - ((byte*)b);
            if (diff2 / sizeof(int) != diff1) return 1;
        }

        return 0;
    }
}
`
`
`/unsafe
using System;

class PointerArithmetic
{
    static unsafe int Main()
    {
        sbyte[] ia = new sbyte[5] {2,4,6,8,10};

        // pointer used to test each operator overload
        sbyte* tmpPtr, newPtr;

        fixed (sbyte* ptr = ia) 
        {
            sbyte* endPtr = ptr + ia.Length;

            // T* operator -(T* x, int y);
            tmpPtr = endPtr - 2;
            if ( *tmpPtr != ia[ia.Length - 2] )
                return 1;

            // T* operator -(T* x, uint y);
            tmpPtr = endPtr - 2u;
            if ( *tmpPtr != ia[ia.Length - 2] )
                return 2;

            // T* operator -(T* x, long y);
            tmpPtr = endPtr - 2L;
            if ( *tmpPtr != ia[ia.Length - 2] )
                return 3;

            // T* operator -(T* x, ulong y);
            tmpPtr = endPtr - 2UL;
            if ( *tmpPtr != ia[ia.Length - 2] )
                return 4;

            // long operator -(T* x, T* y);
            tmpPtr = endPtr;
            newPtr = endPtr - 2;
            if ( tmpPtr - newPtr != 2 )
                return 5;
        }

        // all tests passed if we get to this point
        return 0;
    }
}
`
`
`/unsafe
using System;

class PointerArithmetic
{
    static unsafe int Main()
    {
        int* a = (int*)10;
        int* c = null;
        
        checked 
        {
            c = a++;
            c = ++c;
        }

        return 0;
    }
}
`
`
`/unsafe
using System;

class PointerArithmetic
{
    static unsafe int Main()
    {
        int number1 = 5;
        void* ptr1 = &number1;
        
        int number2 = 10;
        void* ptr2 = &number2;

        long result = 0;
        result = ptr1 + 5;
        result = 5 + ptr1;
        result = ptr1 - ptr2;
        result = ptr1 - 5;
        result = ptr1 + ptr2;

        return 0;
    }
}
`
(14,18): error CS0242: The operation in question is undefined on void pointers
(15,18): error CS0242: The operation in question is undefined on void pointers
(16,18): error CS0242: The operation in question is undefined on void pointers
(17,18): error CS0242: The operation in question is undefined on void pointers
(18,18): error CS0019: Operator '+' cannot be applied to operands of type 'void*' and 'void*'
`
`/unsafe
using System;

class PointerArithmetic
{
    static unsafe int Main()
    {
        int number = 5;
        int* ptr = &number;       

        long result = 5 - ptr;

        return 0;
    }
}
`
(10,23): error CS0019: Operator '-' cannot be applied to operands of type 'int' and 'int*'
`
`/unsafe
class Test
{
  static unsafe int Main()  
  {
    // Test will always pass unless compiler ICEs.
    // result of zero size operation is undefined in spec.
        sbyte* ptr = stackalloc sbyte[0];
        if (ptr == null)  
            return 0;
        else 
            return 0;  
  }
}
`
`
using System;
using System.Collections;
using System.Collections.Generic;

delegate void D();
delegate bool D1<T>();

class MyAtt : Attribute
{
  public MyAtt(D d, D1<int> d1){}
}

[MyAtt(delegate{},((D1<int>)delegate{}))]
public class A
{
  [MyAtt(delegate { }, ((D1<int>)delegate { }))]
  int i;
  [return:MyAtt(delegate { }, ((D1<int>)delegate { }))]
  [MyAtt(delegate { }, ((D1<int>)delegate { }))]
  static int Main([MyAtt(delegate{},((D1<int>)delegate{}))]string[] args)
  {
    return 1;
  }
}
`
(13,8): error CS1706: Expression cannot contain anonymous methods
(13,29): error CS1706: Expression cannot contain anonymous methods
(16,10): error CS1706: Expression cannot contain anonymous methods
(16,34): error CS1706: Expression cannot contain anonymous methods
(18,17): error CS1706: Expression cannot contain anonymous methods
(18,41): error CS1706: Expression cannot contain anonymous methods
(19,10): error CS1706: Expression cannot contain anonymous methods
(19,34): error CS1706: Expression cannot contain anonymous methods
(20,26): error CS1706: Expression cannot contain anonymous methods
(20,47): error CS1706: Expression cannot contain anonymous methods
`
using System;


delegate int D();

D d = {;}

public class Test
{
  public static int Main ()
  {
    Test t = new Test ();

    return 1;
  }
}

`
(6,1): error CS0116: A namespace does not directly contain members such as fields or methods
`
using System;

public class Test
{
    public static int Main(string [] args)
    {
      int ret = 1;
      switch (false) {
        default:
          ret = 0;
          break;
        case true:
          ret = 1;
      }
      return(ret);
    }
}

`
(12,9): warning CS0162: Unreachable code detected
`
`/unsafe
using System;

class Test
{
    static unsafe int Main()
    {
        int* ptr = stackalloc int[3];

        void* vp = (void*)ptr;
        vp++;
        ++vp;
        vp--;
        --vp;

        return 0;
    }
}
`
(10,9): error CS0242: The operation in question is undefined on void pointers
(11,9): error CS0242: The operation in question is undefined on void pointers
(12,9): error CS0242: The operation in question is undefined on void pointers
(13,9): error CS0242: The operation in question is undefined on void pointers
`
`/unsafe
using System;

class Test
{
    static unsafe int Main()
    {
        int* ptr = stackalloc int[2];
        *ptr = 5;
        int x = (*ptr)++;
        if (x != 5)
            return 1;
        x = *ptr;
        if (x != 6)
            return 2;
        return 0;
    }
}
`
`
`/unsafe
using System;

struct MyStruct
{
    public int num;
}

class Test
{
    public unsafe MyStruct* MyMethod()
    {
        return null;
    }
}

class TestDriver
{
    static void Main()
    {
        Test t = new Test();
        t.MyMethod()->num = 5;
        t->MyMethod();
    }
}
`
(21,9): error CS0214: Pointers and fixed buffers may only be used in an unsafe context
(22,9): error CS0193: The * or -> operator must be applied to a pointer
`
`/unsafe
class TestClass
{
  public unsafe void Method(ref int* arg)
  {
    if (arg == (int*)4)
      arg = (int*)5;
    else
      arg = (int*)6;
  }
}

class Driver
{
  static unsafe int Main()
  {
    int* ptr = (int*)4;

    TestClass tc = new TestClass();
    tc.Method(ref ptr);

    if (ptr != (int*)5)
      return 1;

    return 0;    
  }
}
`
`
`/unsafe
unsafe class Test {

    public struct S {
        public int x;
    }
    
    public static void UseIndexedPointerAsRef(S* ptr) 
    {
        UseByRef(ref ptr[5]);
    }

    public static void UseIndexedPointerAsRef(int* ptr) 
    {
        UseByRef(ref ptr[5]);
    }

    public static void UseByRef(ref S p) {
        p.x = 5;
    }

    public static void UseByRef(ref int p) {
        p = 5;
    }

    public static void Main() {}
    
}
`
`
`/unsafe
using System;

class PointerComparison
{
    static unsafe int Main()
    {
        sbyte[] ia = new sbyte[5] {2,4,6,8,10};

        fixed (sbyte* p1 = &ia[2], p2 = &ia[4], p3 = &ia[4])
        {
            // bool operator ==(void* x, void* y);

                // positive test
                if (p2 == p3)
                    Console.WriteLine("Passed");
                else
                    return 1;

                // negative test
                if (p1 == p2)
                    return 1;

            // bool operator !=(void* x, void* y);

                // positive test
                if (p1 != p2)
                    Console.WriteLine("Passed");
                else
                    return 1;

                // negative test
                if (p2 != p3)
                    return 1;

            // bool operator <(void* x, void* y);
            
                // positive test
                if (p1 < p2)
                    Console.WriteLine("Passed");
                else
                    return 1;

                // negative test
                if (p2 < p3)
                    return 1;
            
            // bool operator >(void* x, void* y);

                // positive test
                if (p2 > p1)
                    Console.WriteLine("Passed");
                else 
                    return 1;

                // negative test
                if (p2 > p3)
                    return 1;            

            // bool operator <=(void* x, void* y);

                // positive test
                if (p1 <= p2)
                    Console.WriteLine("Passed");
                else
                    return 1;

                // negative test
                if (p2 <= p1)
                    return 1;
            
            // bool operator >=(void* x, void* y);

                // positive test
                if (p2 >= p1)
                    Console.WriteLine("Passed");
                else
                    return 1;

                // negative test
                if (p1 >= p2)
                    return 1;
        }

        // all tests passed if we get to this point
        return 0;
    }
}
`
Passed
Passed
Passed
Passed
Passed
Passed
`
`/unsafe
class Test
{
  static unsafe int Main()  
  {
    sbyte* ptr = stackalloc sbyte[10];
    
    for (int idx = 0; idx < 10; idx++)
    {
      ptr[idx] = (sbyte)idx;
      if (ptr[idx] != idx)
        return 1;
    }

    for (int idx = 0; idx < 10; idx++)
    {
      if (*ptr++ != idx)
        return 2;
    }

    return 0;
  }
}
`
`
`/unsafe
class Test
{
  static unsafe int Main()  
  {
    char* ptr = stackalloc char[10];
    
    for (int idx = 0; idx < 10; idx++)
    {
      ptr[idx] = (char)(idx + (int)'a');
      if (ptr[idx] != idx + (int)'a')
        return 1;
    }

    for (int idx = 0; idx < 10; idx++)
    {
      if (*ptr++ != idx + (int)'a')
        return 2;
    }

    return 0;
  }
}
`
`
`/unsafe
class Test 
{
    static unsafe int Main() 
    {
        string* ptr = stackalloc string[10];
    return 1;
  }
}
`
(5,9): error CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type ('string')
(5,34): error CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type ('string')
`
`/unsafe
public class TestClass
{
    public static unsafe int operator+(TestClass number) { return 0; }
}

public class MainClass
{
  static void Main() 
    {
    }
}
`
`
`/unsafe
public interface TestInterface
{
    unsafe int TestMethod();
}

public class MainClass
{
  static void Main() 
    {
    }
}
`
`
`/unsafe
public struct TestStruct
{
    static unsafe TestStruct() { }
}

public class MainClass
{
  static void Main() 
    {
    }
}
`
`
`/unsafe
using System;

public class ManagedClass
{
    public int x = 5;
    public float y = 1.0f;
    public string z = "test";
}

public class Test
{
    static unsafe int Main()
    {
        ManagedClass mc = new ManagedClass();

        fixed (int* p1 = &mc.x)
        fixed (float* p2 = &mc.y)
        fixed (char* p3 = mc.z) 
        {
            if (*p1==5 && *p2==1.0f && *p3=='t')
                return 0;
        }

        return 1;
    }
}
`
`
`/unsafe
using System;

public class Test
{
    public unsafe static int Main() 
    {
        short x = 5;

        fixed (short* ptr = &x)
        {
            short* tempPtr = ptr;

            Console.WriteLine(*tempPtr);
        }

        return 0;
    }
}
`
(9,30): error CS0213: You do not need to use the fixed statement to take the address of an already fixed expression
`
`/unsafe
using System;

public class test
{
    public unsafe void meth(int* x)
    {
        Console.WriteLine(*x);
    }
}

public class main
{
  public static int Main() 
    {
        int val = 3;
        test t = new test();

        t.meth(&val);

        return 0;
    }
}
`
(18,9): error CS0214: Pointers and fixed buffers may only be used in an unsafe context
`
`/unsafe
class Test
{
  static unsafe int Main()  
  {
    sbyte* ptr = stackalloc sbyte[-5];
    return 0;
  }
}
`
(5,35): error CS0247: Cannot use a negative size with stackalloc
`
`/unsafe
class Test
{
  static unsafe int Main()  
  {
    try
        {
        }
        catch (System.Exception)
        {
        }
        finally
        {
            sbyte* ptr = stackalloc sbyte[5];
        }
        
        return 0;
  }
}
`
(13,26): error CS0255: stackalloc may not be used in a catch or finally block
`
`/unsafe
class Test
{
  static unsafe int Main()  
  {
    int* ptr = stackalloc int(10);
    return 0;
  }
}
`
(5,30): error CS1575: A stackalloc expression requires [] after type
`
`/unsafe
class Test
{
  static unsafe int Main()  
  {
    // Test will always pass unless compiler ICEs.
    // result of zero size operation is undefined in spec.
        int zero = 0;
        sbyte* ptr = stackalloc sbyte[zero];
        if (ptr == null)
            return 0;
        else 
            return 0;
  }
}
`
`
`/unsafe
using System;

public class test
{
    public unsafe void testMeth(int& x)
    {
        Console.WriteLine(1);
    }
}

public class main
{
  public static int Main() {}
}
`
(5,36): error CS1001: Identifier expected
`
`/unsafe
using System;

class Test
{
  static unsafe int Main() 
    {
        int a = 5, b = 6;
        int* p = &(a + b);

        return 0;
    }
}
`
(8,20): error CS0211: Cannot take the address of the given expression
`
`/unsafe
delegate void D();

struct S
{
    int M() { unsafe return 0; }
    int P { get { unsafe return 0; } set { unsafe int x = value; } }
    event D E { add { unsafe int x = 5; } remove { unsafe int x = 5; } }
}

class C
{
    int M() { unsafe return 0; }
    int P { get { unsafe return 0; } set { unsafe int x = value; } }
    event D E { add { unsafe int x = 5; } remove { unsafe int x = 5; } }
    
    static void Main() { }
}
`
(5,22): error CS1514: { expected
(6,26): error CS1514: { expected
(6,51): error CS1514: { expected
(7,30): error CS1514: { expected
(7,59): error CS1514: { expected
(12,22): error CS1514: { expected
(13,26): error CS1514: { expected
(13,51): error CS1514: { expected
(14,30): error CS1514: { expected
(14,59): error CS1514: { expected
`
`/unsafe
class C
{
    unsafe { void M() {} }
}
`
(3,12): error CS1031: Type expected
(4,1): error CS1519: Invalid token '}' in class, struct, or interface member declaration
`
`/unsafe
public unsafe enum TestEnum 
{
    One, Two, Three
}

public unsafe class main
{
    static void Main() 
    {
    }
}
`
(1,20): error CS0106: The modifier 'unsafe' is not valid for this item
`
`/unsafe
class Test
{
    unsafe static void* Foo() {return null;}

    static void Main() {
        Foo();  // this should be an error
    }
}
`
(6,9): error CS0214: Pointers and fixed buffers may only be used in an unsafe context
`
`/unsafe
class Test 
{
  static void Main() 
  {
    int*[] apfInd = new int*[4];
  }
}
`
(5,25): error CS0214: Pointers and fixed buffers may only be used in an unsafe context
`
`/unsafe
using System;

class C
{
    public unsafe static void Main()
    {
        byte[] b = new byte[100];
        
        fixed (int* p = (int*) &b[4])
        {
            Console.WriteLine(*p);
        }
    }
}
`
(9,21): error CS0254: The right hand side of a fixed statement assignment may not be a cast expression
`
`/unsafe
using System;

public class Test
{
    public unsafe static int Main() 
    {
        int[] arr1 = new int[5] {5, 2, 3, 4, 5};

        fixed (int* p1 = arr1)
        {
            p1 = null;
        }

        return 1;
    }
}
`
(11,13): error CS1656: Cannot assign to 'p1' because it is a 'fixed variable'
`
`/unsafe
using System;

public class ManagedClass
{
    public int x = 5;
    public float y = 1.0f;
    public string z = "test";
}

public class Test
{
    static unsafe int Main()
    {
        ManagedClass mc = new ManagedClass();

        fixed (int* p1 = &mc.x, float* p2 = &mc.y, string p3 = &mc.z) 
        {
            if (*p1==5 && *p2==6 && *p3==7)
                return 0;
        }

        return 1;
    }
}
`
(16,33): error CS1044: Cannot use more than one type in a for, using, fixed, or declaration statement
(16,52): error CS1044: Cannot use more than one type in a for, using, fixed, or declaration statement
(16,45): error CS0029: Cannot implicitly convert type 'float*' to 'int*'
(16,64): error CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type ('string')
`
`/unsafe
using System;

public class Test
{
    public unsafe static void Method(ref int* arg)
    {
        Console.WriteLine("Here");
    }
    
    public unsafe static int Main() 
    {
        int[] arr1 = new int[5] {5, 2, 3, 4, 5};

        fixed (int* p1 = arr1)
        {
            Test.Method(ref p1);;
        }

        return 1;
    }
}
`
(16,29): error CS1657: Cannot pass 'p1' as a ref or out argument because it is a 'fixed variable'
`
`/unsafe
using System;

class Test
{
    unsafe static int Main() 
    {
        fixed (int p1 = 5) {}
        return 1;
    }
}
`
(7,16): error CS0209: The type of locals declared in a fixed statement must be a pointer type
`
using System;

class C {
  bool Test(IntPtr ptr){
    if (ptr == null) 
      return true; 
    if (null != ptr)
      return false; 
    return true && false;
  }
  public static void Main(){}
}
`
(5,9): error CS0019: Operator '==' cannot be applied to operands of type 'System.IntPtr' and '<null>'
(7,9): error CS0019: Operator '!=' cannot be applied to operands of type '<null>' and 'System.IntPtr'
`
interface ITest 
{
    int F(int x);
    int F(string x);
}

class Test : ITest 
{
    public int F(int x) 
    {
        return 0;
    }

    public int F(string x) 
    {
        return 0;
    }
}

class Driver 
{
    static int Main() 
    {
        Test t = new Test();
        return t.F(23) + t.F("some string");
    }
}
`
`
namespace Feature {

  using System;

  interface I {
      int f();
  }

  class S : I {
      public int f() {
          return 1;
      }
  }

  class R : S {
      public new int f() {
          return 2;
      }
  }

  class Q : R, I {
      public new int f() {
          return 3;
      }
  }

  public class Test {

      public static void Main() {
          I i = new S();
          if(!(i.f() == 1)) {
              Console.WriteLine("Failed f?");
          }

          i = new R();
          if(!(i.f() == 1)) {
              Console.WriteLine("Failed R.f virtual");
          }

          i = new Q();
          if(!(i.f() == 3)) {
              Console.WriteLine("Failed Q.f not virtual");
          }

      }
  }
}
`
`
namespace Feature {

  using System;

  interface I {
      int f();
  }

  class S : I {
      public int f() {
          return 1;
      }
  }

  class R : S {
      public new int f() {
          return 2;
      }
  }

  class Q : R, I {
      private new int f() {
          return 3;
      }
  }

  public class Test {

      public static void Main() {
          I i = new S();
          if(!(i.f() == 1)) {
              Console.WriteLine("Failed f?");
          }

          i = new R();
          if(!(i.f() == 1)) {
              Console.WriteLine("Failed R.f virtual");
          }

          i = new Q();
          if(!(i.f() == 3)) {
              Console.WriteLine("Succeeded Q.f not virtual");
          }

      }
  }
}
`
Succeeded Q.f not virtual
`
#if !FOO
 
public class C {
 
    #if KERNEL
    unsafe
    #endif
    public C next;
}
 
#else
 
class C {
}
 
#endif

class Test{public static void Main(){}}
`
`
using System;

public class Gen
{
  public static bool IsT<T>(T t)
  {
    if (t is T) 
      return true;
    return false;
  }  
}


public class Test
{
  public static int counter = 0;
  public static bool result = true;
  public static void Eval(bool exp)
  {
    counter++;
    if (!exp)
    {
      result = exp;
      Console.WriteLine("Test Failed at location: " + counter);
    }
  
  }
  
  public static int Main()
  {
    Test.Eval(Gen.IsT<int>(1));
    Test.Eval(Gen.IsT<string>("string"));
    Test.Eval(!(Gen.IsT<object>(null)));

    if (result)
    {
      Console.WriteLine("Test Passed");
      return 0;
    }
    else
    {
      Console.WriteLine("Test Failed");
      return 1;
    }
    
  }
    
}
`
Test Passed
`
`/p:v2
using System;
using System.Collections.Generic;

public struct Gen<T> : IEnumerable<T>  
{
  T[] Values;
  
  public Gen(T[] Values)
  {
    this.Values = Values;    
  }
  
  public IEnumerator<T>  GetEnumerator()
  {
    foreach(T Value in Values)
    {
      yield return Value;
    }
  }

  System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
  {
    return this.GetEnumerator();
  }

  public static void TestForeach(Gen<T> G, T[] Arr)
  {
    ((VerifyIterator<T>)
      delegate(Gen<T> XG, T[] XArr) 
      { 
        int i = 0;
        foreach(T val in XG)
        {
          Test.Eval(val.Equals(XArr[i++]));
        }
      }
    )(G,Arr); 
  }
}


public delegate void VerifyIterator<T>(Gen<T> G, T[] Arr);

public class Test
{
  public static int counter = 0;
  public static bool result = true;
  public static void Eval(bool exp)
  {
    counter++;
    if (!exp)
    {
      result = exp;
      Console.WriteLine("Test Failed at location: " + counter);
    }
  
  }
  
  public static int Main()
  {
    Gen<int>.TestForeach(new Gen<int>(new int[]{1,2,3,4,5,6,7,8,9}),new int[]{1,2,3,4,5,6,7,8,9});
    Gen<string>.TestForeach(new Gen<string>(new string[]{"1","2","3","4","5","6","7","8","9"}),new string[]{"1","2","3","4","5","6","7","8","9"});
  
    if (result)
    {
      return 0;
    }
    else
    {
      return 1;
    }
  }
    
}
`
`
using System;

public class Test
{
  private delegate void D();
  int i = 10;  // private field
  public void foo()
  {
    D d = delegate()
    {
      // AD local
      int i = 10;
      goto LABEL1;
    };
  LABEL1:
    d();
  }

  public static int Main()
  {
    return 1;
  }
}
`
(13,7): error CS1632: Control cannot leave the body of an anonymous method
`
using System;

struct A 
{
  public C CFld; 
}

class C
{
  public A AFld;
  
  public static implicit operator A(C c)
  {
    return c.AFld;
  }

  public static explicit operator C(A a)
  {
    return a.CFld;
  }
}

class D : C {}

class NullableTest1
{
  public static void Context<T>() where T : C, new()
  {
    A a = new A();
    a.CFld = new T();
    a.CFld.AFld = a;

    C c = a.CFld;

    A? nubA = c;
    Test.Eval(nubA.HasValue && nubA.Value.CFld == c);

    C nubC = (C)nubA;
    Test.Eval(nubC.AFld.CFld == c);

    try
    {
      nubA = null;
      nubC = (C)nubA;
      Test.Eval(false);
    }
    catch (InvalidOperationException) 
    {
      Test.Eval(true);
    }
  }  
}

class NullableTest<T> where T : C, new()
{
  public static void Context() 
  {
    A a = new A();
    a.CFld = new T();
    a.CFld.AFld = a;

    C c = a.CFld;

    A? nubA = c;
    Test.Eval(nubA.HasValue && nubA.Value.CFld == c);

    C nubC = (C)nubA;
    Test.Eval(nubC.AFld.CFld == c);

    try
    {
      nubA = null;
      nubC = (C)nubA;
      Test.Eval(false);
    }
    catch (InvalidOperationException) 
    {
      Test.Eval(true);
    }
  }  
}

public class Test
{
  public static int counter = 0;
  public static bool result = true;

  public static void Eval(bool expr)
  {
    counter++;
    if (!expr)
    {
      result = false;
      Console.WriteLine("Test Failed at location {0}", counter);
    }

  }
  
  public static int Main()
  {
    NullableTest1.Context<D>();
    NullableTest<D>.Context();
    if (result)
      return 0;
    else
      return 1;
  }

}
`
`
`/unsafe
public class Test {

private static unsafe void memcpy(byte *dst, byte *src, int length)
{
    dst += 16;
    int i = 8;
    dst += i;
    long j = 4;
    dst += j;
}
private static unsafe void memcpy(long *dst, long *src, int length)
{
    dst += 16;
    int i = 8;
    dst += i;
    long j = 4;
    dst += j;
}
public static void Main() {}
}
`
`
using System;

public struct S 
{
  public static implicit operator int(S s)
  {
    return s.x;
  }
  
  int x;
  
  public S(int x)
  {
    this.x = x;
  }
}

public class Test
{
  public static void F(int? x) {}
  
  public static int Main()
  {
    S? x = new S(2);
    F(x);
    if (x.ToString() == "S")
      return 0;
    return 1;
  }
}
`
`
using System;

public class Verifier
{
    public static string LastAction;
    public static void SetLastAction(string format, params object[] args)
    {
        LastAction = String.Format(format, args);
    }
}

struct S { }

class GenC<T> where T : struct
{
    public static implicit operator GenC<T>(T t)
    {
        Verifier.SetLastAction("GenC[{0}].op_Implicit({0})", typeof(T));
        return new GenC<T>();
    }

    public static implicit operator T(GenC<T> gc)
    {
        Verifier.SetLastAction("GenC[{0}].op_Implicit(GenC[{0}])", typeof(T));
        return default(T);
    }

    public static void TestContext()
    {
        T? nubT;
        GenC<T> gc = new GenC<T>();

        nubT = gc;
        Test.Eval(Verifier.LastAction, String.Format("GenC[{0}].op_Implicit(GenC[{0}])", typeof(T)));
        nubT = nubT;
    }
}

struct GenS<T> where T : struct
{
    public static implicit operator GenS<T>(T t)
    {
        Verifier.SetLastAction("GenS[{0}].op_Implicit({0})", typeof(T));
        return new GenS<T>();
    }

    public static implicit operator T(GenS<T> gc)
    {
        Verifier.SetLastAction("GenS[{0}].op_Implicit(GenS[{0}])", typeof(T));
        return default(T);
    }

    public static void TestContext()
    {
        T? nubT = new T();

        GenS<T>? gs = nubT;
        Test.Eval(Verifier.LastAction, String.Format("GenS[{0}].op_Implicit({0})", typeof(T)));

        nubT = gs;
        Test.Eval(Verifier.LastAction, String.Format("GenS[{0}].op_Implicit(GenS[{0}])", typeof(T)));


        nubT = null;
        gs = nubT;
        Test.Eval(gs.HasValue == false);
    }
}


class NullableTest
{
    public static void Context<T>() where T : struct
    {
        T? nubT;
        GenC<T> gc = new GenC<T>();

        nubT = gc;
        Test.Eval(Verifier.LastAction, String.Format("GenC[{0}].op_Implicit(GenC[{0}])", typeof(T)));


        nubT = new T();

        GenS<T>? gs = nubT;
        Test.Eval(Verifier.LastAction, String.Format("GenS[{0}].op_Implicit({0})", typeof(T)));

        nubT = (T?)gs;
        Test.Eval(Verifier.LastAction, String.Format("GenS[{0}].op_Implicit(GenS[{0}])", typeof(T)));

        nubT = null;
        gs = nubT;
        Test.Eval(gs.HasValue == false);
    }
}


public class Test
{
    public static int counter = 0;
    public static bool result = true;

    public static void Eval(bool expr)
    {
        counter++;
        if (!expr)
        {
            result = false;
            Console.WriteLine("Test Failed at location {0}", counter);
        }

    }
    public static void Eval(object obj1, object obj2)
    {
        counter++;

        if ((!(null == obj1 && null == obj2)) && (null == obj1 || null == obj2 || !obj1.Equals(obj2)))
        {
            result = false;
            Console.WriteLine("Test Failed at location: " + counter);
            Console.WriteLine("While Comparing {0} to {1}", obj1, obj2);
        }

    }

    public static int Main()
    {
        GenC<S>.TestContext();
        GenS<S>.TestContext();
        NullableTest.Context<S>();

        if (result)
            return 0;
        else
            return 1;
    }

}
`
`
namespace A 
{
    class Foo {}
}

class Test
{
  static int Main() 
    {
        global::A.Foo foo = new global::A.Foo();
        return foo != null ? 0 : 1;
    }
}
`
`
using System;

namespace Lists
{
    public class Pair<A, B>
    {
        public virtual Pair<C,C> Diag<C>(C c){
          return null;
        }
    }

    public class Triple<A,B,C>: Pair<A,B> 
    {
        public override Pair<D,D> Diag<D>(D c){
           return null;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {   
        }
    }
}
`
`
namespace A 
{
    namespace B
    {
        class Foo {}
    }
}

class Test
{
  static int Main() 
    {
        global::A.B.Foo foo = new global::A.B.Foo();
        return foo == null ? 1 : 0;
    }
}
`
`
namespace A 
{
    namespace B
    {
        class Foo {}
    }
}

namespace C.A.B{

  class Foo{}

class Test
{
  static int Main() 
    {
        A.B.Foo foo = new A.B.Foo();
        System.Console.WriteLine(foo.GetType().FullName);
        return 0;
    }
}
}
`
C.A.B.Foo
`
namespace A 
{
    namespace B
    {
        class Foo {}
    }
}

namespace C.A.B{

  class Foo{}

class Test
{
  static int Main() 
    {
        global::A.B.Foo foo = new global::A.B.Foo();
        System.Console.WriteLine(foo.GetType().FullName);
        return 0;
    }
}
}
`
A.B.Foo
`
using System;

namespace N1
{
    class Test
    {
        public static int WhoAmI()
        {
            return 1;
        }
    }
    
    namespace N2
    {
        class Test
        {
            public static int WhoAmI()
            {
                return 12;
            }
        }

        namespace N1 
        {
            class Test
            {
                public static int WhoAmI()
                {
                    return 121;
                }

              static int Main() 
                {
                    if (global::N1.Test.WhoAmI() != 1)
                        return 1;
                    
                    if (global::N1.N2.Test.WhoAmI() != 12)
                        return 2;
                    
                    if (global::N1.N2.N1.Test.WhoAmI() != 121)
                        return 3;

                    if (N1.Test.WhoAmI() != 121)
                        return 4;

                    if (N2.Test.WhoAmI() != 12)
                        return 5;

                    if (N2.N1.Test.WhoAmI() != 121)
                        return 6;
                    
                    return 0;
                }
            }
        }
    }
}
`
`
using System;

namespace N1{
  using N1Alias = global::N1;
  
  class Test{
    public static int WhoAmI=1;
  }
  namespace N1{
    using N11 = N1Alias.N1;

    class Test{
      public static int WhoAmI=11;
    }
    namespace N1{
      using N111 = N11.N1;

      class Test{
        public static int WhoAmI=111;

        static int Main(){
          int ret = 0;
          bool N1Alias=false;
          bool N11=false;
          bool N111=false;
          if (N1Alias::Test.WhoAmI != 1){
            N1Alias=!N1Alias;
            ret =  1;
          }
          if (N11::Test.WhoAmI != 11){
            N11=!!N11;
            ret +=  10;
          }
          if (N11::N1.Test.WhoAmI != 111)
            ret +=  100;
          if (N1.Test.WhoAmI != 111)
            ret +=  1000;
          if (N11::Test.WhoAmI != 11)
            ret +=  10000;
          if (N111::Test.WhoAmI != 111){
            N111= (bool) (N111|N111);
            ret +=  100000;
          }
          return ret;
        }
      }
    }
  }
}
`
`
namespace First
{
    namespace Second
    {
        class Foo {}
        
        class Test
        {
          static int Main() 
            {
                global:: First.Second.Foo foo = new global::First.Second.Foo();
                return foo != null ? 0 : 1;
            }
        }
    }
}
`
`
using System;


[assembly:global::A]

interface I { }

class Driver:global::I
{
  static void Main() {}
}

class C<T> where T:global::I{}

class A : Attribute{}
`
`
namespace N1 
{
    interface I1
    {
        int Method();
    }
}

namespace N2
{
    class Test : N1.I1
    {
        int global::N1.I1.Method()
        {
            return 5;
        }
        
      static int Main() 
        {
            Test t = new Test();
            if (((N1.I1)t).Method() != 5)
                return 1;
            
            return 0;
        }
    }
}
`
`
using global::System.Collections;

namespace N1
{
    namespace N2
    {
        using global::System;

        class Test
        {
          static int Main() 
            {
                Console.WriteLine("XXX");
                return 0;
            }
        }
    }
}
`
XXX
`
namespace N1
{
    using globSys = global::System;
    
    namespace N2
    {
        using globSys::Collections;

        class Test
        {
          static int Main() 
            {
                object foo = new ArrayList();
                return foo is System.Collections.ArrayList ? 0 : 1;
            }
        }
    }
}
`
`
namespace N1
{
    using globSys = global::System;
    
    namespace N2
    {
        using globSyss::Collections;

        class Test
        {
          static int Main() 
            {
            }
        }
    }
}
`
(7,15): error CS0432: Alias 'globSyss' not found
`
namespace N1
{
    using globSys = global::System;
    
    namespace N2
    {
        using globSys::Collection;

        class Test
        {
          static int Main() 
            {
            }
        }
    }
}
`
(7,24): error CS0234: The type or namespace name 'Collection' does not exist in the namespace 'System' (are you missing an assembly reference?)
`
namespace N1
{
    using globSys = global::Systemm;
    
    namespace N2
    {
        class Test
        {
          static int Main() 
            {
            }
        }
    }
}
`
(3,29): error CS0400: The type or namespace name 'Systemm' could not be found in the global namespace (are you missing an assembly reference?)
`
enum E { a }

class test
{
    public static int Main()
   {
      global::E m = (global::E)-10.00;
      return 10 + (int)m;
   }
}
`
`
public class A { }
public class B : A { }


public class Test
{
  public static int F<T,U>() where T : class, U
  {
        T[] t = new T[] { };
        U[] u = t;
        return u.Length;
  }

  public static int Main()
  {
    return F<B,A>();
  }
}
`
`
using System;

public class G1<T>{}

public class Gen
{
  public Type[] infered;
  public void Method<T>(T p1)
  {
    infered = new Type[]{typeof(T)};
  }
}

public class Test
{
  public static int counter = 0;
  public static bool result = true;
  public static void Eval(bool exp)
  {
    counter++;
    if (!exp)
    {
      result = exp;
      Console.WriteLine("Test Failed at location: " + counter);
    }
  
  }

  public delegate void D<T>(T t);
  
  public static int Main()
  {
    Gen g = new Gen();

    (new D<int>(g.Method))(1);
    Test.Eval(g.infered[0].Equals(typeof(int)));

    (new D<long>(g.Method))(1L);
    Test.Eval(g.infered[0].Equals(typeof(long)));

    (new D<double>(g.Method))(1d);
    Test.Eval(g.infered[0].Equals(typeof(double)));

    (new D<string>(g.Method))("string");
    Test.Eval(g.infered[0].Equals(typeof(string)));

    (new D<G1<int>>(g.Method))(new G1<int>());
    Test.Eval(g.infered[0].Equals(typeof(G1<int>)));

    (new D<G1<G1<int>>>(g.Method))(new G1<G1<int>>());
    Test.Eval(g.infered[0].Equals(typeof(G1<G1<int>>)));
  
    if (result)
    {
      return 0;
    }
    else
    {
      return 1;
    }
  }
    
}
`
`
namespace global{}

namespace N1
{
  using System = global::System;
  interface Collections{}


    namespace N2
    {
      using Collections = System::Collections;
      class System{}

        class Test
        {
          class Collections{}

          static int Main() 
            {
                System::Console.WriteLine("XXX");
                Collections::ArrayList al = new Collections::ArrayList();
                return al.Count;
            }
        }
    }
}
`
XXX
`
using System;

public interface I<T> 
{
  I<T> this[I<T> i] { get; set; }
  I<T> GetAt(int i);
}

public class C<T> : I<T>
{
  I<T>[] Flds;

  public C(int i)
  { 
    Flds = new I<T>[i] ; 
  }
  
  public I<T> GetAt(int i)
  {
    return Flds[i];
  }
  
  public I<T> this[I<T> i]
  {
    get 
    { 
      I<T> tmp = Flds[0];
      Flds[0] = i;
      return tmp; 
    }
    set 
    { 
      Flds[0] = i;
      Flds[1] = value;
    }
  }
}

public class InterfaceConstraintContext
{
  public static void TestConstraintCallCodeGen<T,U>(T obj, T val1, T val2) where T : I<U>
  {  
    obj[val1] = val2;
    Test.Eval(obj.GetAt(0), val1);
    Test.Eval(obj.GetAt(1), val2);
  }
}

public class Test
{
  public static int counter = 0;
  public static bool result = true;
  public static void Eval(object obj1, object obj2)
  {
    counter++;

    if ( (!(null == obj1 && null == obj2)) && (null == obj1 || null == obj2 || !obj1.Equals(obj2)))
    {
      result = false;
      Console.WriteLine("Test Failed at location: " + counter);
      Console.WriteLine("While Comparing {0} to {1}", obj1, obj2);
    }
  
  }

  public static int Main()
  {
    InterfaceConstraintContext.TestConstraintCallCodeGen<C<int>, int>(new C<int>(2),new C<int>(2),new C<int>(2));
    InterfaceConstraintContext.TestConstraintCallCodeGen<C<Guid>, Guid>(new C<Guid>(2), new C<Guid>(2), new C<Guid>(2));
    InterfaceConstraintContext.TestConstraintCallCodeGen<C<double>, double>(new C<double>(2), new C<double>(2), new C<double>(2));
    InterfaceConstraintContext.TestConstraintCallCodeGen<C<string>, string>(new C<string>(2), new C<string>(2), new C<string>(2));
    InterfaceConstraintContext.TestConstraintCallCodeGen<C<object>, object>(new C<object>(2), new C<object>(2), new C<object>(2));
    
    if (result)
      return 0;
    else
      return 1;
  }
    
}
`
`
using System;

public class C
{
  public int IntFld;
}

public class Test
{
  public static int Main()
  {
    C c = new C();
    int i = (c.IntFld<int>);
    return 1;
  }
    
}
`
(13,14): error CS0307: The field 'C.IntFld' cannot be used with type arguments
(5,14): (Location of symbol related to previous error)
`
using System;

public class C
{

  public int IntProp { get {return 0;} set {} }
}


public class Test
{
  public static int Main()
  {
    C c = new C();
    int i = (c.IntProp<int>);
    return 1;
  }
    
}
`
(15,14): error CS0307: The property 'C.IntProp' cannot be used with type arguments
(6,14): (Location of symbol related to previous error)
`
using sys = global::System;

namespace N1{
  using col=sys::Collections;

  class Test{
    static int Main(){
        char col='?';

        col::ArrayList al = new col::ArrayList();
        al.Add(1);
        al.Add(2);
        al.Add(3);
                    
        foreach (sys::Int32 i in al)
        {
          sys::Console.WriteLine(i + " " + col);
        }

        return 0;
    }
  }
}
`
1 ?
2 ?
3 ?
`
namespace N1 
{
    class FooAttribute : System.Attribute {}
}
 
namespace N2
{
  using globalN1 = global::N1;

    [globalN1::Foo]
    class Test
    {
      static int Main() 
        {
            return 0;
        }
    }
}
`
`
namespace First
{
    namespace Second
    {
        using FS = Second;
        class Foo {}
        
        class Test
        {
            static int Main() 
            {
                int ret = 0;

                int Foo = 1;
                char FS = (char) ((int) 'a' + Foo);

                FS::

                    Foo foo = new FS

                                    ::Foo();

                if ((char)((int)FS - Foo) != 'a')
                    ret = 1;

                if (foo == null)
                    ret += 2;


                return ret;
            }
        }
    }
}
`
`
namespace First
{
    namespace Second
    {
        using FS = Second;
        class Foo {}
        
        class Test
        {
            static int Main() 
            {
                int ret = 0;

                int Foo = 1;
                char FS = (char) ((int) 'a' + Foo);

                FS::

                    Foo foo = new FS

                                    ::Foo();

                if ((char)((int)FS - Foo) != 'a')
                    ret = 1;

                if (ret !=0)
                    System.Console.WriteLine(ret);
                    
                if (foo == null) return 1;

                return ret;
            }
        }
    }
}
`
`
extern aliass System;
class Test
{
    static int Main()
    {
        return 0;
    }
}
`
(1,8): error CS1003: Syntax error, 'alias' expected
(1,15): error CS1002: ; expected
`
namespace N
{
    using alias = alias.alias;

    class myClass
    {
        static int Main()
        {
            myClass c = new myClass();

            return c != null ? 0 : 1;
        }
    }
}

namespace alias
{
    class alias {}
}
`
`
public interface IEnumerator<T>{}

public class TreeSet<T> {
  public IEnumerator<T> GetEnumerator() {
    return new TreeEnumerator();
  }

  private class TreeEnumerator : IEnumerator<T> {
  }
}
public class Program{public static void Main(){}}
`
`
namespace test{
  using SysIO = System.IO;
  class Test
  {
      static int Main()
      {
          SysIO.Stream s;
          return 0;
      }
  }
}
class SysIO{
}
`
`
class Test
{
    static int Main()
    {
        SysIO.Stream s;
        return 0;
    }
}
class SysIO{
}
`
(5,15): error CS0426: The type name 'Stream' does not exist in the type 'SysIO'
`
using SysIO = System.IO;
class Test
{
    static int Main()
    {
        SysIO.Stream s;
        return 0;
    }
}
class SysIO{
}
`
(6,15): error CS0426: The type name 'Stream' does not exist in the type 'SysIO'
(1,7): error CS0576: Namespace '<global namespace>' already contains a type definition for 'SysIO'
(10,7): (Location of symbol related to previous error)
`
using SysIO = System.IO;
class Test
{
    static int Main()
    {
        return 0;
    }
}
class SysIO{
}
`
`
using System.Collections.Generic;
 
  public class Pair<S>{
    public readonly S First;
    public readonly S Second;

    [Microsoft.Contracts.NotDelayed] 
    public Pair(S v) { this.First = v; this.Second = this.First; Second = v;}
 
}
 
public class M { public static void Main(){} }
`
`
using System = global;

class Test
{
    static int Main()
    {
        //global::System.Console.WriteLine("");
        return System::System.Meth();
    }
}
class global{
  public class System{
    public static int Meth(){return 0;}
  }
}
`
(8,16): error CS0431: Can't use alias 'System' with '::' since the alias references a type. Use '.' instead.
(1,1): (Location of symbol related to previous error)
`
using System = global;

class Test
{
    static int Main()
    {
        global::System.Console.WriteLine("hello");
        return 0;
    }
}
class global{
  public class System{
  }
}
`
hello
`
using System.Collections.Generic;
 
  public class Pair<S,T>{
    public readonly S First;
    public readonly T Second;
 
    public Pair(S first, T second) { 
      First = first; Second = second; 
      Pair<int,int> other = new Pair<int,int>(1,2);
      other.First = 1; //this shouldn't be legal!
    }
}
 
public class M { public static void Main(){} }
`
(10,7): error CS0191: A readonly field cannot be assigned to (except in a constructor or a variable initializer)
`
class MyBase 
{
  public virtual int foo 
    {
    get 
        {
      return 1;
    }
  }  
}

class MyDerived : MyBase 
{
  public int get_foo() 
    {
    return 2;
  }  
}

class MyDerived2 : MyDerived 
{
  public override int foo 
    {
    get 
        {
      return 3;
    }
  }

  public static int Main() 
    {
        return new MyBase().foo /*1*/+ new MyDerived().foo /*1*/+ new MyDerived().get_foo() /*2*/+ new MyDerived2().foo /*3*/+ new MyDerived2().get_foo() /*2*/- 9;
  }
}
`
`
using System;

class MyBase {
  public static int intI = 2;
  ~MyBase() {
    intI = intI * 2;
  }
}

class MyClass : MyBase{

  ~MyClass() {
    intI = intI + 2;
  }

  public static int Main() {
    MyClass mc = new MyClass();
    mc = null;
    GC.Collect();
    GC.WaitForPendingFinalizers();
    if (intI == 8) {
      return 0;
    }
    else {
      return mc == null ? 1 : 2;
    }
  }
}
`
`
using Microsoft.Contracts;

public class EMap<T, Data> where T: class {

    private Node listHead;

    public EMap() {
        this.listHead = new Node(null, default(Data), this);
    }

    // we only want type visibility outside NewESet, but not member accessibility
    public class Node {
        internal Node next;

        internal Node(T ep, Data data, [Delayed] EMap<T, Data> parent) {
            this.next = this;
        }
    }
}    
public class M { public static void Main(){} }
`
`
// Check that conditional uses of variables are okay
using System;
using System.Diagnostics;
public class T {

  [Conditional("Foo")]
  static void IgnoreMe(int x) {
    Console.WriteLine("IgnoreMe called");
  }
  
  public static void Main() {
    int x = 5;
    IgnoreMe(x);
  }
}
`
`
using System;

extern class C1 {}
extern struct S1 {}

namespace N {
    extern class C2 {}
    extern struct S2 {}
}

class Test {
  static void Main() {}
}
`
(3,1): error CS0439: An extern alias declaration must precede all other namespace elements
(3,8): error CS1003: Syntax error, 'alias' expected
(4,1): error CS1519: Invalid token 'extern' in class, struct, or interface member declaration
(7,12): error CS1003: Syntax error, 'alias' expected
(8,5): error CS1519: Invalid token 'extern' in class, struct, or interface member declaration
`
using System;

public class SpecializedSubGenericClassInt : GenericClass<int>
{

  public SpecializedSubGenericClassInt() : base() {}
  public SpecializedSubGenericClassInt(int t) : base(t) {}
  public SpecializedSubGenericClassInt(GC1<int> g) : base(g) {}
  

  public static void TestCtors(int t)
  {
    new SpecializedSubGenericClassInt();
    Test.Eval(String.Format("GenericClass[{0}].ctor()",typeof(int)), TestVerificationStore.LastAction);

    new SpecializedSubGenericClassInt(t);
    Test.Eval(String.Format("GenericClass[{0}].ctor(T)",typeof(int)), TestVerificationStore.LastAction);
    
    new SpecializedSubGenericClassInt(new GC1<int>(t));
    Test.Eval(String.Format("GenericClass[{0}].ctor(GC1<T>)",typeof(int)), TestVerificationStore.LastAction);
  }
  
  public void TestBaseMemberAccessWithNoQualifiers(int TestValue)
  {
    Fld1 = TestValue;
    Test.Eval(TestValue,Fld1);

    sFld1 = TestValue;
    Test.Eval(TestValue,sFld1);

    Fld2 = new GC1<int>(TestValue);
    Test.Eval(new GC1<int>(TestValue),Fld2);

    sFld2 = new GC1<int>(TestValue);
    Test.Eval(new GC1<int>(TestValue),sFld2);

    Fld3 = new GS1<int>(TestValue);
    Test.Eval(new GS1<int>(TestValue),Fld3);

    sFld3 = new GS1<int>(TestValue);
    Test.Eval(new GS1<int>(TestValue),sFld3);

    int t;
  
    Prop1 = default(int);
    Test.Eval(String.Format("GenericClass[{0}].Prop1.set",typeof(int)), TestVerificationStore.LastAction);

    t = Prop1;
    Test.Eval(String.Format("GenericClass[{0}].Prop1.get",typeof(int)), TestVerificationStore.LastAction);

    vProp1 = default(int);
    Test.Eval(String.Format("GenericClass[{0}].vProp1.set",typeof(int)), TestVerificationStore.LastAction);

    t = vProp1;
    Test.Eval(String.Format("GenericClass[{0}].vProp1.get",typeof(int)), TestVerificationStore.LastAction);

    sProp1 = default(int);
    Test.Eval(String.Format("GenericClass[{0}].sProp1.set",typeof(int)), TestVerificationStore.LastAction);

    t = sProp1;
    Test.Eval(String.Format("GenericClass[{0}].sProp1.get",typeof(int)), TestVerificationStore.LastAction);


    GC1<int> gc1t;
    
    Prop2 = default(GC1<int>);
    Test.Eval(String.Format("GenericClass[{0}].Prop2.set",typeof(int)), TestVerificationStore.LastAction);

    gc1t = Prop2;
    Test.Eval(String.Format("GenericClass[{0}].Prop2.get",typeof(int)), TestVerificationStore.LastAction);

    vProp2 = default(GC1<int>);
    Test.Eval(String.Format("GenericClass[{0}].vProp2.set",typeof(int)), TestVerificationStore.LastAction);

    gc1t = vProp2;
    Test.Eval(String.Format("GenericClass[{0}].vProp2.get",typeof(int)), TestVerificationStore.LastAction);

    sProp2 = default(GC1<int>);
    Test.Eval(String.Format("GenericClass[{0}].sProp2.set",typeof(int)), TestVerificationStore.LastAction);

    gc1t = sProp2;
    Test.Eval(String.Format("GenericClass[{0}].sProp2.get",typeof(int)), TestVerificationStore.LastAction);

    GS1<int> gs1t;
    
    Prop3 = default(GS1<int>);
    Test.Eval(String.Format("GenericClass[{0}].Prop3.set",typeof(int)), TestVerificationStore.LastAction);

    gs1t = Prop3;
    Test.Eval(String.Format("GenericClass[{0}].Prop3.get",typeof(int)), TestVerificationStore.LastAction);

    vProp3 = default(GS1<int>);
    Test.Eval(String.Format("GenericClass[{0}].vProp3.set",typeof(int)), TestVerificationStore.LastAction);

    gs1t = vProp3;
    Test.Eval(String.Format("GenericClass[{0}].vProp3.get",typeof(int)), TestVerificationStore.LastAction);

    sProp3 = default(GS1<int>);
    Test.Eval(String.Format("GenericClass[{0}].sProp3.set",typeof(int)), TestVerificationStore.LastAction);

    gs1t = sProp3;
    Test.Eval(String.Format("GenericClass[{0}].sProp3.get",typeof(int)), TestVerificationStore.LastAction);

    Ev += (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].Ev.add",typeof(int)), TestVerificationStore.LastAction);

    Ev -= (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].Ev.remove",typeof(int)), TestVerificationStore.LastAction);

    vEv += (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].vEv.add",typeof(int)), TestVerificationStore.LastAction);

    vEv -= (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].vEv.remove",typeof(int)), TestVerificationStore.LastAction);

    sEv += (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].sEv.add",typeof(int)), TestVerificationStore.LastAction);

    sEv -= (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].sEv.remove",typeof(int)), TestVerificationStore.LastAction);

    GenDlg<GC1<int>> DFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].FldEv",typeof(int));return x;};
    GenDlg<GC1<int>> DvFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].vFldEv",typeof(int));return x;};
    GenDlg<GC1<int>> DsFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].sFldEv",typeof(int));return x;};
    
    FldEv += DFldEv;
    FireFldEv();
    Test.Eval(String.Format("GenericClass[{0}].FldEv",typeof(int)), TestVerificationStore.LastAction);
    FldEv -= DFldEv;
    try { FireFldEv(); }
    catch (NullReferenceException ) { }
    catch (Exception E) {Test.Eval("Catch NullReferenceException on FldEv",E);}

        
    vFldEv += DvFldEv;
    FirevFldEv();
    Test.Eval(String.Format("GenericClass[{0}].vFldEv",typeof(int)), TestVerificationStore.LastAction);
    vFldEv -= DvFldEv;
    try { FirevFldEv(); }
    catch (NullReferenceException ) { }
    catch (Exception E) {Test.Eval("Catch NullReferenceException on vFldEv",E);}

        
    sFldEv += DsFldEv;
    FiresFldEv();
    Test.Eval(String.Format("GenericClass[{0}].sFldEv",typeof(int)), TestVerificationStore.LastAction);
    sFldEv -= DsFldEv;
    try { FiresFldEv(); }
    catch (NullReferenceException ) { }
    catch (Exception E) {Test.Eval("Catch NullReferenceException on sFldEv",E);}

    Meth1(TestValue);
    Test.Eval(String.Format("GenericClass[{0}].Meth1",typeof(int)),TestVerificationStore.LastAction);

    vMeth1(TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth1",typeof(int)),TestVerificationStore.LastAction);

    sMeth1(TestValue);
    Test.Eval(String.Format("GenericClass[{0}].sMeth1",typeof(int)),TestVerificationStore.LastAction);
    
    Meth2(out TestValue);
    Test.Eval(String.Format("GenericClass[{0}].Meth2",typeof(int)),TestVerificationStore.LastAction);

    vMeth2(out TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth2",typeof(int)),TestVerificationStore.LastAction);

    sMeth2(out TestValue);
    Test.Eval(String.Format("GenericClass[{0}].sMeth2",typeof(int)),TestVerificationStore.LastAction);

    Meth3(ref TestValue);
    Test.Eval(String.Format("GenericClass[{0}].Meth3",typeof(int)),TestVerificationStore.LastAction);

    vMeth3(ref TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth3",typeof(int)),TestVerificationStore.LastAction);

    sMeth3(ref TestValue);
    Test.Eval(String.Format("GenericClass[{0}].sMeth3",typeof(int)),TestVerificationStore.LastAction);

    GC1<int> GC1TVal = default(GC1<int>);
    
    Meth4(GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].Meth4",typeof(int)),TestVerificationStore.LastAction);

    vMeth4(GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth4",typeof(int)),TestVerificationStore.LastAction);

    sMeth4(GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].sMeth4",typeof(int)),TestVerificationStore.LastAction);

    Meth5(out GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].Meth5",typeof(int)),TestVerificationStore.LastAction);

    vMeth5(out GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth5",typeof(int)),TestVerificationStore.LastAction);

    sMeth5(out GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].sMeth5",typeof(int)),TestVerificationStore.LastAction);

    Meth6(ref GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].Meth6",typeof(int)),TestVerificationStore.LastAction);

    vMeth6(ref GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth6",typeof(int)),TestVerificationStore.LastAction);

    sMeth6(ref GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].sMeth6",typeof(int)),TestVerificationStore.LastAction);

    int[] TArr = new int[] {};
    
    Meth7(TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth7",typeof(int)),TestVerificationStore.LastAction);

    vMeth7(TArr);
    Test.Eval(String.Format("GenericClass[{0}].vMeth7",typeof(int)),TestVerificationStore.LastAction);

    sMeth7(TArr);
    Test.Eval(String.Format("GenericClass[{0}].sMeth7",typeof(int)),TestVerificationStore.LastAction);

    Meth8(out TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth8",typeof(int)),TestVerificationStore.LastAction);

    vMeth8(out TArr);
    Test.Eval(String.Format("GenericClass[{0}].vMeth8",typeof(int)),TestVerificationStore.LastAction);

    sMeth8(out TArr);
    Test.Eval(String.Format("GenericClass[{0}].sMeth8",typeof(int)),TestVerificationStore.LastAction);

    Meth9(ref TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth9",typeof(int)),TestVerificationStore.LastAction);

    vMeth9(ref TArr);
    Test.Eval(String.Format("GenericClass[{0}].vMeth9",typeof(int)),TestVerificationStore.LastAction);

    sMeth9(ref TArr);
    Test.Eval(String.Format("GenericClass[{0}].sMeth9",typeof(int)),TestVerificationStore.LastAction);

    Meth10(TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth10",typeof(int)),TestVerificationStore.LastAction);

    vMeth10(TestValue, TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth10",typeof(int)),TestVerificationStore.LastAction);

    sMeth10();
    Test.Eval(String.Format("GenericClass[{0}].sMeth10",typeof(int)),TestVerificationStore.LastAction);

    Meth11(new GC1<int>[]{});
    Test.Eval(String.Format("GenericClass[{0}].Meth11",typeof(int)),TestVerificationStore.LastAction);

    vMeth11(GC1TVal, GC1TVal, GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth11",typeof(int)),TestVerificationStore.LastAction);

    sMeth11();
    Test.Eval(String.Format("GenericClass[{0}].sMeth11",typeof(int)),TestVerificationStore.LastAction);

    GenericClass<int> GenericClassT;

    GenericClassT = new SpecializedSubGenericClassInt() + new SpecializedSubGenericClassInt();
    Test.Eval(String.Format("GenericClass[{0}].op_Addition",typeof(int)),TestVerificationStore.LastAction);

    GenericClassT++;
    Test.Eval(String.Format("GenericClass[{0}].op_incr",typeof(int)),TestVerificationStore.LastAction);

    if (GenericClassT) 
    {
      Test.Eval(String.Format("GenericClass[{0}].op_true",typeof(int)),TestVerificationStore.LastAction);
    }

    if (((GenericClass<int>)null) && new SpecializedSubGenericClassInt()) 
    {
      Test.Eval(String.Format("GenericClass[{0}].op_false",typeof(int)),TestVerificationStore.LastAction);
    }
    
    GC1<int> GenericClassGC1T = default(GenericClass<int>);
    GS1<int> GenericClassGS1T = (GS1<int>) default(GenericClass<int>);

  }

  public void TestBaseMemberAccessWithBaseQualifier(int TestValue)
  {
    base.Fld1 = TestValue;
    Test.Eval(TestValue,base.Fld1);

    base.Fld2 = new GC1<int>(TestValue);
    Test.Eval(new GC1<int>(TestValue),base.Fld2);

    base.Fld3 = new GS1<int>(TestValue);
    Test.Eval(new GS1<int>(TestValue),base.Fld3);

    int t;
    GC1<int> GC1TVal = default(GC1<int>);
    GS1<int> GS1TVal = default(GS1<int>);

    base.Prop1 = default(int);
    Test.Eval(String.Format("GenericClass[{0}].Prop1.set",typeof(int)), TestVerificationStore.LastAction);

    t = base.Prop1;
    Test.Eval(String.Format("GenericClass[{0}].Prop1.get",typeof(int)), TestVerificationStore.LastAction);

    base.vProp1 = default(int);
    Test.Eval(String.Format("GenericClass[{0}].vProp1.set",typeof(int)), TestVerificationStore.LastAction);

    t = base.vProp1;
    Test.Eval(String.Format("GenericClass[{0}].vProp1.get",typeof(int)), TestVerificationStore.LastAction);

    GC1<int> gc1t;
    
    base.Prop2 = default(GC1<int>);
    Test.Eval(String.Format("GenericClass[{0}].Prop2.set",typeof(int)), TestVerificationStore.LastAction);

    gc1t = base.Prop2;
    Test.Eval(String.Format("GenericClass[{0}].Prop2.get",typeof(int)), TestVerificationStore.LastAction);

    base.vProp2 = default(GC1<int>);
    Test.Eval(String.Format("GenericClass[{0}].vProp2.set",typeof(int)), TestVerificationStore.LastAction);

    gc1t = base.vProp2;
    Test.Eval(String.Format("GenericClass[{0}].vProp2.get",typeof(int)), TestVerificationStore.LastAction);

    GS1<int> gs1t;
    
    base.Prop3 = default(GS1<int>);
    Test.Eval(String.Format("GenericClass[{0}].Prop3.set",typeof(int)), TestVerificationStore.LastAction);

    gs1t = base.Prop3;
    Test.Eval(String.Format("GenericClass[{0}].Prop3.get",typeof(int)), TestVerificationStore.LastAction);

    base.vProp3 = default(GS1<int>);
    Test.Eval(String.Format("GenericClass[{0}].vProp3.set",typeof(int)), TestVerificationStore.LastAction);

    gs1t = base.vProp3;
    Test.Eval(String.Format("GenericClass[{0}].vProp3.get",typeof(int)), TestVerificationStore.LastAction);

    base[1] = TestValue;
    Test.Eval(String.Format("GenericClass[{0}].this1.set",typeof(int)), TestVerificationStore.LastAction);
  
    TestValue = base[1];
    Test.Eval(String.Format("GenericClass[{0}].this1.get",typeof(int)), TestVerificationStore.LastAction);
  
    base[GC1TVal,TestValue] = GC1TVal;
    Test.Eval(String.Format("GenericClass[{0}].this2.set",typeof(int)), TestVerificationStore.LastAction);
  
    GC1TVal = base[GC1TVal,TestValue];
    Test.Eval(String.Format("GenericClass[{0}].this2.get",typeof(int)), TestVerificationStore.LastAction);
  
    base[GS1TVal] = TestValue;
    Test.Eval(String.Format("GenericClass[{0}].vthis1.set",typeof(int)), TestVerificationStore.LastAction);
  
    TestValue = base[GS1TVal];
    Test.Eval(String.Format("GenericClass[{0}].vthis1.get",typeof(int)), TestVerificationStore.LastAction);

    base["1",TestValue] = GC1TVal;
    Test.Eval(String.Format("GenericClass[{0}].vthis2.set",typeof(int)), TestVerificationStore.LastAction);
  
    GC1TVal = base["1",TestValue];
    Test.Eval(String.Format("GenericClass[{0}].vthis2.get",typeof(int)), TestVerificationStore.LastAction);
  
    base.Ev += (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].Ev.add",typeof(int)), TestVerificationStore.LastAction);

    base.Ev -= (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].Ev.remove",typeof(int)), TestVerificationStore.LastAction);

    base.vEv += (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].vEv.add",typeof(int)), TestVerificationStore.LastAction);

    base.vEv -= (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].vEv.remove",typeof(int)), TestVerificationStore.LastAction);

    GenDlg<GC1<int>> DFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].FldEv",typeof(int));return x;};
    GenDlg<GC1<int>> DvFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].vFldEv",typeof(int));return x;};
    GenDlg<GC1<int>> DsFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].sFldEv",typeof(int));return x;};
    
    base.FldEv += DFldEv;
    FireFldEv();
    Test.Eval(String.Format("GenericClass[{0}].FldEv",typeof(int)), TestVerificationStore.LastAction);
    base.FldEv -= DFldEv;
    try { FireFldEv(); }
    catch (NullReferenceException ) { }
    catch (Exception E) {Test.Eval("Catch NullReferenceException on FldEv",E);}

        
    base.vFldEv += DvFldEv;
    FirevFldEv();
    Test.Eval(String.Format("GenericClass[{0}].vFldEv",typeof(int)), TestVerificationStore.LastAction);
    base.vFldEv -= DvFldEv;
    try { FirevFldEv(); }
    catch (NullReferenceException ) { }
    catch (Exception E) {Test.Eval("Catch NullReferenceException on vFldEv",E);}

    base.Meth1(TestValue);
    Test.Eval(String.Format("GenericClass[{0}].Meth1",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth1(TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth1",typeof(int)),TestVerificationStore.LastAction);
    
    base.Meth2(out TestValue);
    Test.Eval(String.Format("GenericClass[{0}].Meth2",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth2(out TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth2",typeof(int)),TestVerificationStore.LastAction);

    base.Meth3(ref TestValue);
    Test.Eval(String.Format("GenericClass[{0}].Meth3",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth3(ref TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth3",typeof(int)),TestVerificationStore.LastAction);

    GC1TVal = default(GC1<int>);
    
    base.Meth4(GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].Meth4",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth4(GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth4",typeof(int)),TestVerificationStore.LastAction);

    base.Meth5(out GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].Meth5",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth5(out GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth5",typeof(int)),TestVerificationStore.LastAction);

    base.Meth6(ref GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].Meth6",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth6(ref GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth6",typeof(int)),TestVerificationStore.LastAction);

    int[] TArr = new int[] {};
    
    base.Meth7(TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth7",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth7(TArr);
    Test.Eval(String.Format("GenericClass[{0}].vMeth7",typeof(int)),TestVerificationStore.LastAction);
    
    base.Meth8(out TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth8",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth8(out TArr);
    Test.Eval(String.Format("GenericClass[{0}].vMeth8",typeof(int)),TestVerificationStore.LastAction);

    base.Meth9(ref TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth9",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth9(ref TArr);
    Test.Eval(String.Format("GenericClass[{0}].vMeth9",typeof(int)),TestVerificationStore.LastAction);

    base.Meth10(TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth10",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth10(TestValue, TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth10",typeof(int)),TestVerificationStore.LastAction);

    base.Meth11(new GC1<int>[]{});
    Test.Eval(String.Format("GenericClass[{0}].Meth11",typeof(int)),TestVerificationStore.LastAction);

    base.vMeth11(GC1TVal, GC1TVal, GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth11",typeof(int)),TestVerificationStore.LastAction);
  }  

  public void TestBaseMemberAccessWithThisQualifier(int TestValue)
  {
    this.Fld1 = TestValue;
    Test.Eval(TestValue,this.Fld1);

    this.Fld2 = new GC1<int>(TestValue);
    Test.Eval(new GC1<int>(TestValue),this.Fld2);

    this.Fld3 = new GS1<int>(TestValue);
    Test.Eval(new GS1<int>(TestValue),this.Fld3);

    int t;
    GC1<int> GC1TVal = default(GC1<int>);
    GS1<int> GS1TVal = default(GS1<int>);

    this.Prop1 = default(int);
    Test.Eval(String.Format("GenericClass[{0}].Prop1.set",typeof(int)), TestVerificationStore.LastAction);

    t = this.Prop1;
    Test.Eval(String.Format("GenericClass[{0}].Prop1.get",typeof(int)), TestVerificationStore.LastAction);

    this.vProp1 = default(int);
    Test.Eval(String.Format("GenericClass[{0}].vProp1.set",typeof(int)), TestVerificationStore.LastAction);

    t = this.vProp1;
    Test.Eval(String.Format("GenericClass[{0}].vProp1.get",typeof(int)), TestVerificationStore.LastAction);

    GC1<int> gc1t;
    
    this.Prop2 = default(GC1<int>);
    Test.Eval(String.Format("GenericClass[{0}].Prop2.set",typeof(int)), TestVerificationStore.LastAction);

    gc1t = this.Prop2;
    Test.Eval(String.Format("GenericClass[{0}].Prop2.get",typeof(int)), TestVerificationStore.LastAction);

    this.vProp2 = default(GC1<int>);
    Test.Eval(String.Format("GenericClass[{0}].vProp2.set",typeof(int)), TestVerificationStore.LastAction);

    gc1t = this.vProp2;
    Test.Eval(String.Format("GenericClass[{0}].vProp2.get",typeof(int)), TestVerificationStore.LastAction);

    GS1<int> gs1t;
    
    this.Prop3 = default(GS1<int>);
    Test.Eval(String.Format("GenericClass[{0}].Prop3.set",typeof(int)), TestVerificationStore.LastAction);

    gs1t = this.Prop3;
    Test.Eval(String.Format("GenericClass[{0}].Prop3.get",typeof(int)), TestVerificationStore.LastAction);

    this.vProp3 = default(GS1<int>);
    Test.Eval(String.Format("GenericClass[{0}].vProp3.set",typeof(int)), TestVerificationStore.LastAction);

    gs1t = this.vProp3;
    Test.Eval(String.Format("GenericClass[{0}].vProp3.get",typeof(int)), TestVerificationStore.LastAction);

    this[1] = TestValue;
    Test.Eval(String.Format("GenericClass[{0}].this1.set",typeof(int)), TestVerificationStore.LastAction);
  
    TestValue = this[1];
    Test.Eval(String.Format("GenericClass[{0}].this1.get",typeof(int)), TestVerificationStore.LastAction);
  
    this[GC1TVal,TestValue] = GC1TVal;
    Test.Eval(String.Format("GenericClass[{0}].this2.set",typeof(int)), TestVerificationStore.LastAction);
  
    GC1TVal = this[GC1TVal,TestValue];
    Test.Eval(String.Format("GenericClass[{0}].this2.get",typeof(int)), TestVerificationStore.LastAction);
  
    this[GS1TVal] = TestValue;
    Test.Eval(String.Format("GenericClass[{0}].vthis1.set",typeof(int)), TestVerificationStore.LastAction);
  
    TestValue = this[GS1TVal];
    Test.Eval(String.Format("GenericClass[{0}].vthis1.get",typeof(int)), TestVerificationStore.LastAction);

    this["1",TestValue] = GC1TVal;
    Test.Eval(String.Format("GenericClass[{0}].vthis2.set",typeof(int)), TestVerificationStore.LastAction);
  
    GC1TVal = this["1",TestValue];
    Test.Eval(String.Format("GenericClass[{0}].vthis2.get",typeof(int)), TestVerificationStore.LastAction);

    this.Ev += (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].Ev.add",typeof(int)), TestVerificationStore.LastAction);

    this.Ev -= (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].Ev.remove",typeof(int)), TestVerificationStore.LastAction);

    this.vEv += (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].vEv.add",typeof(int)), TestVerificationStore.LastAction);

    this.vEv -= (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].vEv.remove",typeof(int)), TestVerificationStore.LastAction);

    GenDlg<GC1<int>> DFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].FldEv",typeof(int));return x;};
    GenDlg<GC1<int>> DvFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].vFldEv",typeof(int));return x;};
    GenDlg<GC1<int>> DsFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].sFldEv",typeof(int));return x;};
    
    this.FldEv += DFldEv;
    FireFldEv();
    Test.Eval(String.Format("GenericClass[{0}].FldEv",typeof(int)), TestVerificationStore.LastAction);
    this.FldEv -= DFldEv;
    try { FireFldEv(); }
    catch (NullReferenceException ) { }
    catch (Exception E) {Test.Eval("Catch NullReferenceException on FldEv",E);}

        
    this.vFldEv += DvFldEv;
    FirevFldEv();
    Test.Eval(String.Format("GenericClass[{0}].vFldEv",typeof(int)), TestVerificationStore.LastAction);
    this.vFldEv -= DvFldEv;
    try { FirevFldEv(); }
    catch (NullReferenceException ) { }
    catch (Exception E) {Test.Eval("Catch NullReferenceException on vFldEv",E);}

    this.Meth1(TestValue);
    Test.Eval(String.Format("GenericClass[{0}].Meth1",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth1(TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth1",typeof(int)),TestVerificationStore.LastAction);
    
    this.Meth2(out TestValue);
    Test.Eval(String.Format("GenericClass[{0}].Meth2",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth2(out TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth2",typeof(int)),TestVerificationStore.LastAction);

    this.Meth3(ref TestValue);
    Test.Eval(String.Format("GenericClass[{0}].Meth3",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth3(ref TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth3",typeof(int)),TestVerificationStore.LastAction);

    GC1TVal = default(GC1<int>);
    
    this.Meth4(GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].Meth4",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth4(GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth4",typeof(int)),TestVerificationStore.LastAction);

    this.Meth5(out GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].Meth5",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth5(out GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth5",typeof(int)),TestVerificationStore.LastAction);

    this.Meth6(ref GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].Meth6",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth6(ref GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth6",typeof(int)),TestVerificationStore.LastAction);

    int[] TArr = new int[] {};
    
    this.Meth7(TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth7",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth7(TArr);
    Test.Eval(String.Format("GenericClass[{0}].vMeth7",typeof(int)),TestVerificationStore.LastAction);
    
    this.Meth8(out TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth8",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth8(out TArr);
    Test.Eval(String.Format("GenericClass[{0}].vMeth8",typeof(int)),TestVerificationStore.LastAction);

    this.Meth9(ref TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth9",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth9(ref TArr);
    Test.Eval(String.Format("GenericClass[{0}].vMeth9",typeof(int)),TestVerificationStore.LastAction);

    this.Meth10(TArr);
    Test.Eval(String.Format("GenericClass[{0}].Meth10",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth10(TestValue, TestValue);
    Test.Eval(String.Format("GenericClass[{0}].vMeth10",typeof(int)),TestVerificationStore.LastAction);

    this.Meth11(new GC1<int>[]{});
    Test.Eval(String.Format("GenericClass[{0}].Meth11",typeof(int)),TestVerificationStore.LastAction);

    this.vMeth11(GC1TVal, GC1TVal, GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].vMeth11",typeof(int)),TestVerificationStore.LastAction);

  }  

  public void TestBaseStaticMemberAccessWithBaseNameQualifier(int TestValue)
  {
    GenericClass<int>.sFld1 = TestValue;
    Test.Eval(TestValue,GenericClass<int>.sFld1);

    GenericClass<int>.sFld2 = new GC1<int>(TestValue);
    Test.Eval(new GC1<int>(TestValue),GenericClass<int>.sFld2);

    GenericClass<int>.sFld3 = new GS1<int>(TestValue);
    Test.Eval(new GS1<int>(TestValue),GenericClass<int>.sFld3);

    int t;

    GenericClass<int>.sProp1 = default(int);
    Test.Eval(String.Format("GenericClass[{0}].sProp1.set",typeof(int)), TestVerificationStore.LastAction);

    t = GenericClass<int>.sProp1;
    Test.Eval(String.Format("GenericClass[{0}].sProp1.get",typeof(int)), TestVerificationStore.LastAction);

    GC1<int> gc1t;
    
    GenericClass<int>.sProp2 = default(GC1<int>);
    Test.Eval(String.Format("GenericClass[{0}].sProp2.set",typeof(int)), TestVerificationStore.LastAction);

    gc1t = GenericClass<int>.sProp2;
    Test.Eval(String.Format("GenericClass[{0}].sProp2.get",typeof(int)), TestVerificationStore.LastAction);

    GS1<int> gs1t;

    GenericClass<int>.sProp3 = default(GS1<int>);
    Test.Eval(String.Format("GenericClass[{0}].sProp3.set",typeof(int)), TestVerificationStore.LastAction);

    gs1t = GenericClass<int>.sProp3;
    Test.Eval(String.Format("GenericClass[{0}].sProp3.get",typeof(int)), TestVerificationStore.LastAction);

    GenericClass<int>.sEv += (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].sEv.add",typeof(int)), TestVerificationStore.LastAction);

    GenericClass<int>.sEv -= (GenDlg<int>)null;
    Test.Eval(String.Format("GenericClass[{0}].sEv.remove",typeof(int)), TestVerificationStore.LastAction);

    GenDlg<GC1<int>> DFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].FldEv",typeof(int));return x;};
    GenDlg<GC1<int>> DvFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].vFldEv",typeof(int));return x;};
    GenDlg<GC1<int>> DsFldEv = delegate(GC1<int> x){TestVerificationStore.SetLastAction("GenericClass[{0}].sFldEv",typeof(int));return x;};
            
    GenericClass<int>.sFldEv += DsFldEv;
    FiresFldEv();
    Test.Eval(String.Format("GenericClass[{0}].sFldEv",typeof(int)), TestVerificationStore.LastAction);
    GenericClass<int>.sFldEv -= DsFldEv;
    try { FiresFldEv(); }
    catch (NullReferenceException ) { }
    catch (Exception E) {Test.Eval("Catch NullReferenceException on sFldEv",E);}

    GenericClass<int>.sMeth1(TestValue);
    Test.Eval(String.Format("GenericClass[{0}].sMeth1",typeof(int)),TestVerificationStore.LastAction);
    
    GenericClass<int>.sMeth2(out TestValue);
    Test.Eval(String.Format("GenericClass[{0}].sMeth2",typeof(int)),TestVerificationStore.LastAction);

    GenericClass<int>.sMeth3(ref TestValue);
    Test.Eval(String.Format("GenericClass[{0}].sMeth3",typeof(int)),TestVerificationStore.LastAction);

    GC1<int> GC1TVal = default(GC1<int>);
    
    GenericClass<int>.sMeth4(GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].sMeth4",typeof(int)),TestVerificationStore.LastAction);

    GenericClass<int>.sMeth5(out GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].sMeth5",typeof(int)),TestVerificationStore.LastAction);

    GenericClass<int>.sMeth6(ref GC1TVal);
    Test.Eval(String.Format("GenericClass[{0}].sMeth6",typeof(int)),TestVerificationStore.LastAction);

    int[] TArr = new int[] {};
    
    GenericClass<int>.sMeth7(TArr);
    Test.Eval(String.Format("GenericClass[{0}].sMeth7",typeof(int)),TestVerificationStore.LastAction);

    GenericClass<int>.sMeth8(out TArr);
    Test.Eval(String.Format("GenericClass[{0}].sMeth8",typeof(int)),TestVerificationStore.LastAction);

    GenericClass<int>.sMeth9(ref TArr);
    Test.Eval(String.Format("GenericClass[{0}].sMeth9",typeof(int)),TestVerificationStore.LastAction);

    GenericClass<int>.sMeth10();
    Test.Eval(String.Format("GenericClass[{0}].sMeth10",typeof(int)),TestVerificationStore.LastAction);

    GenericClass<int>.sMeth11();
    Test.Eval(String.Format("GenericClass[{0}].sMeth11",typeof(int)),TestVerificationStore.LastAction);

  }

  public void TestNestedTypeBaseMemberAccess()
  {
    #pragma warning disable 219
    GenericClass<int>.NestedClass NC = default(NestedClass);
    GenericClass<int>.NestedStruct NS = default(NestedStruct);
    GenericClass<int>.NestedInterface NI = default(NestedInterface);
    GenericClass<int>.NestedEnum NE = default(NestedEnum);
    GenericClass<int>.NestedDelegate ND = default(NestedDelegate);
    #pragma warning restore 219
  }
  
}
public class Test
{
  public static int counter = 0;
  public static bool result = true;
  public static void Eval(object obj1, object obj2)
  {
    counter++;

    if ( (!(null == obj1 && null == obj2)) && (null == obj1 || null == obj2 || !obj1.Equals(obj2)))
    {
      result = false;
      Console.WriteLine("Test Failed at location: " + counter);
      Console.WriteLine("Expected: [{0}]\nGot: [{1}]\n", obj1, obj2);
    }
  }

  public static int Main()
  {
    SpecializedSubGenericClassInt.TestCtors(1);
    
    new SpecializedSubGenericClassInt().TestBaseMemberAccessWithNoQualifiers(1);
    new SpecializedSubGenericClassInt().TestBaseMemberAccessWithBaseQualifier(1);
    new SpecializedSubGenericClassInt().TestBaseMemberAccessWithThisQualifier(1);
    new SpecializedSubGenericClassInt().TestBaseStaticMemberAccessWithBaseNameQualifier(1);
    new SpecializedSubGenericClassInt().TestNestedTypeBaseMemberAccess();
    
              if (result)
              {
      return 0;
    }
    else
    {
      return 1;
    }
  }
}

// </Code>
// Define the generic class to be used as base


public delegate T GenDlg<T>(T t);
public delegate string Dlg(string s);

public interface GI1<T> {}
public class GC1<T>
{
  T t;
  public GC1(T t) {this.t = t;}
  public override bool Equals(object obj) 
  { 
    return (obj != null && obj.GetType().Equals(typeof(GC1<T>)) && ((((GC1<T>)obj).t == null && t == null) || ((GC1<T>)obj).t != null && ((GC1<T>)obj).t.Equals(t)));
  }
  public override int GetHashCode() {return base.GetHashCode();}

}

public struct GS1<T>
{
  T t;
  public GS1(T t) {this.t = t;}
  public override bool Equals(object obj) 
  { 
    return (obj != null && obj.GetType().Equals(typeof(GS1<T>)) && ((((GS1<T>)obj).t == null && t == null) || ((GS1<T>)obj).t != null && ((GS1<T>)obj).t.Equals(t)));
  }  
  public override int GetHashCode() {return base.GetHashCode();}
}

public class TestVerificationStore
{
  public static string LastAction;
  public static void SetLastAction(string format, params object[] args) 
  { 
    LastAction = String.Format(format, args); 
  }
}

public class GenericClass<T>
{
  protected GenericClass()
  {
    TestVerificationStore.SetLastAction("GenericClass[{0}].ctor()",typeof(T));
  }
  
  protected GenericClass(T t)
  {
    TestVerificationStore.SetLastAction("GenericClass[{0}].ctor(T)",typeof(T));
  }
  protected GenericClass(GC1<T> G)
  {
    TestVerificationStore.SetLastAction("GenericClass[{0}].ctor(GC1<T>)",typeof(T));
  }
  
  protected T Fld1;
  protected static T sFld1;

  protected GC1<T> Fld2;
  protected static GC1<T> sFld2;

  protected GS1<T> Fld3;
  protected static GS1<T> sFld3;

  protected T Prop1
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].Prop1.get",typeof(T));
      return Fld1; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].Prop1.set",typeof(T));
      Fld1 = value; 
    } 
  }
  
  protected virtual T vProp1
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vProp1.get",typeof(T));
      return Fld1; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vProp1.set",typeof(T));
      Fld1 = value; 
    } 
  }

  protected static T sProp1
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].sProp1.get",typeof(T));
      return sFld1; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].sProp1.set",typeof(T));
      sFld1 = value; 
    } 
  }

  protected GC1<T> Prop2
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].Prop2.get",typeof(T));
      return Fld2; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].Prop2.set",typeof(T));
      Fld2 = value; 
    } 
  }
  
  protected virtual GC1<T> vProp2 
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vProp2.get",typeof(T));
      return Fld2; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vProp2.set",typeof(T));
      Fld2 = value; 
    } 
  }

  protected static GC1<T> sProp2
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].sProp2.get",typeof(T));
      return sFld2; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].sProp2.set",typeof(T));
      sFld2 = value; 
    } 
  }

  protected GS1<T> Prop3
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].Prop3.get",typeof(T));
      return Fld3; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].Prop3.set",typeof(T));
      Fld3 = value; 
    } 
  }
  
  protected virtual GS1<T> vProp3 
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vProp3.get",typeof(T));
      return Fld3; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vProp3.set",typeof(T));
      Fld3 = value; 
    } 
  }

  protected static GS1<T> sProp3
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].sProp3.get",typeof(T));
      return sFld3; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].sProp3.set",typeof(T));
      sFld3 = value; 
    } 
  }


  protected T this[int i]
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].this1.get",typeof(T));
      return Fld1; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].this1.set",typeof(T));
      Fld1 = value; 
    } 
  }

  protected GC1<T> this[GC1<T> i, T t]
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].this2.get",typeof(T));
      return Fld2; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].this2.set",typeof(T));
      Fld2 = value; 
    } 
  }

  protected virtual T this[GS1<T> i]
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vthis1.get",typeof(T));
      return Fld1; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vthis1.set",typeof(T));
      Fld1 = value; 
    } 
  }
  
  protected virtual GC1<T> this[string s, T t] 
  { 
    get 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vthis2.get",typeof(T));
      return Fld2; 
    } 
    set 
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vthis2.set",typeof(T));
      Fld2 = value; 
    } 
  }
  
  protected  event GenDlg<T> Ev
  {
    add 
    {
      TestVerificationStore.SetLastAction("GenericClass[{0}].Ev.add",typeof(T));
    }
    remove
    {
      TestVerificationStore.SetLastAction("GenericClass[{0}].Ev.remove",typeof(T));
    }
  }
  
  protected  virtual event GenDlg<T> vEv
  {
    add 
    {
      TestVerificationStore.SetLastAction("GenericClass[{0}].vEv.add",typeof(T));  
    }
    remove
    { 
      TestVerificationStore.SetLastAction("GenericClass[{0}].vEv.remove",typeof(T));
    }
  }

  protected static event GenDlg<T> sEv
  {
    add 
    {
      TestVerificationStore.SetLastAction("GenericClass[{0}].sEv.add",typeof(T));
    }
    remove
    {
      TestVerificationStore.SetLastAction("GenericClass[{0}].sEv.remove",typeof(T));
    }
  }

  
  protected event GenDlg<GC1<T>> FldEv;

  protected GC1<T> FireFldEv()
  {
    return FldEv(default(GC1<T>));
  }

  protected virtual event GenDlg<GC1<T>> vFldEv;

  protected virtual GC1<T> FirevFldEv()
  {
    return vFldEv(default(GC1<T>));
  }

  protected static event GenDlg<GC1<T>> sFldEv;

  protected static GC1<T> FiresFldEv()
  {
    return sFldEv(default(GC1<T>));
  }
  
  protected T Meth1(T t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth1",typeof(T));
    return Fld1; 
  }
  
  protected virtual T vMeth1(T t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth1",typeof(T));
    return Fld1; 
  }

  protected static T sMeth1(T t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth1",typeof(T));
    return sFld1; 
  }

  protected T Meth2(out T t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth2",typeof(T));
    t = Fld1;
    return Fld1; 
  }
  
  protected virtual T vMeth2(out T t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth2",typeof(T));
    t = Fld1;
    return Fld1; 
  }

  protected static T sMeth2(out T t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth2",typeof(T));
    t = sFld1;
    return sFld1; 
  }

  protected T Meth3(ref T t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth3",typeof(T));
    t = Fld1;
    return Fld1; 
  }
  
  protected virtual T vMeth3(ref T t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth3",typeof(T));
    t = Fld1;
    return Fld1; 
  }

  protected static T sMeth3(ref T t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth3",typeof(T));
    t = sFld1;
    return sFld1; 
  }

  protected GC1<T> Meth4(GC1<T> t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth4",typeof(T));
    return Fld2; 
  }
  
  protected virtual GC1<T> vMeth4(GC1<T> t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth4",typeof(T));
    return Fld2; 
  }

  protected static GC1<T> sMeth4(GC1<T> t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth4",typeof(T));
    return sFld2; 
  }

  protected GC1<T> Meth5(out GC1<T> t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth5",typeof(T));
    t = default(GC1<T>);
    return Fld2; 
  }
  
  protected virtual GC1<T> vMeth5(out GC1<T> t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth5",typeof(T));
    t = default(GC1<T>);
    return Fld2; 
  }

  protected static GC1<T> sMeth5(out GC1<T> t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth5",typeof(T));
    t = default(GC1<T>);
    return sFld2; 
  }

  protected GC1<T> Meth6(ref GC1<T> t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth6",typeof(T));
    t = default(GC1<T>);
    return Fld2; 
  }
  
  protected virtual GC1<T> vMeth6(ref GC1<T> t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth6",typeof(T));
    t = default(GC1<T>);
    return Fld2; 
  }

  protected static GC1<T> sMeth6(ref GC1<T> t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth6",typeof(T));
    t = default(GC1<T>);
    return sFld2; 
  }

  protected T Meth7(T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth7",typeof(T));
    return Fld1; 
  }
  
  protected virtual T vMeth7(T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth7",typeof(T));
    return Fld1; 
  }

  protected static T sMeth7(T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth7",typeof(T));
    return sFld1; 
  }

  protected T Meth8(out T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth8",typeof(T));
    t = null;
    return Fld1; 
  }
  
  protected virtual T vMeth8(out T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth8",typeof(T));
    t = null;
    return Fld1; 
  }

  protected static T sMeth8(out T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth8",typeof(T));
    t = null;
    return sFld1; 
  }

  protected T Meth9(ref T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth9",typeof(T));
    t = null;
    return Fld1; 
  }
  
  protected virtual T vMeth9(ref T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth9",typeof(T));
    t = null;
    return Fld1; 
  }

  protected static T sMeth9(ref T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth9",typeof(T));
    t = null;
    return sFld1; 
  }

  protected T Meth10(params T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth10",typeof(T));
    return Fld1; 
  }
  
  protected virtual T vMeth10(params T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth10",typeof(T));
    return Fld1; 
  }

  protected static T sMeth10(params T[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth10",typeof(T));
    return sFld1; 
  }

  protected T Meth11(params GC1<T>[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].Meth11",typeof(T));
    return Fld1; 
  }
  
  protected virtual T vMeth11(params GC1<T>[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].vMeth11",typeof(T));
    return Fld1; 
  }

  protected static T sMeth11(params GC1<T>[] t) 
  { 
    TestVerificationStore.SetLastAction("GenericClass[{0}].sMeth11",typeof(T));
    return sFld1; 
  }
  
  public static GenericClass<T> operator + (GenericClass<T> G1, GenericClass<T> G2)
  {
    TestVerificationStore.SetLastAction("GenericClass[{0}].op_Addition",typeof(T));
    return G1;
  }

  public static GenericClass<T> operator ++ (GenericClass<T> G1)
  {
    TestVerificationStore.SetLastAction("GenericClass[{0}].op_incr",typeof(T));
    return G1;
  }

  public static bool operator true (GenericClass<T> G)
  {
    TestVerificationStore.SetLastAction("GenericClass[{0}].op_true",typeof(T));
    return (G != null);
  }

  public static bool operator false (GenericClass<T> G)
  {
    TestVerificationStore.SetLastAction("GenericClass[{0}].op_false",typeof(T));
    return (G == null);
  }

  public static GenericClass<T> operator & (GenericClass<T> G1, GenericClass<T> G2)
  {
    return G1;
  }

  public static implicit operator GC1<T> (GenericClass<T> G)
  {
    TestVerificationStore.SetLastAction("GenericClass[{0}].op_impl",typeof(T));
    return default(GC1<T>);
  }

  public static explicit operator GS1<T> (GenericClass<T> G)
  {
    TestVerificationStore.SetLastAction("GenericClass[{0}].op_expl",typeof(T));
    return default(GS1<T>);
  }

  protected class NestedClass { }
  protected struct NestedStruct { }
  protected interface NestedInterface { }
  protected delegate void NestedDelegate();
  protected enum NestedEnum { }
  
}
`
`
class foo
{
    int i = 0;
    delegate bool NoArg();
    NoArg bar()
    {
        return delegate
        {
            int j = 0;
            goto Forward;
        Backward:
            j += ++i;
            goto Continue;
        Forward:
            goto Backward;
        Continue:
            return j==1;
        };
    }
    static int Main()
    {
        foo f = new foo();
        if (f.bar()()) return 0;
        else return 1;
    }
}
`
`
`/p:v2
using System;

public class SpecializedSubGenericClassInt : GenericClass<int>{}

public class GenericClass<T> {
  protected virtual event EventHandler vFldEv;
}

public class Test{
 public static int Main(){
   SpecializedSubGenericClassInt foo = new SpecializedSubGenericClassInt();
   return foo == null ? 1 : 0;
 }
}
`
`
using System;
using System.Collections;

// Helper Class for using block
public class Dis: IDisposable
{
  public void Dispose() { }
}



// Helper Class for Validation
public class Validator
{
  public static int Passed = 0;

  public static int Failed = 0;


  public static void Validate(int i1, int i2, string s1, string s2)
  {
    if ((s1 == s2) && (i1 == i2))
      Passed++;
    else
      Failed++;
  }
}



public class Test
{
  public delegate void Del(int i, string s);



  public delegate void D();



  //ctor
  [Microsoft.Contracts.NotDelayed] public Test(int i, string s)
  {
    D d = delegate
    {
      Validator.Validate(i,1,s,"CTOR");
    };

    d();
  }


  // cctor
  static Test() { /*N/A*/}


  // dtor
  ~Test() {/*N/A*/}


  // iter block
  public IEnumerable Iter1(int i, string s)
  {
    D d = delegate
    {
      Validator.Validate(i,2,s,"Iter");
    };

    d();
    yield break;
  }


  // static iter block
  public static IEnumerable Iter2(int i, string s)
  {
    D d = delegate
    {
      Validator.Validate(i,3,s,"StaticIter");
    };

    d();
    yield break;
  }


  // anonymous method block
  public void AnonymousMethod(int i, string s)
  {
    ((Del)delegate(int ii, string ss){
        D d = delegate
    {
      Validator.Validate(ii,4,ss,"AnonymousMethod");
    };

    d();  
    })(i, s);
  }


  // static anonymous method
  public static void SAnonymousMethod(int i, string s)
  {
    ((Del)delegate(int ii, string ss){
          D d = delegate
    {
      Validator.Validate(ii,5,ss,"Static AnonymousMethod");
    };

    d();
    })(i, s);
  }


  // method block
  public void Method(int i, string s)
  {
    D d = delegate
    {
      Validator.Validate(i,6,s,"Method");
    };

    d();
  }


  // static method block
  public static void SMethod(int i, string s)
  {
    D d = delegate
    {
      Validator.Validate(i,7,s,"Static Method");
    };

    d();
  }


  // using block
  public void Using(int i, string s)
  {
    using (new Dis())
    {
      D d = delegate
    {
      Validator.Validate(i,8,s,"Using");
    };

      d();
    }
  }


  // Lock block
  public void Lock(int i, string s)
  {
    lock (this)
    {
      D d = delegate
    {
      Validator.Validate(i,9,s,"Lock");
    };

      d();
    }
  }


  // foreach block
  public void Foreach(int i, string s)
  {
    foreach (char c in s)
    {
      D d = delegate
      {
        Validator.Validate(i,10,s,"Foreach");
      };

      d();
    }
  }


  // Property block
  public int Prop
  {
    get
    {
      /*NA*/
      return 1;
    }
    set
    {
      D d = delegate
      {
        Validator.Validate(value,11,"Prop"+value.ToString(),"Prop11");
      };

      d();
    }
  }


  // static property block
  public static int SProp
  {
    get
    {
      /*NA*/
      return 1;
    }
    set
    {
      D d = delegate
      {
        Validator.Validate(value,12,"Prop"+value.ToString(),"Prop12");
      };

      d();
    }
  }


  // indexer block
  public int this[int i, string s]
  {
    get
    {
      D d = delegate
      {
        Validator.Validate(i,13,s,"Indexer");
      };

      d();
      return i;
    }
    set
    {
      D d = delegate
      {
        Validator.Validate(value,13,s,"Indexer");
      };

      d();
    }
  }


  // operator blocks
  public static bool operator==(Test t1, Test t2)
  {
    /*NA*/
    return false;
  }


  // operator blocks
  public static bool operator!=(Test t1, Test t2)
  {
    /*NA*/
    return false;
  }


  public event D E
  {
    add
    {
      /*NA*/
    }
    remove
    {
      /*NA*/
    }
  }


  public void TryCatchFinally(int i, string s)
  {
    try
    {
      D d = delegate
    {
      Validator.Validate(i,14,s,"TryCatchFinally");
      throw new Exception();
    };

      d();
    }
    catch
    {
      D d = delegate
    {
      Validator.Validate(i,14,s,"TryCatchFinally");
    };

      d();
    }
    finally
    {
      D d = delegate
    {
      Validator.Validate(i,14,s,"TryCatchFinally");
    };

      d();
    }
  }
}



public class EntryPoint
{
  // entry point
  static int Main(string[] args)
  {
    // cctor
    Test t = new Test(1, "CTOR");

    // iterator
    foreach (int i in t.Iter1(2, "Iter"))
    {
    }

    // static iterator
    foreach (int i in Test.Iter2(3, "StaticIter"))
    {
    }

    // anonymous method
    t.AnonymousMethod(4, "AnonymousMethod");

    // static anonymous method
    Test.SAnonymousMethod(5, "Static AnonymousMethod");

    // method
    t.Method(6, "Method");

    // static method
    Test.SMethod(7, "Static Method");

    // using
    t.Using(8, "Using");

    // lock
    t.Lock(9, "Lock");

    // foreach
    t.Foreach(10, "Foreach");

    // Property
    t.Prop = 11;
    { int i = t.Prop; }

    // Static Property
    Test.SProp = 12;
    { int i = Test.SProp; }

    // Indexer
    t[13, "Indexer"] = 13;
    { int i = t[13, "Indexer"]; }

    // Try Catch Finally
    t.TryCatchFinally(14, "TryCatchFinally");

    if (Validator.Passed == 23 && Validator.Failed == 0)
      return 0;
    else
      return 1;
    }
}
`
(31,14): warning CS0660: 'Test' defines operator == or operator != but does not override Object.Equals(object o)
(31,14): warning CS0661: 'Test' defines operator == or operator != but does not override Object.GetHashCode()
(322,18): warning CS0219: The variable 'i' is assigned but its value is never used
(327,18): warning CS0219: The variable 'i' is assigned but its value is never used
(354,11): warning CS0219: The variable 'i' is assigned but its value is never used
(358,11): warning CS0219: The variable 'i' is assigned but its value is never used
(362,11): warning CS0219: The variable 'i' is assigned but its value is never used
`
`/p:v2
using System;
using System.Collections;
// Helper Class for using block
public class Dis: IDisposable
{
  public void Dispose() { }
}



// Helper Class for Validation
public class Validator
{
  public static int Passed = 0;

  public static int Failed = 0;


  public static void Validate<T,U>(T i1, int i2, U s1, string s2) where U : IComparable 
  {
    if ((s1 != null && (s1.CompareTo(s2) == 0) && i2.Equals(i1)))
    {
      Passed++;
    }
    else if (s2 == null && i2.Equals(i1))
    {
      Passed++;
    }
    else
      Failed++;

  }
}



public class Test<T,U>  where U : IEnumerable,IComparable where T : IComparable
{
  public delegate void Del(T i, U s);
  public delegate void D();

  public T i=default(T);
  public U s=default(U);

  //ctor
  [Microsoft.Contracts.NotDelayed] public Test()
  {
    this.i=default(T);
    this.s=default(U);
    
    D d = delegate
    {
      Validator.Validate(default(T),0,default(U),null);
    };

    d();
  }


  // cctor
  static Test() { /*N/A*/}


  // dtor
  ~Test() {    
    D d = delegate
    {
      Validator.Validate(i,1,s,"DTOR");
    };

    d();
  }


  // iter block
  public IEnumerable Iter1()
  {
    D d = delegate
    {
      Validator.Validate(i,2,s,"Iter");
    };

    d();
    yield break;
  }


  // static iter block
  public static IEnumerable Iter2()
  {
    /*NA*/
    yield break;
  }


  // anonymous method block
  public void AnonymousMethod()
  {
    ((Del)delegate(T ii, U ss){
        D d = delegate
    {
      Validator.Validate(ii,4,ss,"AnonymousMethod");
    };

    d();  
    })(i, s);
  }


  // static anonymous method
  public static void SAnonymousMethod()
  {
    /*NA*/
  }


  // method block
  public void Method()
  {
    D d = delegate
    {
      Validator.Validate(i,6,s,"Method");
    };

    d();
  }


  // static method block
  public static void SMethod()
  {
    /*NA*/
  }


  // using block
  public void Using()
  {
    using (new Dis())
    {
      D d = delegate
    {
      Validator.Validate(i,8,s,"Using");
    };

      d();
    }
  }


  // Lock block
  public void Lock()
  {
    lock (this)
    {
      D d = delegate
    {
      Validator.Validate(i,9,s,"Lock");
    };

      d();
    }
  }


  // foreach block
  public void Foreach()
  {
    foreach (object c in s)
    {
      D d = delegate
      {
        Validator.Validate(i,10,s,"Foreach");
      };

      d();
    }
  }


  // Property block
  public int Prop
  {
    get
    {
      /*NA*/
      return 1;
    }
    set
    {
      D d = delegate
      {
        Validator.Validate(value,11,"Prop"+value.ToString(),"Prop11");
      };

      d();
    }
  }


  // static property block
  public static int SProp
  {
    /*NA*/
    get { return 1; }
  }


  // indexer block
  public T this[int index]
  {
    get
    {
      D d = delegate
      {
        Validator.Validate(i,13,s,"Indexer");
      };

      d();
      return i;
    }
    set
    {
      D d = delegate
      {
        Validator.Validate(value,13,s,"Indexer");
      };

      d();
    }
  }


  // operator blocks
  public static bool operator==(Test<T,U> t1, Test<T,U> t2)
  {
    /*NA*/
    return false;
  }


  // operator blocks
  public static bool operator!=(Test<T,U> t1, Test<T,U> t2)
  {
    /*NA*/
    return false;
  }


  public event D E
  {
    add
    {
      /*NA*/
    }
    remove
    {
      /*NA*/
    }
  }


  public void TryCatchFinally()
  {
    try
    {
      D d = delegate
    {
      Validator.Validate(i,14,s,"TryCatchFinally");
      throw new Exception();
    };

      d();
    }
    catch
    {
      D d = delegate
    {
      Validator.Validate(i,14,s,"TryCatchFinally");
    };

      d();
    }
    finally
    {
      D d = delegate
    {
      Validator.Validate(i,14,s,"TryCatchFinally");
    };

      d();
    }
  }
}



public class EntryPoint
{
  // entry point
  static int Main(string[] args)
  {
    // ctor
    Test<int,string> t = new Test<int,string>();

    // iterator
    t.i=2;
    t.s="Iter";
    foreach (int i in t.Iter1())
    {
    }

    // static iterator
    /*
    t.i=3;
    t.s="StaticIter";
    foreach (int i in Test.Iter2())
    {
    }
    */

    // anonymous method
    t.i=4;
    t.s="AnonymousMethod";
    t.AnonymousMethod();

    // static anonymous method
    /*
    t.i=5;
    t.s="Static AnonymousMethod";
    Test.SAnonymousMethod();
    */

    // method
    t.i=6;
    t.s="Method";
    t.Method();

    // static method
    /*
    t.i=7;
    t.s="Static Method";
    Test.SMethod();
    */

    // using
    t.i=8;
    t.s="Using";
    t.Using();

    // lock
    t.i=9;
    t.s="Lock";
    t.Lock();

    // foreach
    t.i=10;
    t.s="Foreach";
    t.Foreach();

    // Property
    t.i=11;
    t.s="Pro";
    t.Prop = 11;
    { int i = t.Prop; }

    // Static Property
    /*
    Test.SProp = 12;
    t.i=12;
    t.s="SPro";
    { int i = Test.SProp; }
    */

    // Indexer
    t.i=13;
    t.s="Indexer";
    t[13] = 13;
    { int i = t[13]; }

    // Try Catch Finally
    t.i=14;
    t.s="TryCatchFinally";
    t.TryCatchFinally();

    // DTOR
    t.i=15;
    t.s="DTOR";

    if (Validator.Passed == 19 && Validator.Failed == 0)
      return 0;
    else
      return 1;
    }
}
`
(37,14): warning CS0660: 'Test<T,U>' defines operator == or operator != but does not override Object.Equals(object o)
(37,14): warning CS0661: 'Test<T,U>' defines operator == or operator != but does not override Object.GetHashCode()
(309,18): warning CS0219: The variable 'i' is assigned but its value is never used
(365,11): warning CS0219: The variable 'i' is assigned but its value is never used
(379,11): warning CS0219: The variable 'i' is assigned but its value is never used
`
using System;

public class Gen<T> 
{
  public delegate void D(T t);
    
  public static void ConversionTest()
  {
    Gen<object>.D d1 = default(Gen<object>.D);
    Gen<string>.D d2 = d1;
  }
}

public class Test
{
  public static int Main()
  {  
    Gen<object>.ConversionTest();
    return 0;
  }
}
`
(10,24): error CS0029: Cannot implicitly convert type 'Gen<object>.D' to 'Gen<string>.D'
`
using System;

public struct BoxwoodPtr {
    public int pos;
}

public class RefParameterPrefixUpdate {

    private static void UpdateParameterField(ref BoxwoodPtr source)
    {
            source.pos += 555;
    }

    public static void Main() {
        BoxwoodPtr bptr = new BoxwoodPtr();

        UpdateParameterField(ref bptr);

        Console.WriteLine(bptr.pos);
    }

}
`
555
`
public enum MyEnum {a = 1, b = 2}

public class MyClass1 {
  public static MyEnum E = MyEnum.a;
}

public class MyClass2 {

  public static MyEnum E = MyEnum.b;

  public static int Main() {

    if (MyClass1.E != MyEnum.a) {
      return 1;
    }
    if (MyClass2.E != MyEnum.b) {
      return 1;
    }

    return 0;
  }

}
`
`
using System;

public class Test{
  public static void Main(string[] args){
    int? i = 1;
    int? j = null;
    Console.WriteLine(i + i);
    Console.WriteLine(i + j);
    Console.WriteLine(i + 2);
    Console.WriteLine(j + j);
    Console.WriteLine(j + i);
    Console.WriteLine(j + 2);
  }
}
`
2

3



`
using System;
using System.Collections;

interface ifoo{
}
class bar{
}
class bar1 : bar, ifoo{
}

public class Test{
  public static void Main(string[] args){
    bar b = new bar1();
    ifoo c = (ifoo)b;
    Console.WriteLine(b == c);
  }
}
`
True
`
using System;

public struct S {

    int x;

    public static void M(ref S s) {
        s.x = 55;
    }


    public void Test() {
        M(ref this);
    }

    public static int Main() {
        S s = new S();

        s.Test();

        if (s.x == 55) { 
            return 0; 
        } 
        else { 
            Console.WriteLine("Failed");
            return 1; 
        }
    }
}
`
`

class IdeConfig {
    public IdeConfig(int x) {
    }
}


class IdePnpConfig : IdeConfig {

    public IdePnpConfig(int y) {
    }
}
`
(10,32): error CS1501: No overload for method 'IdeConfig' takes '0' arguments
(3,12): (Location of symbol related to previous error)
`
using System;

public class Test
{
  public static int Main(string [] args)
  {
    int ret = 2;

    byte? b = 2;
    
    switch (b)
    {
      case 1:
      case 2:
        ret--;
        break;
      case 3:
        break;
      default:
        break;
    }

    switch (b)
    {
      case 1:
      case 3:
        break;
      default:
        ret--;
        break;
    }
    return ret;
  }
}
`
`
`/p:v2
using System;

public class Test
{
  public static int counter = 0;
  public static bool result = true;

  public static void Eval(bool expr)
  {
    counter++;
    if (!expr)
    {
      result = false;
      Console.WriteLine("Test Failed at location {0}", counter);
    }

  }

  public static int Main()
  {
    int? nubInt;

    nubInt = Nullable<int>.FromObject((object)null);
    Test.Eval(nubInt == null);

    nubInt = Nullable<int>.FromObject(1);
    Test.Eval(nubInt == 1);
  
    nubInt = Nullable.FromObject<int>((object)null);
    Test.Eval(nubInt == null);

    nubInt = Nullable.FromObject<int>(1);
    Test.Eval(nubInt == 1);
  
    if (result)
    {
      return 0;
    }
    else
    {
      return 1;
    }
  }
}
`
(23,28): error CS0117: 'int?' does not contain a definition for 'FromObject'
(26,28): error CS0117: 'int?' does not contain a definition for 'FromObject'
(29,23): error CS0117: 'System.Nullable' does not contain a definition for 'FromObject'
(32,23): error CS0117: 'System.Nullable' does not contain a definition for 'FromObject'
`
using System;

public class Test{
  public static void Main(string[] args){
    int? i = 1;
    int? j = null;
    Console.WriteLine(i & i);
    Console.WriteLine(i & j);
    Console.WriteLine(i & 2);
    Console.WriteLine(j & j);
    Console.WriteLine(j & i);
    Console.WriteLine(j & 2);
  }
}
`
1

0



`
using System;

public class Test{
  public static void Main(string[] args){
    int? i = 1;
    Console.WriteLine(i & null);
  }
}
`
(6,23): warning CS0458: The result of the expression is always 'null' of type 'int?'
(5,10): warning CS0219: The variable 'i' is assigned but its value is never used

`
using System;

public class Test
{
  public static int Main(string [] args)
  {
    int ret = 2;

    byte? b = null;
    
    switch (b)
    {
      case 1:
      case null:
        ret--;
        break;
      case 3:
        break;
      default:
        break;
    }

    switch (b)
    {
      case 1:
      case 3:
        break;
      default:
        ret--;
        break;
    }
    return ret;
  }
}
`
`
using System;

public class Test{
  public static void Main(string[] args){
    //Console.WriteLine(true & null);
  }
}
`
`
using System;

class foo{
  public foo(int i){
    Console.WriteLine(i);
  }
}
class bar : foo{
  [Microsoft.Contracts.NotDelayed]
  public bar(int i)
    : base(i){
    del d = delegate (){};
    Console.WriteLine(d);
  }
}
delegate void del();

public class Test{

  public static void Main(string[] args){
    new bar(1);
  }
}
`
1
del
`
using System;
using System.Collections;

public class Test
{
  public int verify = 0;
  public int field=10;
  delegate void D();  
  void DoStuff(D d)
  {
    d();
  }

  public void F(IEnumerable e)
  {
    DoStuff(delegate()
    {
      DoStuff(delegate()
      {
        foreach (int z in e)
          verify += (z + field);
      });

      foreach (int z in e)
        DoStuff(delegate() { verify += z; });
    });
  }

  public static int Main() 
  {
    Test t = new Test();
    t.F(new int[] { 1, 2, 3, 4, 5 });
    Console.WriteLine(t.verify);
    if(t.verify != 80) return 1;
    else return 0;
  }
}
`
80
`
using System;

public class Test
{

  public delegate void D();

  public static int i = 0;
  public static D[] Del = new D[]{delegate(){ i++;},delegate {i++;}, delegate{
    // increment i
    i++;
  }, (D)delegate{i++;},};

  public static int Main ()
  {
    foreach(D d in Test.Del)
      d();
    return Test.i-4;
  }
}
`
`
using System;

public delegate void D();

public class Test
{
  public static int i = 0;
  D member1 = delegate(){ i++;} +  (D)delegate{i++;}+ (D)delegate{i++;};
  public static int Main ()
  {
    (new Test ()).member1();
    return Test.i - 3;
  }
}
`
`
using System;

public class Test
{
	private delegate string D();

	private string foo(ref D d)
	{
		d = delegate(){ return s;};
		return d();
	}
	
	public string s;	

	public static int Main()
	{	
		D d = null;
		Test t = new Test();
		t.s = "Hello";
		if(t.foo(ref d) != t.s)
			return 1;
		t.s="world";
		if(d() != t.s)
			return 1;		
		t.s="!!";
		t=null;
		if(d() != "!!")
			return 1;		
		return 0;
	}
}
`
`
public class IsTest {
  public static void Main() {
    B b = new B();
    bool x = M(b);
    System.Console.WriteLine("M returns: {0}", x);
  }

  public static bool M(J j) {
    bool x = j is A;    // it is this expression that the Spec# compiler complains about
    return x;
  }
}

public interface J {}
public class A {}

public class B : A, J {}
`
M returns: True
`
using System;

public interface I {}

public struct CI : I {}

public struct C : I {}

class Gen<T> where T: struct, I
{
  public static void TestIsOperatorC(T t, bool expected)
  {
    Test.Eval(t is C, expected);
  }
  

  public static void TestIsOperatorI(T t, bool expected)
  {
    Test.Eval(t is I, expected);
  }

  public static void TestNewOnT()
  {
    Test.Eval(new T() is T, true);
  }
}

public class Test
{
  public static int counter = 0;
  public static bool result = true;
  public static void Eval(object obj1, object obj2)
  {
    counter++;

    if ( (!(null == obj1 && null == obj2)) && (null == obj1 || null == obj2 || !obj1.Equals(obj2)))
    {
      result = false;
      Console.WriteLine("Test Failed at location: " + counter);
      Console.WriteLine("While Comparing {0} to {1}", obj1, obj2);
    }
  
  }

  public static int Main()
  {
    Gen<C>.TestIsOperatorC(new C(),  true);
    Gen<CI>.TestIsOperatorC(new CI(), false);
    
    Gen<CI>.TestIsOperatorI(new CI(),  true);
    Gen<C>.TestIsOperatorI(new C(), true);

    Gen<C>.TestNewOnT();
  
    if (result)
      return 0;
    else
      return 1;
  }
    
}
`
(19,15): warning CS0183: The given expression is always of the provided ('I') type
(24,15): warning CS0183: The given expression is always of the provided ('T') type
`
namespace N1
{
    class C1 
    {
        public C1(int a) {}
    }

    class C2 : C1
    {
        public C2(int a) : global::base(a) {}         
    }

    class Test
    {
        static int Main()
        {
            C2 c2 = new C2(5);
            return 0;
        }
    }
}
`
(10,28): error CS1018: Keyword this or base expected
(10,28): error CS1514: { expected
(10,36): error CS1041: Identifier expected, 'base' is a keyword
(10,28): error CS1520: Class, struct, or interface method must have a return type
(10,42): error CS1001: Identifier expected
(10,41): error CS0246: The type or namespace name 'a' could not be found (are you missing a using directive or an assembly reference?)
(10,28): error CS1501: No overload for method 'C1' takes '0' arguments
(5,16): (Location of symbol related to previous error)
`
using System;

[MyAttr]
class T {
  public static void Main(){}
}


[AttributeUsage(Constants.Class|AttributeTargets.Interface)]
class MyAttr : Attribute {
}


public class Constants {

    public const AttributeTargets Class = AttributeTargets.Class;
}
`
`
class MyTest {
  protected const int intI = 2;
}


class MyClass {

  public static int Main() {
    int intJ = MyTest.intI;
    return 1;
  }
}
`
(9,23): error CS0122: 'MyTest.intI' is inaccessible due to its protection level
(2,23): (Location of symbol related to previous error)
`
enum MyEnum {a = 1, b = 2}

class MyClass {

  const MyEnum test = MyEnum.a;

  public static int Main() {
    if (test == MyEnum.a) {
      return 0;
    }
    else {
      return 1;
    }
  }
}
`
`
using System;

public class Test
{
  public static int Main(string [] args)
  {
    string s = null;

    switch (s)
    {
      case null:
        Console.WriteLine("null");
        return 0;
      default:
        return 1;
    }
  }
}
`
null
`
class Foo{ 
    public const decimal M1 = -1m;
    public const short MinValue1 = unchecked((short)0x8000);
    public const int MinValue2 = unchecked((int)0x80000000);
    public const long MinValue3 = unchecked((long)0x8000000000000000L);
    public const sbyte MinValue4 = unchecked((sbyte)0x80);
    public static int Main(){
      if (Foo.M1 != decimal.MinusOne) return 1;
      if (Foo.MinValue1 != short.MinValue) return 2;
      if (Foo.MinValue2 != int.MinValue) return 3;
      if (Foo.MinValue3 != long.MinValue) return 4;
      if (Foo.MinValue4 != sbyte.MinValue) return 5;
      return 0;
    }
}
`
`
using System;

class MyClass 
{
  int _i;
  public MyClass(int i) { _i = i;}
  public int GetI() {return _i;}
}

class MyMainClass {

  public const MyClass mc = new MyClass(10);

  public static int Main() 
  {
    int retval = 1;
    if (null == mc)
      retval = 0;
    if (0 == retval) Console.WriteLine ("PASS");
    else Console.WriteLine ("FAIL");
    return retval;
  }
}
`
(12,29): error CS0133: The expression being assigned to 'MyMainClass.mc' must be constant
`
public class Test {
  public object M(){
    return Test;
  } 

  public static void Main(){}
}
`
(3,12): error CS0118: 'Test' is a 'class' but is used like a variable
`
using System;
 
public class Test{
  static void Main(){
      Console.WriteLine("A:{0}, B:{1}, C:{2}", (int)A.Tags.A, (int)B.Tags.B, (int)C.Tags.C);
  }
}
 
public class C {
    public enum Tags {
        Base = B.Tags.Last,
        C = Base+1,
    }
}
public class B {
    public enum Tags {
        Base = A.Tags.Last,
        B = Base+1,
        Last = Base+1,
    }
}
public class A {
    public enum Tags {
        Base = 1,
        A = Base + 1,
        Last = Base + 1,
    }
}
`
A:2, B:3, C:4
`
using System;
 
class Class1 {
 
    static void Main(string[] args) {
        string s = null;
      before_try:
        //        s = "before_try";
        try {
            if (s == null) {
                throw new ApplicationException("inside try");
            }
        } catch (Exception) {
            s = "Catch Exception";
            goto before_try;
        } 
        finally {
            Console.WriteLine("Ran through finally");
        }
    }
}
`
Ran through finally
Ran through finally
`
using System;
  
public class Test {
 
    public static void Main() {}
 
    public static bool IsInst(System.Type targetType)
    {
        return (null == targetType.id);
    }
 
}
`
(9,36): error CS0117: 'System.Type' does not contain a definition for 'id'
`
class A{
  public A(int x) {}
}
class B : A{
}
`
(4,7): error CS1501: No overload for method 'A' takes '0' arguments
(2,10): (Location of symbol related to previous error)
`
`
using System;
// Test against bug in Writer, where it used to use the tiny exception handler table format to emit 22 exception handlers.
class Test{
  static void Foo(){}
  static void Bar(){}
  static void Main(){
    try{Foo();}catch(Exception){Bar();}
    try{Foo();}catch(Exception){Bar();}
    try{Foo();}catch(Exception){Bar();}
    try{Foo();}catch(Exception){Bar();}
    try{Foo();}catch(Exception){Bar();}

    try{Foo();}catch(Exception){Bar();}
    try{Foo();}catch(Exception){Bar();}
    try{Foo();}catch(Exception){Bar();}
    try{Foo();}catch(Exception){Bar();}
    try{Foo();}catch(Exception){Bar();}

    try{Foo();}catch(Exception){Bar();}
    try{Foo();}catch(Exception){Bar();}
    try{Foo();}catch(Exception){Bar();}
    try{Foo();}catch(Exception){Bar();}
    try{Foo();}catch(Exception){Bar();}

    try{Foo();}catch(Exception){Bar();}
    try{Foo();}catch(Exception){Bar();}
    try{Foo();}catch(Exception){Bar();}
    try{Foo();}catch(Exception){Bar();}
    try{Foo();}catch(Exception){Bar();}

    try{Foo();}catch(Exception){Bar();}
    try{
      throw new ApplicationException();
    }catch(ApplicationException){
      Console.WriteLine("Okay!");
    }
  }
}
`
Okay!
`
public class Outer {
  int x = 12;

  public int OuterM() {
    return this.x;
  }

  public class Inner {
    int y = 8;

    public int InnerM() {
      return OuterM();
    }
  }

  public static void Main() {
    Inner i = new Inner();
    int j = i.InnerM();
    System.Console.WriteLine(j);
  }
}
`
(12,14): error CS0038: Cannot access a nonstatic member of outer type 'Outer' via nested type 'Outer.Inner'
`
`/p:v2
using System.Collections.Generic;

public class Outer<T> : IEnumerable<Outer<T>.Inner>
{
  public class Inner : List<T> { }

  private IEnumerable<Inner> x = new List<Inner>();

  IEnumerator<Inner> IEnumerable<Inner>.GetEnumerator() { return x.GetEnumerator(); }

  System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return x.GetEnumerator(); }
}

public class Test
{
  public void Method()
  {
    Outer<int> o = new Outer<int>();
    int sum = 0;
    foreach (Outer<int>.Inner i in o)
    {
      sum += i.Count; 
    }
  }
  public static void Main(){}
}
`
`
class MyClass  {
static int GetProp<F>(char a){return 1;}
static int GetProp<F,G>(char a){return 0;}
 
  public static int Main() {
    return GetProp<int,int>('a');
  }
}
`
`
class B {
  void x() {
    object o = new B();
    o = o.MemberwiseClone();
  }
}
`
(4,11): error CS1540: Cannot access protected member 'object.MemberwiseClone()' via a qualifier of type 'object'; the qualifier must be of type 'B' (or derived from it)
`
using System;
class Test{
  public delegate void Handler(int a, int b);
  [field: NonSerialized]
  public event Handler Event1;
  public static void Main(){}
}
`
`
using System;

namespace SpecBugs
{
    abstract public class EnumCodeCase
    {
        protected EnumCodeCase()
        {
        }

		protected EnumCode enumCode;
		public EnumCode EnumCode
		{
			set { this.enumCode = value; }
		}

		public void PostProcess()
		{
			switch (this.enumCode)
			{
				case EnumCode.A:
					{
					}
					break;

				case EnumCode.B:
					{
					}
					break;

				case EnumCode.C:
					{
					}
					break;
			}
		}
		public static void Main(){}
    }

	public enum EnumCode
	{
		A,
		B,
		C,
	}
}
`
`
struct Complex { 
  private double re, im;
  public Complex(double re, double im) {
    this.re = re; this.im = im;
  }
  public Complex Negate() {
    return new Complex(-re, -im);
  }
}
class Test{
  public static void Main(){}
}
`
`
public class Base<T>{
  protected int foo{get{return 1;}}
}
public class Derived<T> : Base<T>{
  public int GetFoo(){
    return this.foo;
  }
}
public class Test{
  public static int Main(){
    Derived<int> d = new Derived<int>();
    return d.GetFoo() - 1;
  }
}
`
`
public class Test{
  public class Base<T>{
    protected int foo{get{return 1;}}
  }
  public class Derived<T> : Base<T>{
    public int GetFoo(){
      return this.foo;
    }
  }
  public static int Main(){
    Derived<int> d = new Derived<int>();
    return d.GetFoo() - 1;
  }
}
`
`
using System;

public class Gen<T>  
{
  public int val = 0;
  public Gen(int val) { this.val = val; }

  public static Gen<T> operator ++ (Gen<T> g)
  {
    return new Gen<T>(g.val+1);
  }

  public override string ToString() { return val.ToString();}
    
}
  
public class Test
{
  public static int counter = 0;
  public static bool result = true;
  public static void Eval(bool exp)
  {
    counter++;
    if (!exp)
    {
      result = exp;
      Console.WriteLine("Test Failed at location: " + counter);
    }
  
  }
  
  public static int Main()
  {     
    Gen<string> g = new Gen<string>(0);
    Test.Eval(g++.val==0);
    Test.Eval(++g.val==2);
    
    if (result)
    {
      return 0;
    }
    else
    {
      return 1;
    }
  }
}
`
`
class MyClass {

	public static bool MyMeth(ref MyClass foo, MyClass bar){
		return foo == bar;
	}

	public static int Main() {
	  MyClass mc = new MyClass();
	  if (MyMeth(ref mc, mc)) return 0;
	  return 1;
	}	
}
`
`
using System;

class A<T>
{
  public class Gen<U>
  {
    public int x = 1;
    public string Dummy(T t, U u) { return t.ToString() + u.ToString();}
  }
}
  
public class Test
{
  public static int counter = 0;
  public static bool result = true;
  public static void Eval(bool exp)
  {
    counter++;
    if (!exp)
    {
      result = exp;
      Console.WriteLine("Test Failed at location: " + counter);
    }
  }
  
  public static int Main()
  {
    A<int>.Gen<string> Obj = new A<int>.Gen<string>();
    Test.Eval(1 == Obj.x);

    if (result)
    {
      return 0;
    }
    else
    {
      return 1;
    }
  }
}
`
`
public sealed class NilEnumerator<T> : System.Collections.Generic.IEnumerator<T>{
  public void Reset() { }
  object System.Collections.IEnumerator.Current { get { throw new System.NotSupportedException(); } }
  T System.Collections.Generic.IEnumerator<T>.Current { get { throw new System.NotSupportedException(); } }
  public bool MoveNext() { return false; }
  public void Dispose() { }
}
public class Test{public static void Main(){}}
`
`
`/p:v2
using System;

public interface IFoo
{
    T getValue<T>(T t);
}

public class Foo : IFoo
{
    T IFoo.getValue<T>(T t)
    {
        return t;
    }
    public static void Main(){}
}
`
`
`
using System;
using System.Collections;
// foreach over null should fail
static class Test
{
   static void Main()
   {
      try
      {
         IEnumerable c = null;
         foreach (object o in c)
         {
            Console.WriteLine(o);
         }
         Console.WriteLine("FAIL");
      } catch (NullReferenceException) {
         Console.WriteLine("PASS");
      }
   }
}
`
PASS
`
`
using System;
using System.Collections;
// foreach with null enumerator should fail
class MyEnumerable : IEnumerable
{
    public IEnumerator GetEnumerator() { return null; }
}
static class Test
{
   static void Main()
   {
      try
      {
         foreach (object o in new MyEnumerable())
         {
            Console.WriteLine(o);
         }
         Console.WriteLine("FAIL");
      } catch (NullReferenceException) {
         Console.WriteLine("PASS");
      }
   }
}
`
PASS
`
public class C {

    int x;

    public void M() {

        int x;
        x = 1;
        {
            int x;
            x = 1;
        }
    }

    public static void Main() {}
}
`
(10,17): error CS0136: A local variable named 'x' cannot be declared in this scope because it would give a different meaning to 'x', which is already used in a 'parent or current' scope to denote something else
`
using System;

public class Test
{
	public delegate void D(int i);
	
	public void m(int i){Console.WriteLine("pass");}
	public void m(char ch){}

	public static void Main()
	{
		Test t = new Test();
    D d = t.m;
		d(1);
	}		
}
`
pass
`
using System;
using System.Collections;

public delegate void Del<T>(T i, T s);

public class Test<T, U>
    where U : IEnumerable, IComparable
    where T : IComparable
{
    //ctor
    public Test()
    {

        Del<T> dd = delegate
        {
          U u = default(U);
        };

    }
}
public class Test{public static void Main(){}}
`
(16,13): warning CS0219: The variable 'u' is assigned but its value is never used
`
using System;

namespace nms
{
    public class Constants
    {
        public const sbyte MIN_PLUS_ONE = sbyte.MinValue + 1;
    }

    public enum E : sbyte
    {
        zero,
        plus_one,
    }

    class Test
    {
        static void Main()
        {
            object ob = E.plus_one - (Constants.MIN_PLUS_ONE + 1);
            ob = ob;
        }
    }
}
`
`
using System;

public class Constants
{
    public const ulong MAX_MINUS_ONE = ulong.MaxValue - 1;
    static void Main(){}
}
`
`
using System;

namespace nms
{
    public class Constants
    {

        public const long PLUS_ONE = +1;

        public const ulong MAX_MINUS_ONE = ulong.MaxValue - 1;

    }

    public enum E : long
    {
        zero,
    }

    public enum UE : ulong
    {
        zero,
        plus_one,
        max_minus_one = Constants.MAX_MINUS_ONE,
    }

    class Test
    {
        static System.Int32 Main()
        {
            int result = 0;

            result += verify(UE.plus_one + (ulong)Constants.MAX_MINUS_ONE, Constants.PLUS_ONE + Constants.MAX_MINUS_ONE);

            return result;
        }

        static int verify(E e, long i)
        {
            return 0;
        }

        static int verify(UE e, ulong i)
        {
            return 0;
        }

    }
}
`
`

using System;

public class VDef {

    public static void Printf(string fmt, __arglist) {

        Decode(__arglist);
    }

    public static void Decode(RuntimeArgumentHandle art) {
        ArgIterator ai = new ArgIterator(art);
        while(ai.GetRemainingCount() >0)
        {
            TypedReference tr = ai.GetNextArg();
            Type t = __reftype(tr);
            if (t == typeof(int)) {
                int i = __refvalue(tr, int);
                Console.WriteLine("Got int {0}", i);
            }
            else if (t == typeof(long)) {
                long i = __refvalue(tr, long);
                Console.WriteLine("Got long {0}", i);
            }
            else if (t == typeof(string)) {
                string s = __refvalue(tr, string);
                Console.WriteLine("Got string {0}", s);
            }
            else {
                Console.WriteLine("Undecoded type with val:{0}", 
                                  TypedReference.ToObject(tr).ToString());
            }
        }
    }

    public static void P4(__arglist) {
    }

    public static void Main() {
        Printf("foo", __arglist("bar", 7));
    }
}
`
Got string bar
Got int 7
`
using System;

class VUse {

    public static void Printf(string fmt, __arglist) {
    }

    public static void Main()
    {
        Printf("foo", 5, __arglist("bar", 7));
        Printf(__arglist("bar", 7));
        Printf("foo", 5, "baz");
        Printf("foo", 5);
        Printf("foo");
        Printf();
    }

    public static void M2()
    {
        P4("foo", 5, __arglist("bar", 7));
        P4("foo", __arglist("bar", 7));
        P4("foo", 5, "baz");
        P4("foo", 5);
        P4("foo");
        P4();
    }

    public static int i = __arglist;

    public static void M3() {

        ArgIterator ai = new ArgIterator(__arglist);
    }

    public static void Bad(int j) {
        Type t = __reftype(j);
    }

    public static void Bad2(object arg, int j) {
        int i = __refvalue(arg, j);
    }

    public int this[int i, __arglist] {
        get { return 0; }
        set {}
    }


    public static void P4(__arglist) {}

    public delegate void FooD(int i, __arglist);
}
`
(43,28): error CS0237: __arglist is not allowed in indexers
(40,33): error CS0246: The type or namespace name 'j' could not be found (are you missing a using directive or an assembly reference?)
(51,38): error CS0235: __arglist is not allowed in delegates
(10,9): error CS1501: No overload for method 'Printf' takes '3' arguments
(5,24): (Location of symbol related to previous error)
(11,9): error CS1501: No overload for method 'Printf' takes '1' arguments
(5,24): (Location of symbol related to previous error)
(12,9): error CS1501: No overload for method 'Printf' takes '3' arguments
(5,24): (Location of symbol related to previous error)
(13,23): error CS0029: Cannot implicitly convert type 'int' to '__arglist'
(14,9): error CS1501: No overload for method 'Printf' takes '1' arguments
(5,24): (Location of symbol related to previous error)
(15,9): error CS1501: No overload for method 'Printf' takes '0' arguments
(5,24): (Location of symbol related to previous error)
(20,9): error CS1501: No overload for method 'P4' takes '3' arguments
(49,24): (Location of symbol related to previous error)
(21,9): error CS1501: No overload for method 'P4' takes '2' arguments
(49,24): (Location of symbol related to previous error)
(22,9): error CS1501: No overload for method 'P4' takes '3' arguments
(49,24): (Location of symbol related to previous error)
(23,9): error CS1501: No overload for method 'P4' takes '2' arguments
(49,24): (Location of symbol related to previous error)
(24,12): error CS0029: Cannot implicitly convert type 'string' to '__arglist'
(25,9): error CS1501: No overload for method 'P4' takes '0' arguments
(49,24): (Location of symbol related to previous error)
(28,27): error CS0190: The __arglist construct is valid only within a variable argument method
(32,42): error CS0190: The __arglist construct is valid only within a variable argument method
(36,28): error CS0029: Cannot implicitly convert type 'int' to 'System.TypedReference'
`
`/unsafe
using System;
unsafe public class Test {
       public static void Main() {
         int x;

         Foo(&x);
         Console.WriteLine("{0}", x);
       }

       public static void Foo(int* p) {
              int count = 0;
              p[count++] = 55;
       } 
}
`
55
`
`/unsafe
using System;
unsafe public class Test {
       public static void Main() {
         int x;

         Foo(&x);
         Console.WriteLine("{0}", x);
       }

       public static void Foo(int* p) {
              long count = 0;
              p[count++] = 55;
       } 
}
`
55
`
using System;

public class Test {

    public static void Main() {}


    public static void P1(ref string data) {
        P2(data);
        P3(data);
        P2(out data);
        P3(ref data);
    }

    public static void P2(ref string data) {
    }

    public static void P3(out string data) {
    }
}
`
(9,12): error CS0029: Cannot implicitly convert type 'string' to 'ref string'
(10,12): error CS0029: Cannot implicitly convert type 'string' to 'out string'
(11,12): error CS0029: Cannot implicitly convert type 'out string' to 'ref string'
(12,12): error CS0029: Cannot implicitly convert type 'ref string' to 'out string'
`
// Test overloading w.r.t varargs
//
public class Test {

    public static void Main() {

        M("foo");

        M("foo", __arglist(5, 6));
    }

    public static void M(string s) {}

    public static void M(string s, __arglist) {}
}
`
`
// Test overloading w.r.t varargs
//
public class Test {

    public static void Main() {

        M("foo", __arglist(5, 6));
    }

    public static void M(string s, __arglist) {}

    public static void M(string s, __arglist) {}
}
`
(12,24): error CS0111: Type 'Test' already defines a member called 'M' with the same parameter types
(10,24): (Location of symbol related to previous error)
`
`/unsafe
// Index on reference to pointers were silently ignored
using System;
unsafe public class T {
    public static void Main() {
        int x = 55;
        int* p = &x;
        int i = Foo(ref p);
        Console.WriteLine("{0}", i);
    }

    public static int Foo(ref int* p) {
        int i = p[0];
        return i;
    }
}
`
55
`
public class A {}
public class B : A {}

struct C {}
 
public class X {
  static int M(out A aOut) {
    aOut = new B();
    if (!(aOut is B)) return 1;
    B b = aOut as B;
    if (b == null) return 2;
    return 0;
  }
 
  public static int Main() {
    A a;
    int result = M(out a);
    if (!(a is B)) result = 3;
    return result;
  }
}
`
`
public class T {

       public static void Main() {
         int x = 0;

         Foo(out x);
         Foo(ref x);
       }

       public static void Foo(int i) {}
}
`
(6,18): error CS1615: Argument '1' should not be passed with the 'out' keyword
(7,18): error CS1615: Argument '1' should not be passed with the 'ref' keyword
`
`/r:System.dll
using System;
using System.Collections.Generic;

public static class Tracer
{
  public static Stack<int> Stack = new Stack<int>();
  public static void Log(int i)
  {
    Stack.Push(i);
  }
  public static bool VerifyTrace(params int[] Sequence)
  {
    try
    {
      foreach(int i in Sequence)
      {
        if (Stack.Pop() != i)
          return false;
      }

      if (Stack.Count == 0)
        return true;
      return false;
    }
    catch
    {
      return false;
    }
    finally
    {
      Stack.Clear();
    }
  }
}

public class DisposePatternContainer
{
  public DisposePattern GetDisposePattern()
  {
    return  new DisposePattern();
  }

  public struct DisposePattern : IDisposable
  {
    bool IteratedOnce;

    public bool MoveNext() 
    {
      if (!IteratedOnce)
        return (IteratedOnce = true);
      return false;
    }

    public int Current 
    { 
      get 
      { 
        return 1;
      } 
    }

    public void Reset()
    {

    }

    public void Dispose()
    {
      Tracer.Log(2);
    }
  }
}

public class TestContext
{
  public static void ExecuteTest(bool Throw)
  {
    Tracer.Log(0);
    using(DisposePatternContainer.DisposePattern Pattern = new DisposePatternContainer().GetDisposePattern())
    {
      if (Throw)
        throw new Exception();
      Tracer.Log(Pattern.Current);
    }
    Tracer.Log(3);
  }
}


public class Test
{
  public static int Main()
  {
    bool Success = true;
  
    TestContext.ExecuteTest(false);
    if (!Tracer.VerifyTrace(3,2,1,0))
    {
      Success = false;
      Console.WriteLine("Failed @ TestContext.ExecuteTest(false): unexpected execution sequence");
    }


    try
    {
      TestContext.ExecuteTest(true);
      Success = false;
      Console.WriteLine("Failed @ TestContext.ExecuteTest(true): didn't throw");
    }
    catch
    {
      if (!Tracer.VerifyTrace(2,0))
      {
        Success = false;
        Console.WriteLine("Failed @ TestContext.ExecuteTest(true): unexpected execution sequence");
      }
    }
    
    if (Success)
      return 0;
    return 1;
      
    
  }
}
`
`
using System;

interface test 
{
	abstract int this [ int ident1 ] { get; set; }
}

class main
{
	public static void Main() {}
}
`
(5,2): error CS0106: The modifier 'abstract' is not valid for this item
`
using System;

public struct S {
    public int NXT;
}


public class Test {

    S RCV;

    public static void Main () {

        Test t = new Test();

        Foo(t, 5);

        Console.WriteLine(t.RCV.NXT);
    }


    public static void Foo(Test t, int ss) {
        t.RCV.NXT+=ss;
    }
}
`
5
`
`/debug
using System;
using System.Diagnostics;

public class Test {

  public static void Main() {
    DebugPrint("Hello");
    Console.WriteLine("Done.");
  }

  [Conditional("DEBUG")]
  public static void DebugPrint(string s) {
    Console.WriteLine(s);
  }
}
`
Done.
`
using System;

[assembly : A]
[param:A]
[foo: A]
[module:A]

[A]
public class foo 
{
  [method:A][foo:A]//[param:A]

  public static int Main() { return 0; }
  
  [foo:A]//[param:A]
  public static int Foo
  {
    [method:A][foo:A]//[param:A]
    get { return 0; }
    [method:A][foo:A][param:A]
    set {}
  }
}

[AttributeUsage(AttributeTargets.All)]
public class A : Attribute
{
}
`
(5,7): warning CS0658: 'foo' is not a recognized attribute location. All attributes in this block will be ignored.
(11,18): warning CS0658: 'foo' is not a recognized attribute location. All attributes in this block will be ignored.
(15,8): warning CS0658: 'foo' is not a recognized attribute location. All attributes in this block will be ignored.
(18,20): warning CS0658: 'foo' is not a recognized attribute location. All attributes in this block will be ignored.
(20,20): warning CS0658: 'foo' is not a recognized attribute location. All attributes in this block will be ignored.
(4,2): warning CS0657: 'param' is not a valid attribute location for this declaration. Valid attribute locations for this declaration are 'type'
`
`/unsafe
using System;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Explicit)]
partial class C
{
  public int fld1;
  public int fld2;
}
[StructLayout(LayoutKind.Sequential)]
partial class C
{
    [FieldOffset(0)]
    public int fld3;

    [FieldOffset(0)]
    public int fld4;
}
  
unsafe public class Test
{
  public static int Main()
  {
    C c = new C();

    return 1;
  }
}
`
(10,2): error CS0579: Duplicate 'StructLayout' attribute
(7,14): error CS0625: 'C.fld1': instance field types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute
(8,14): error CS0625: 'C.fld2': instance field types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute
`
using System;

struct S
{
    void F() { Console.WriteLine("here"); }

    static void Main()
    {
        int x = 0;
        switch (x)
        {
            case 0:
                default(S).F();
                break;
            case 2:
                goto default;
            default:
                break;
        }
    }
}
`
here
`
using System.Threading;
using System;
class Test
{
    volatile IntPtr instanceIntPtrVolatileField;
    static volatile IntPtr staticIntPtrVolatileField;
    static void Main()
    {
        Test t = new Test();
        // Volatile Write
        t.instanceIntPtrVolatileField = IntPtr.Zero;
        Test.staticIntPtrVolatileField = IntPtr.Zero;
        // Volatile Read
        Foo(t.instanceIntPtrVolatileField);
        Foo(Test.staticIntPtrVolatileField);
    }

    static void Foo(IntPtr intPtr) { /* Do Nothing*/ }
}
`
`
using System;

public class main
{
    static public int Method()
    {
        return 1;
    }

    public static int Main()
    {
        if ((sizeof(string) == Method()) || (sizeof(int) != Method()))
            return 1;

    }
}
`
(12,21): error CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type ('string')
(12,14): error CS0233: 'string' does not have a predefined size, therefore sizeof can only be used in an unsafe context (consider using System.Runtime.InteropServices.Marshal.SizeOf)
`
using System;

public class main
{
  public static int Main() 
    {
    int a = 0;
    a = sizeof(int);
    Console.WriteLine(a);

    return 0;
    }
}
`
4
`
using System;

public class A
{
   public static int Main()
   {
      B b = Result;

      return C.foo(new A(), b);

   }

   static int Result(A a)
   {
       return 0;
   }
  
}

public delegate int B(A a);

internal class C
{
    public static int foo(A a, B b)
    {
        return b.Invoke(a);   
    }
}
`
`
`/unsafe
using System;
 
unsafe public class Test {
    public static void Main() {
 
        byte x = 5;
 
        Foo((UIntPtr)(&x));
    }
    
    public static void Bar(object o) {
        Console.WriteLine("Value = {0}", o);
    }
    private static void Foo(UIntPtr data)
    {
        Bar(*(byte*)data);
    }
 
}
`
Value = 5
`
class Test
{
    // no ICE
    public enum E { a = 0x0 }

    static void Main()
    {
        // no ICE
        E e1 = (E)0x01;

        //ICE
        E e2 = (E)0x00;

        //ICE
        E e3 = 0x00;

        // ICE
        bool b = 0x00 > E.a;

    }
}
`
(9,11): warning CS0219: The variable 'e1' is assigned but its value is never used
(12,11): warning CS0219: The variable 'e2' is assigned but its value is never used
(15,11): warning CS0219: The variable 'e3' is assigned but its value is never used
(18,14): warning CS0219: The variable 'b' is assigned but its value is never used
`
`/p:v2
public class MyClass
{
    static int Main() 
    {
        return 0;
  }
    static int Main<T>() 
    {
        return 1;
    }
    int Main<T, J>()
    {
        return 1;

    }
    void Main(string[] s) { }
    void Main<T>(string[] s) { }
    void Main<T, J>(string[] s) { }
    static void Main<T>(int i, int j) { }
    static void Main<T, U>(int i, int j) { }

}

public class AnotherClass
{
    static int Main<T>() 
    { 
        return 1;
    }
}
public class YetAnotherClass<T>
{
    static int Main()
    {
        return 1;
    }
}
`
(7,16): warning CS0402: 'MyClass.Main<T>()': an entry point cannot be generic or in a generic type
(19,17): warning CS0028: 'MyClass.Main<T>(int, int)' has the wrong signature to be an entry point
(20,17): warning CS0028: 'MyClass.Main<T,U>(int, int)' has the wrong signature to be an entry point
(26,16): warning CS0402: 'AnotherClass.Main<T>()': an entry point cannot be generic or in a generic type
(33,16): warning CS0402: 'YetAnotherClass<T>.Main()': an entry point cannot be generic or in a generic type
`
`/p:v2
class A { }
class B : A { }
class C : B { }

delegate void D1(B b);
delegate B D2();

class Target
{
  public static int _verify = 0;
  void M1(A a) { _verify = 1; }  // new target for D1 (Contravariance)
  void M2(B b) { _verify = 2; }  // existing target for D1
  void M3(C c) { _verify = 3; }

  A M4() { _verify = 4; return null; }
  B M5() { _verify = 5; return null; } // existing target for D2
  C M6() { _verify = 6; return null; } // new target for D2 (covariance)

  static bool Verify(int expected)
  {
    return _verify == expected;
  }

  static int Main()
  {
    Target t = new Target();
    {
      D1 d1 = t.M1; // contravariance 
      D2 d2 = t.M6; // covariance

      d1(new C());
      if (!Verify(1)) return 1;
      d2();
      if (!Verify(6)) return 1;
    }
    {
      D1 d1 = t.M2; // normal binding
      D2 d2 = t.M5; // normal binding

      d1(new C());
      if (!Verify(2)) return 1;
      d2();
      if (!Verify(5)) return 1;
    }
    return 0;
  }
}
`
`
`/p:v2
using System;
using System.Collections.Generic;
using System.Text;

delegate void D(B b);
delegate A Del();

class A { }
class B : A { }

class P
{
  static int i = 0;
  void Foo<T>(T t) { i++; }
  T Bar<T>() { i++;  return default(T); }

  static int Main(string[] args)
    {
    P p = new P();
    D d = p.Foo<A>;
    Del dd = p.Bar<B>;

    d(new B());
    dd();
    if(i != 2 ) return 1;
    else return 0;
  }
}
`
`
public class M {

  public static void Main() {
    int i = -1;
    ulong  dirCount = (ulong)i;
    System.Console.WriteLine(dirCount);
  }
}
`
18446744073709551615
`
public class Base<T>
{
}

public class Derived : Base<Derived.Delegate>
{
    public delegate void Delegate();
    public static void Main(){}
}
`
`
public class RefParam {
  static void M(ref int index) {
    while (index < 10) {
      ++index;
    }
  }
  
  public static int Main(){
    int foo = 8;
    M(ref foo);
    return foo - 10;
  }
}
`
`
using System;

public class Test{
  void foo(EventHandler/*!*/ h){
    h(this, new EventArgs());
  }
  
  public static void Main(string[] args){
    Test t = new Test();
    t.foo(t.bar);
  }
   
  void bar(object sender, EventArgs args){
    Console.WriteLine("handler called");
  }
    
}
`
handler called
`
#define BBBBB
 
#if ! AAAAA
 
public class EmptyHashIf {
  public static void Main() {
#if BBBBB
#else
#endif
 
#if BBBBB
#else
    x = 12;
#endif
  }
}
 
#endif
`
`
interface I: J { }
interface J {
  int this[string s] {
	get;
	set;
  }
}
class I_Test {
  private void test2(I i) {
	int ts = i["hi"];
	i["there"] = ts;
  }
}
public class MainC { public static void Main(){ } }
`
`
using System;
 
public interface IT {
 
    void IDo();
}
 
public class N<T> where T : struct, IT {
 
    public static void Test(T n) {
        n.IDo();
    }
}
 
public class Test {
 
    public static void Main() {
    }
 
}
`
`
using System;

public class MyAttr : Attribute { }
 
namespace Foo
{
  public class Class<[MyAttr] T>
  {
  }
}
 
public class Test{public static void Main(){}}
`
`
`/p:v2
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System;
using Microsoft.FxCop.Sdk;

[assembly: InternalsVisibleTo("ReliabilityRules, PublicKey= " + FxCopConstants.PublicKey)]
 
namespace Microsoft.FxCop.Sdk
{
  public sealed class FxCopConstants
  {
    private FxCopConstants() {}  
 
    public const string PublicKey =
            "00240000048000009400000006020000002400005253413100040000010001005ddb167a729ebc" +
            "80b18af8dba27790008fe9b3542d25ae449ca3034d97a6a4dd74483bf4bdfe6cc141d538656e30" +
            "ebbba4cef5954637c894762e09c34b1385db5d8ccccffeec08e3fa52e39326c1619c37727f43fc" +
            "9d0de6b1edb6fcff89270a2ee17736b30ff2ba4598d3f84726d0d6da1a5a9627d30254e0b1f4a5" +
            "93ae1de8";
            
    public static void Main(){}
  }
}
`
`
using System;

class b{
  private int foo;
}

class d : b{
  private int foo;
  public static void Main(){}
}
`
`
using System;

class b{
  ~b(){}
}

class d : b{
  private int Finalize;
  public static void Main(){}
}
`
`
`/unsafe
class Test{
  const string foo = "bar";
  public static void Main(){
    unsafe{
      fixed (char* p = foo){
        char* q = p;
        q = q;
      }
    }
  }
}
`
`
class Foo{
  internal virtual bool Equals(object one, string two){
    return false;
  }
}

class Bar : Foo{
  internal override bool Equals(object one, string two){
    return base.Equals(one, null);
  }
}

class Test
{
    public static void Main()
    {
    }
}
`
`
using System.CodeDom;

class Test
{

    static int? foo(){return null;}

    public static int Main()
    {
      int bar = foo() ?? 5;
      return bar - 5;
    }

}
`
`
class Test{
    public static int Main()
    {
      string foo = null;
      string bar = foo ?? "one";
      return bar.Length - 3;
    }
}
`
`
class Test{
  public int this[int i]{get {return 0;} set{}}
  public void foo(ref Test t){
    t[0] = 1;
  }
  public static void Main() {
    Test t = new Test();
    t.foo(ref t);
  } 
}
`
`
struct S {

  public int this[string s] {
            set { }
  }

  public void test() {
            this["there"] = 7;
  }
}
class Test{
  public static void Main(){
    S s = new S();
    s.test();
  }
}
`
`
using System;
using System.Collections;

class C:IEnumerable{
  int[] xs;
  public IEnumerator GetEnumerator(){ 
    foreach (int x in xs)
      yield return x; 
  }
  public static void Main(){}
}
`
`
`/p:v2
class Test<U>
{
    public static void M<T>() where T : U
    {
    }
 
}
 
class Test
{
    static void Main()
    {
        Test<int>.M<int>();
    }
}
`
`
public class Base
{
  public string Text 
  {
    get 
    { 
      return "Base.get"; 
    }
    set 
    { 
      Test.Action = "Base.set";
    }
  }
}

public class Sub : Base
{
  new protected string Text 
  {
    get 
    { 
      return "Sub.get"; 
    }
    set 
    { 
      Test.Action = "Sub.set";
    }
  }
}

public class Test
{
  public static string Action = null; 

  public static int Main() 
  {
    new Sub().Text = "Access Base.Text";
    
    if (new Sub().Text.Equals("Base.get") && Action.Equals("Base.set"))
      return 0;
    return 1;
  }
}
`
`
using System;

public struct Gen<T>  
{
  public int val;
  public Gen(int val) { this.val = val; }

  public static Gen<T> operator ++ (Gen<T> g)
  {
    return new Gen<T>(g.val+1);
  }

  public override string ToString() { return val.ToString();}
    
}
  
public class Test
{
  public static int counter = 0;
  public static bool result = true;
  public static void Eval(bool exp)
  {
    counter++;
    if (!exp)
    {
      result = exp;
      Console.WriteLine("Test Failed at location: " + counter);
    }
  
  }
  
  public static int Main()
  {     
    Gen<string> g = new Gen<string>(0);
    Test.Eval(g++.val==0);
    Test.Eval(++g.val==2);
    
              if (result)
              {
      return 0;
    }
    else
    {
      return 1;
    }
  }
}
`
`
// Make sure that equality tests cannot be performed on type parameters (CS0019)
class C<T>{
  void foo(T t1, T t2){ if (t1 == t2) return; }
  void bar(T t1, T t2){ if (t1 != t2) return; }
}
class M{ public static void Main(){} }
`
(3,29): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'T'
(4,29): error CS0019: Operator '!=' cannot be applied to operands of type 'T' and 'T'
`
// Make sure that equality tests can be performed on type parameters when constrained to be reference types
class C<T> where T : class{
  void foo(T t1, T t2){ if (t1 == t2) return; }
  void bar(T t1, T t2){ if (t1 != t2) return; }
}
class M{ public static void Main(){} }
`
`
// Make sure that equality tests cannot be performed on type parameters (CS0019)
class C<T> where T : struct{
  void foo(T t1, T t2){ if (t1 == t2) return; }
  void bar(T t1, T t2){ if (t1 != t2) return; }
}
class M{ public static void Main(){} }
`
(3,29): error CS0019: Operator '==' cannot be applied to operands of type 'T' and 'T'
(4,29): error CS0019: Operator '!=' cannot be applied to operands of type 'T' and 'T'
`
class t {
    static t() { System.Console.WriteLine("static ctor #1"); }
    static t() { System.Console.WriteLine("static ctor #2"); }
    public static void Main() { System.Console.WriteLine("main"); }
}
`
(3,12): error CS0111: Type 't' already defines a member called 't' with the same parameter types
(2,12): (Location of symbol related to previous error)
`
using System;
using System.Collections.Generic;
 
public class Node{
  public int elt;
  public Node next;
}
 
public class C {
  Node head;
  [Microsoft.Contracts.NotDelayed]
  public C(){ head = new Node(); head.elt = 3; }
  public IEnumerator<int> GetEnumerator() {
    for (Node t = head; t != null; t = t.next)
      yield return t.elt;
  }
}
 
class Program {
  static void Main(string[] args) {
    C c = new C();
    IEnumerator<int> e = c.GetEnumerator();
    Console.WriteLine(e.MoveNext());
    Console.WriteLine(e.MoveNext());
    Console.WriteLine(e.MoveNext());
  } 
}
`
True
False
False
`
`/p:v2
using System;
 
class foo<T>{
  internal class bar{}
}

public class Program
{
    public static void Main() { 
      Console.WriteLine(typeof(foo<>.bar).Name);
    }
}
`
bar
`
`/nonnull /p:v2
using System;
using System.Runtime.InteropServices;
 
namespace SpecSharpBugs {
  class Program {
    static void Main(string[] args) {
    }
  }
 
  class Invalid_CS182 {
    const string DllName = "Microsoft.Internal.Performance.CodeMarkers.dll";
    class NestedClass {
      [DllImport(DllName)]
      public static extern void DllPerfCodeMarker();
    }
  }
 
  class Invalid_CS508 {
    abstract class BaseClass {
      public abstract T?[] GetAttributes<T>() where T : Attribute;
    }
    class DerivedClass : BaseClass
    {
      public override T?[] GetAttributes<T>() where T : Attribute
      {
        return new T?[0];  // This should not be included in CSharpComformace.Suite because the two is not compatible. 
      }
    }
  }

  class Invalid_CS121 {
    class A { }
    class B { }
    class C { }
    
    private void Foo(Guid id, B[] blist, params A[] alist) { }
    private void Foo(C c, B[] blist, params A[] alist) { }
    private void Foo(C c, params A[] alist) { }
 
    private void Test() {
      Foo(new C(), new A(), new A()); 
    }
  }

  class Invalid_CS150 {
    class A {
      internal const string Value = "foo";
    }
    class B {
      void Test() {
        switch (string.Empty) {
          case A.Value: // CS150: A constant value is expected
            break;
        }
      }
    }
  }
  class Invalid_CS29 {
    class Resource : IDisposable {
      public void Dispose() {
      }
    }
    void Test() {
      using (Resource r = new Resource())
      {
      }
    }
  }
}
`
`
public enum Foo {
  A = 2,
  B = A << 1
}

class Test{
  public static void Main(){
    System.Console.WriteLine((int)Foo.B);
  }
}
`
4
``/compatibility
namespace ConsoleApplication1
{
    class Program
    {
        static int Foo { get { return 0; } set { } }
        public static void Bar(ref int f){ f = 0;}
        public static void Main(){ Bar( ref Foo);}
    }
 
}
`
(7,45): error CS0131: The left-hand side of an assignment must be a variable, property or indexer
`
`/nonnull-
class Test<T> {

  public static T? M() {
      return default(T);
  }
}
public class T{ public static void Main(){}}
`
`
class Test<A,B> where B:A {

  public static A M(B b) {
    return (A)b;
  }
}
public class T{ public static void Main(){}}
`
`
enum foo{ bar }

enum foo2{ bar1 = foo.bar << 1, bar2 = 1 << foo.bar }

public class C{ 
  public static void Main(){
  }
}
`
`
enum foo{ bar }

enum foo2{ bar1 = foo.bar | 1, bar2 = 1 & foo.bar }

public class C{ 
  public static void Main(){
  }
}
`
`
`/p:v2 /nn+
class InvalidCS654 : System.EventArgs{
    void Test(object/*?*/ sender, InvalidCS654 arg){
        System.EventHandler<InvalidCS654> handler = Test;
        if (handler != null) handler = Test;
    }
   public static void Main(){}
}
`
`
`/p:v2
namespace InvalidCS1041
{
    interface I
    {
        object this[object index] { get; }
    }
    class C : I
    {
        object InvalidCS1041.I.this[object index]
        {
            get { return null; }
        }
        public static void Main(){}
    }
}
`
`
`/p:v2
public class ErrorNode{}
public enum TokKind{CurlOpen}
public class ParseNode{}

public class C{ 
            private delegate T ItemParserVal<T, D>(D d) where T : ParseNode;
            private delegate T ItemParserRef<T, D>(ref D d) where T : ParseNode;
            
    void ParseList<T, D>(ref ErrorNode err, bool fOpt, TokKind tidOpen, D data, ItemParserVal<T, D> ip) where T : ParseNode
    {
    }
	void ParseList<T, D>(ref ErrorNode err, bool fOpt, TokKind tidOpen, ref D data, ItemParserRef<T, D> ip) where T : ParseNode
	{
	}
    ParseNode ParseExprOrArrayInit(ref ErrorNode err)
    {
      return new ParseNode();
    }
    void foo(ref ErrorNode err){
		this.ParseList<ParseNode, ErrorNode>(ref err, true, TokKind.CurlOpen, ref err, ParseExprOrArrayInit);
    }
  public static void Main(){
  }
}
`
`
`/p:v2
public class ErrorNode{}
public enum TokKind{CurlOpen}
public class ParseNode{}
public class ListNode<T>{
  public class Bldr{}
}

public class C{ 
  private delegate T ItemParserVal<T, D>(D d) where T : ParseNode;
  private delegate T ItemParserRef<T, D>(ref D d) where T : ParseNode;
            
	void ParseList<T, D>(ref ErrorNode err, bool fOpt, TokKind tidOpen, ref D data, ItemParserRef<T, D> ip) where T : ParseNode
	{
	  ListNode<T>.Bldr bldr = new ListNode<T>.Bldr();
	  FParseOpen(ref err, ref bldr, tidOpen);
	}
  bool FParseOpen<X>(ref ErrorNode err, ref ListNode<X>.Bldr bldr, TokKind tid) where X : ParseNode{
    return false;
  }
	
  public static void Main(){
  }
}
`
`
`/p:v2
using System;

public class A{}
public class B{}
public class C{}

public class G1<T>{}
public class G2<T,U> {}
public class G3<T,U,V> {}

public class G1G1<T> : G1<T> {}

public class Gen
{
  public Type[] infered;
  public void Method<T>(G1<T> p1)
  {
    infered = new Type[]{typeof(T)};
  }
}

public class Test
{
  public static int counter = 0;
  public static bool result = true;
  public static void Eval(bool exp)
  {
    counter++;
    if (!exp)
    {
      result = exp;
      Console.WriteLine("Test Failed at location: " + counter);
    }
  
  }
  
  public static int Main()
  {
    Gen g = new Gen();

    g.Method(new G1G1<A>());
    Test.Eval(g.infered[0].Equals(typeof(A)));

    g.Method(new G1G1<G2<A,B>>());
    Test.Eval(g.infered[0].Equals(typeof(G2<A,B>)));

    g.Method(new G1G1<G3<A,B,G2<G1<int>,G1<string>>>>());
    Test.Eval(g.infered[0].Equals(typeof(G3<A,B,G2<G1<int>,G1<string>>>)));

    
    if (result)
    {
      return 0;
    }
    else
    {
      return 1;
    }
  }
    
}
`
`
`/p:v2
using System;

public class A{}
public class B{}
public class C{}

public interface IG1<T>{}

public class G1<T>{}
public class G2<T,U>{}
public class G3<T,U,V>{}

public class G1IG1<T> : IG1<T> {}

public class Gen
{
	public Type[] infered;
	public void Method<T>(IG1<T> p1)
	{
		infered = new Type[]{typeof(T)};
	}
}

public class Test
{
	public static int counter = 0;
	public static bool result = true;
	public static void Eval(bool exp)
	{
		counter++;
		if (!exp)
		{
			result = exp;
			Console.WriteLine("Test Failed at location: " + counter);
		}
	
	}
	
	public static int Main()
	{
		Gen g = new Gen();

		g.Method(new G1IG1<A>());
		Test.Eval(g.infered[0].Equals(typeof(A)));

		g.Method(new G1IG1<G2<A,B>>());
		Test.Eval(g.infered[0].Equals(typeof(G2<A,B>)));

		g.Method(new G1IG1<G3<A,B,G2<G1<int>,G1<string>>>>());
		Test.Eval(g.infered[0].Equals(typeof(G3<A,B,G2<G1<int>,G1<string>>>)));

		
		if (result)
		{
			return 0;
		}
		else
		{
			return 1;
		}
	}
		
}
`
`
`/p:v2
using System;
using System.Collections.Generic;

public struct Struct { }
public class BaseClass { }
public class DerClass : BaseClass { }

public struct GenStruct<T> { }
public class GenBaseClass<T> { }
public class GenDerClass<T> : GenBaseClass<T> { }


public class Foo
{	
	public static void MIE<T>(IEnumerable<T> t) { }
	public static void MIL<T>(IList<T> t) { }
}

public class Test
{
	public static void ConstructedTypeTest()
	{

		//Class inference from T[] to IList<T>}
		Foo.MIL(new DerClass[] { });
		Foo.MIL(new BaseClass[] { });
		Foo.MIL(new object[] { });

		//Class inference from T[] to IEnumerable<T>}
		Foo.MIE(new DerClass[] { });
		Foo.MIE(new BaseClass[] { });
		Foo.MIE(new object[] { });

		//Struct inference from T[] to IList<T>, IEnumerable<T>
		Foo.MIL(new Struct[] { });
		Foo.MIE(new Struct[] { });
	}

	public static void GenericTypeTest<T>()
	{

		//Generic inference from T[] to IList<T>}
		Foo.MIL(new T[] { });
		Foo.MIE(new T[] { });
	}

	public static void Main()
	{
		ConstructedTypeTest();
		GenericTypeTest<string>();
		GenericTypeTest<BaseClass>();
		GenericTypeTest<Struct>();
	}
}
`
`
`/p:v2
public class ErrorNode{}
public enum TokKind{CurlOpen}
public class ParseNode{}
public class Token{}

public class C{ 
  private delegate T ItemParserVal<T, D>(D d) where T : ParseNode;
  private delegate T ItemParserRef<T, D>(ref D d) where T : ParseNode;
            
	void ParseList<T, D>(ref ErrorNode err, bool fOpt, TokKind tidOpen, ref D data, ItemParserRef<T, D> ip) where T : ParseNode
	{
	  ParseNode meth = new ParseNode();
    AppendError(meth, new Token(), TokKind.CurlOpen, meth);
	}
  T AppendError<T>(T node, Token tok, TokKind eid, params object[] args) where T : ParseNode
  {
      return node;
  }

	
  public static void Main(){
  }
}
`
`
`/p:v2
using System.Collections.Generic;
using System.Threading;

public class Entry{}

public class C{ 
  
 private static List<Entry> g_rgentAvail;

 private static void OfferList(ref List<Entry> rgent)
  {
  rgent = Interlocked.Exchange(ref g_rgentAvail, rgent);
  }
	
  public static void Main(){
  }
}
`
`
`/nowarn:626
class t {
  public static void Main() { }

  public static extern int operator !(t b);
  public static extern int operator +(t b, int i);
  public static extern int operator *(int d, t b);
  public static extern implicit operator t(int x);
  public static extern explicit operator int(t b);
  public static extern implicit operator t(string x);
  public static extern explicit operator string(t b);
}
`
`
`/nowarn:626
class t {
  public static void Main() { }
  public extern event DD e;
}
delegate void DD();
`
`
`/p:v2
class t {
  public static void Main() {
    new S("hi",42).test();
  }
}
struct S {
  string s;
  int i;
  public S(string s0, int i0) { s = s0; i = i0; }
  public override string ToString() { return "S<" + s + "," + i + ">"; }

  public static int operator +(S c, int i) { return 2; }
  public static int operator *(int i, S c) { return 4; }
  public static implicit operator S(int x) { return new S("hi",42); }
  public static explicit operator int(S c) { return c.i; }
  public static explicit operator S(string x) { return new S("hi",42); }
  public static implicit operator string(S c) { return c.s; }
  
  public void test() {
    Check.Value(this + 3, 2);
    Check.Value(3 * this, 4);
    S c = 5; Check.Value(c, new S("hi",42));
    Check.Value((int)this, 42);
    Check.Value((S)"bob", new S("hi",42));
    string s = this; Check.Value(s, "hi");
    System.Console.WriteLine("");
  }
}
class Check {
  public static void Value(object computed, object expected) {
    if (computed == null) computed = "<null>";
    if (expected == null) expected = "<null>";
    System.Console.Write("{0}", computed); 
    if (computed.ToString() != expected.ToString()) { 
      System.Console.Write("[WRONG! should be {0}]", expected);
    }
    System.Console.Write(" "); 
  }
}  
`
2 4 S<hi,42> 42 S<hi,42> hi 
`
class foo<T> where T : class{
   public void bar(T t){
     T x = t;
     if (x == t) return;
   }
}
class Test{ public static void Main(){foo<string> fum = new foo<string>(); fum.bar("one");}}
`
`
`/unsafe
using System;

class PointerArithmetic
{
    static unsafe int Main()
    {
        decimal[] ia = new decimal[5] {2,4,6,8,10};

        // pointer used to test each operator overload
        decimal* tmpPtr, newPtr;

        fixed (decimal* ptr = ia) 
        {
            decimal* endPtr = ptr + ia.Length;

            // T* operator -(T* x, int y);
            tmpPtr = endPtr - 2;
            if ( *tmpPtr != ia[ia.Length - 2] )
                return 1;

            // T* operator -(T* x, decimal y);
            tmpPtr = endPtr - 2u;
            if ( *tmpPtr != ia[ia.Length - 2] )
                return 2;

            // T* operator -(T* x, decimal y);
            tmpPtr = endPtr - 2L;
            if ( *tmpPtr != ia[ia.Length - 2] )
                return 3;

            // T* operator -(T* x, udecimal y);
            tmpPtr = endPtr - 2UL;
            if ( *tmpPtr != ia[ia.Length - 2] )
                return 4;

            // decimal operator -(T* x, T* y);
            tmpPtr = endPtr;
            newPtr = endPtr - 2;
            if ( tmpPtr - newPtr != 2 )
                return 5;
        }

        // all tests passed if we get to this point
        return 0;
    }
}
`
`
`/unsafe
using System;

class PointerArithmetic
{
    static unsafe int Main()
    {
        sbyte[] ia = new sbyte[5] {2,4,6,8,10};

        // pointer used to test each operator overload
        sbyte* tmpPtr;

        fixed (sbyte* ptr = ia) 
        {
            // T* operator +(T* x, int y);
            tmpPtr = ptr + 2;
            if (*tmpPtr != ia[2])
                return 1;
            
            // T* operator +(T* x, uint y);
            tmpPtr = ptr + 2u;
            if (*tmpPtr != ia[2])
                return 2;

            // T* operator +(T* x, long y);
            tmpPtr = ptr + 3L;
            if (*tmpPtr != ia[3])
                return 3;
            
            // T* operator +(T* x, ulong y);
            tmpPtr = ptr + 4UL;
            if (*tmpPtr != ia[4])
                return 4;

            // T* operator +(int x, T* y);
            tmpPtr = 2 + ptr;
            if (*tmpPtr != ia[2])
                return 5;

            // T* operator +(uint x, T* y);
            tmpPtr = 2u + ptr;
            if (*tmpPtr != ia[2])
                return 6;

            // T* operator +(long x, T* y);
            tmpPtr = 4L + ptr;
            if (*tmpPtr != ia[4])
                return 7;

            // T* operator +(ulong x, T* y);
            tmpPtr = 3UL + ptr;
            if (*tmpPtr != ia[3])
                return 8;
        }

        // all tests passed if we get to this point
        return 0;
    }
}
`
`
`/unsafe
public class Test {

    unsafe public void Bad5(ref int p)
    {
        int x = *p;
    }

    public static void Main() {}

}
`
(5,17): error CS0193: The * or -> operator must be applied to a pointer
`
`/unsafe
//
// Check that complicated LHS is only evaluated once.
//
using System;

namespace Microsoft.Singularity.Applications
{
    unsafe public class SharedHeapTest
    {

        public static void Main(String[] args)
        {
            int b = 0x3;

            int* bp = &b;
            SetBits( 0xf0, (UIntPtr)bp);

            Console.WriteLine("b = {0:x}", b);
        }

        private static UIntPtr GetAddress(UIntPtr address) {
            Console.WriteLine("GetAddress called");
            return address;
        }
        
        private static void SetBits(byte bit, UIntPtr address)
        {
            *(byte*)GetAddress(address) |= bit;
        }

    }
}
`
GetAddress called
b = f3
`
enum Flags {
    ReadOnly = 0x32,
}

class RaviTest {

    public static void Main() {
    }

    public void Bad(Flags flags) {

        bool Write;

        Write = ! (flags & Flags.ReadOnly);
    }

}
`
(14,20): error CS0029: Cannot implicitly convert type 'Flags' to 'bool'
`
// 
// Checks that we are inserting proper box operation in yield
//
using System.Collections.Generic;

interface IEdge {
}


class Test {

    struct S : IEdge {
    }
    
    public IEnumerable<IEdge/*!*/>/*!*/ Successors() 
    {
        Dictionary<string, S> edges = new Dictionary<string,S>();

        yield return edges["f"];
    }

    public static void Main() {}
}
`
`
// Test that auto delegate construction works even if
// we take methods off non-null objects.
// A Strip Type modifier was missing.
//
using System;
using System.Collections.Generic;

class Graph<T, S> {
}

interface IVisitor<T, S> {

    bool Pred(T t);
}

class App<T, S> {

    public App(IVisitor<T, S> v) :
        this(null, v.Pred, v.Pred)
    {
    }

    public App(Graph<T, S> g, IVisitor<T, S>/*!*/ v) :
        this(g, v.Pred, v.Pred)
    {
    }

    public App(Graph<T, S> g, Predicate<T> p) {}

    public App(Graph<T, S> g, Predicate<T>/*!*/ p, Predicate<T> q) {}
}

class Test {
    public static void Main() {}
}
`
`
//
// Check that we don't add newslot when overriding and making abstract 
//
namespace Microsoft.MidoriTest
{
    using System;

    /// Generic host for a remote object handler
    public interface IHost/*<T>*/
    {
        bool DoOne();

        void DoAll();
    }

    public abstract class Host : IHost
    {
        public virtual void Start() {
        }

        public virtual void DoAll() {
            while (DoOne()) {
            }
        }

        abstract public bool DoOne();
    }

    /// receives a message stream over a singularity channel
    public abstract class SingHost : Host
    {
        public SingHost() {
        }

        /// subclasses should override these to provide type-specific behaviorf
        override abstract public bool DoOne();
    }


    /// Handles console events coming in over a Singularity console device channel
    internal class SingConsoleHost : SingHost
    {
        int i = 5;
        public SingConsoleHost() {
        }

        override public bool DoOne() {
            return i-- > 0;
        }
    }

    public class Foo
    {
        public static void Main(string[] args)
        {
            new SingConsoleHost().DoAll();
        }
    }        
}
`
`
using System.Diagnostics;

[DebuggerTypeProxy(typeof(BitSet.DebugView))]
public class BitSet
{
      private class DebugView
      {
      }
      public static void Main(){}
}
`
`
using System;
using System.Diagnostics;
 
namespace N
{
      public class Debug 
      {
            public static int Field;
      }
}
 
namespace N.M
{
 
      public class Program
      {
            static void Main (string[] commandLineArgs)
            {
                  Console.WriteLine(Debug.Field);
            }
      }
}
`
0
`
public class Program{
  static bool M<T>(T a)  {
    string b = a as string;
    return b != null;
  }
  public static void Main(){}
}
`
`
using System;
 
public class Program
{
            public Expression/*!*/ Expression { get { return expression; } }
            private Expression/*!*/ expression = new Expression();
 
            public static Expression2/*!*/ Expression2 { get { return expression2; } }
            private static Expression2/*!*/ expression2 = new Expression2();
 
            static void Main(string[] commandLineArgs)
            {
                  Console.WriteLine(Expression.Context.Read);
                  Console.WriteLine(Expression2.Context.Read);
            }
}
 
public class Expression
{
      public enum Context
      {
            Read,
            Write
      }
}
 
public class Expression2
{
      public enum Context
      {
            Read,
            Write
      }
}
`
Read
Read
`
using System;
 
public class Program
{
            public Expression/*!*/ Expression { get { return expression; } }
            private Expression/*!*/ expression = new Expression();
 
            public static Expression/*!*/ Expression2 { get { return expression2; } }
            private static Expression/*!*/ expression2 = new Expression();
 
            static void Main(string[] commandLineArgs)
            {
                  Console.WriteLine(Expression.Context.Read);
                  Console.WriteLine(Expression2.Context.Read);
            }
}
 
public class Expression
{
      public enum Context
      {
            Read,
            Write
      }
}
 
public class Expression2
{
      public enum Context
      {
            Read,
            Write
      }
}
`
(14,49): error CS0572: 'Context': cannot reference a type through an expression; try 'Expression.Context' instead
`
public class Foo<T> where T: class {
  public Foo(){
    T t = null;
  }
}
class Test{
  public static void Main(){
    Foo<string> bar = new Foo<string>();
  }
}
`
(3,7): warning CS0219: The variable 't' is assigned but its value is never used
(8,17): warning CS0219: The variable 'bar' is assigned but its value is never used
`
// Test code gen bug having to do with a change in explicit coercions
//
// The ? expression failed to generate a box and castclass in the
// second branch
using System;
using System.Collections.Generic;

struct Seq<Node> : IEnumerable<Node> {

    public IEnumerable<Node>! OldTopologicalSort()
    {
        Pair<bool,Seq<Node>> result = this.TopSort();
        return  result.First ? result.Second : (IEnumerable<Node>)new Seq<Node>();
    }

    Pair<bool, Seq<Node>> TopSort() {
        return new Pair<bool, Seq<Node>>();
    }

    public IEnumerator<Node> GetEnumerator() {
        yield return default(Node);
    }

    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
        yield return null;
    }

}
    public struct Pair<T1,T2>
    {
        private T1 first;
        private T2 second;

        public T1 First { get { return first; } }
        public T2 Second { get { return second; } }

        public Pair(T1 first, T2 second)
        {
            this.first = first;
            this.second = second;
        }
    }

class C {
    public static void Main() {
        IEnumerable<string> ie = new Seq<string>().OldTopologicalSort();

        foreach (string s in ie) {
            Console.WriteLine(s);
        }
    }
}
`
`
`/unsafe
// Test indirection when ref UIntPtr* is used.
using System;

unsafe class Test {

    public static void Main() {
        UIntPtr*[] ptrarr = new UIntPtr*[2];

        ptrarr[0] = (UIntPtr*)0xfc;
        ptrarr[1] = (UIntPtr*)0xff00ff00ff00;

        UIntPtr* ptr = Simple(ref ptrarr[0]);

        Console.WriteLine("ptr = {0:X}", (ulong)ptr);
    }


    static UIntPtr* Simple(ref UIntPtr *framePointer)
    {
        return framePointer + 1;
    }
}
`
ptr = 100
`
`/unsafe
using System;

unsafe class Test {

    public static void Main() {
        int[] arr = new int[2];
        arr[0] = 55;
        arr[1] = 77;

        fixed (int* ptr = &arr[0]) {
            TestIncPtr(ptr);
        }

        fixed (int* ptr = &arr[1]) {
            TestDecPtr(ptr);
        }

    }

    public static void TestIncPtr(int* ptr) {
        int* tmp1 = ptr;
        PrePtrInc(ref tmp1);
        Console.WriteLine("{0}", *tmp1);

        int* tmp2 = ptr;
        PostPtrInc(ref tmp2);
        Console.WriteLine("{0}", *tmp2);
    }

    public static void TestDecPtr(int* ptr) {
        int* tmp1 = ptr;
        PrePtrDec(ref tmp1);
        Console.WriteLine("{0}", *tmp1);

        int* tmp2 = ptr;
        PostPtrDec(ref tmp2);
        Console.WriteLine("{0}", *tmp2);
    }

    public static void PostPtrDec(ref int* ptr) {
        ptr--;
    }
    public static void PrePtrDec(ref int* ptr) {
        --ptr;
    }
    public static void PostPtrInc(ref int* ptr) {
        ptr++;
    }
    public static void PrePtrInc(ref int* ptr) {
        ++ptr;
    }
}
`
77
77
55
55
`
`/r:System.dll /unsafe 
//
// Check that pointer add and substract performs implicit derefence on
// by refs
using System;
using System.Diagnostics;

unsafe class Test {

    public static void Main() {
        int[] arr = new int[2];
        arr[0] = 55;
        arr[1] = 77;

        fixed (int* ptr = &arr[0]) {
            TestIncPtr(ptr);
        }

        fixed (int* ptr = &arr[1]) {
            TestDecPtr(ptr);
            TestCompare(ptr);
        }

    }

    public static void TestIncPtr(int* ptr) {
        int* tmp1 = ptr;
        Add(ref tmp1);
        Console.WriteLine("{0}", *tmp1);
    }

    public static void TestDecPtr(int* ptr) {
        int* tmp1 = ptr;
        Sub(ref tmp1);
        Console.WriteLine("{0}", *tmp1);
    }

    public static void TestCompare(int* ptr) {
        int* tmp1 = ptr + 1;
        TestComparisons1(ref ptr, ref tmp1, false);
        TestComparisons1(ref tmp1, ref tmp1, true);
        TestComparisons2(ptr, ref tmp1, false);
        TestComparisons2(tmp1, ref tmp1, true);
        TestComparisons3(ref ptr, tmp1, false);
        TestComparisons3(ref tmp1, tmp1, true);
    }

    public static void TestComparisons1(ref int* ptr1, ref int* ptr2, bool same) {
        Debug.Assert(Eq1(ref ptr1, ref ptr2) == same);
        Debug.Assert(Lt1(ref ptr1, ref ptr2) != same);
        Debug.Assert(Lt1(ref ptr2, ref ptr1) == false);
    }

    public static void TestComparisons2(int* ptr1, ref int* ptr2, bool same) {
        Debug.Assert(Eq2(ptr1, ref ptr2) == same);
        Debug.Assert(Lt2(ptr1, ref ptr2) != same);
        Debug.Assert(Lt2(ptr2, ref ptr1) == false);
    }

    public static void TestComparisons3(ref int* ptr1, int* ptr2, bool same) {
        Debug.Assert(Eq3(ref ptr1, ptr2) == same);
        Debug.Assert(Lt3(ref ptr1, ptr2) != same);
        Debug.Assert(Lt3(ref ptr2, ptr1) == false);
    }

    public static void Add(ref int* ptr) {
        int *p = ptr + 1;

        ptr = p;
    }

    public static void Sub(ref int* ptr) {
        int *p = ptr - 1;

        ptr = p;
    }


    public static bool Eq1(ref int* ptr1, ref int* ptr2) {
        return ptr1 == ptr2;
    }

    public static bool Eq2(int* ptr1, ref int* ptr2) {
        return ptr1 == ptr2;
    }

    public static bool Eq3(ref int* ptr1, int* ptr2) {
        return ptr1 == ptr2;
    }

    public static bool Lt1(ref int* ptr1, ref int* ptr2) {
        return ptr1 < ptr2;
    }

    public static bool Lt2(int* ptr1, ref int* ptr2) {
        return ptr1 < ptr2;
    }

    public static bool Lt3(ref int* ptr1, int* ptr2) {
        return ptr1 < ptr2;
    }


}
`
77
55
`
`/unsafe
//
// Check proper dereferencing of data in fixed
//
class Test{

  int f;
  public static void Main(){
  }

  public static void Check(ref string s) 
  {
    unsafe{
      fixed (char* p = s){
        char* q = p;
        q = q;
      }
    }
  }

  public static void Check(ref Test t) {
    unsafe{
      fixed (int* p = &t.f){
        int* q = p;
        q = q;
      }
    }
  }

  public static void Check(ref int[] arr) {
    unsafe{
      fixed (int* p = arr){
        int* q = p;
        q = q;
      }
    }
  }
}
`
`
using System;
using System.Threading;

using Microsoft.Singularity.UnitTest;


namespace Microsoft.Singularity.UnitTest
{
    public class UnitTest {
        
        public static void Clear() {}
    }
}




namespace Microsoft.Singularity.Applications
{
    public class PulseTestsThread {

        public static void Main() {
            UnitTest.Clear();
        }

    }

}
`
(23,13): error CS0234: The type or namespace name 'Clear' does not exist in the namespace 'Microsoft.Singularity.UnitTest' (are you missing an assembly reference?)
`
using System;
using System.Collections;

namespace Microsoft.Singularity.Drivers.Wdf
{
    public abstract class Queue {
        private string parent;

        public string Name {
            get {
                return parent;
            }
        }
    }
}


namespace Microsoft.Singularity.Drivers.Wdf.Net
{
    public class NicDeviceQueue : Queue
    {
    }

    internal class NicDeviceServiceDispatcher
    {
        private Wdf.Net.NicDeviceQueue queue;
        
        public void Initialize()
        {
            string s = queue.Name;
        }


        public static void Main() {}
    }
}
`
(30,20): warning CS0219: The variable 's' is assigned but its value is never used
`
// Check that nested types take precedence over outer namespaces
//
namespace Microsoft.Zap
{
	/// <summary>
	/// Summary description for Zap.
	/// </summary>
	public class Zap {

        public static void Test() {}
    }
}


namespace Microsoft.Zap.Zapper
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class ZapTestClient
	{
        public static void Main() {
            Zap.Test();
        }
    }
}
`
`
using System;

class Test {


    const long Signature = 'h' | ('t' << 8) | ('t' << 16) | ('p' << 24);
    
    public static void Main(){}

}
`
`
public class A {
    static A() {
        new B(null);
    }
}

public class B {
    public B(C c) {
    }

    protected B(A a) {
    }
}
`
(8,14): error CS0246: The type or namespace name 'C' could not be found (are you missing a using directive or an assembly reference?)
(3,9): error CS0122: 'B.B(A)' is inaccessible due to its protection level
`
public class D {
    public object foo(X x) {
        using (x.bar) {
        }
    }
}
`
(2,23): error CS0246: The type or namespace name 'X' could not be found (are you missing a using directive or an assembly reference?)
`
class A {}

public class B {

    public B(X x) {
        object y = x ?? new A();
    }
}
`
(5,14): error CS0246: The type or namespace name 'X' could not be found (are you missing a using directive or an assembly reference?)
`
using System;

public class c {
  public static void Main() {
    object o = new Decimal?(1);    
    byte b = (Byte)(Nullable<Decimal>)o;
    
    o = new Decimal();
    ulong? l = (Nullable<UInt64>)(Decimal)o;    
  }
}
`
(6,10): warning CS0219: The variable 'b' is assigned but its value is never used
(9,12): warning CS0219: The variable 'l' is assigned but its value is never used
`
public interface IMessage {
  void Foo();
}

public struct M : IMessage {

  public void Foo() {}

}

public class Test {

  public void Send<T>(ref T source) where T : IMessage {
    source.Foo();
  }

  public static void Main() {}
}
`
`
// Would have been an assertion failure. We disallow matching __arglist vs. object
// 
using System;

class Arglist {

   
  static void mywrite(string fmt, object o) {
    System.Console.WriteLine("{0} and {1}", fmt, o);
  }
 
  /*
  static void mywrite(string fmt, params string [] rest){
  } 
  
  static void mywrite(string fmt, __arglist) {
    ArgIterator ai = new ArgIterator(__arglist);
    while (ai.GetRemainingCount () >0) {
      TypedReference tr = ai.GetNextArg();
      Type t = __reftype(tr);
      System.Console.WriteLine("haha {0}-{1}!", fmt, t);
    }
  }*/
  
  public static void Main(string [] args) {
    //Console.WriteLine("", __arglist("hello", 3));
    mywrite("me", __arglist("hello", 3));
  }
}
`
(27,5): error CS2742: Cannot allow an __arglist expression passed as an object type.
(8,15): (Location of symbol related to previous error)
`
public class C {
    private static C _foo;

    public static void Main() {
        System.Threading.Interlocked.CompareExchange(ref _foo, new C(), null);
    }
}
`
`
public delegate void Foo();

public class C {

    public static void Main() {
        Foo foo = Main;

        if (foo == Main) {
            foo = null;
        }
    }
}
`
`
using System.Collections.Generic;

public class C {
    public static IList<C> Foo() {
        return new List<C>();
    }

    public static void Main() {
        IList<C> z = Foo() ?? new List<C>();
    }
}
`
(9,18): warning CS0219: The variable 'z' is assigned but its value is never used
`
public class C {
    public struct OperatorReference<T> {
    }

    public class UnaryOperator { }

    public class VTable {
        public OperatorReference<UnaryOperator>[] UnaryOperators;
    }

    private static void PropagateOperators<T>(ref OperatorReference<T>[] to) {
    }

    public static void Main() {
        VTable dest = new VTable();
        PropagateOperators(ref dest.UnaryOperators);
    }
}
`
`
using System.Collections;

public class C {
    IEnumerator GetEnumerator() {
        try {
            yield return null; // error
        } finally {
        }
    }
    
    public static int Main(){
      C c = new C();
      foreach (object ob in c){
        if (ob == null) return 0;
      }
      return 1;
    }
}
`
`
// Test using a subtype's property that must be resolved to its supertype's property accessor
using System;
class Base {
  public virtual string S { get { return "a"; }  set { } }
}
class SubTypeOverridingOnlySet : Base {
  public override string S { set { } }
}
class SubTypeOverridingOnlyGet : Base {
  public override string S { get { return "b"; } }
}
class Client{
  static string UseSubTypeNoGetter(SubTypeOverridingOnlySet d){
    return d == null ? "a" : d.S;
  }
  static void UseSubTypeNoSetter(SubTypeOverridingOnlySet d){
    d.S = "c";
  }
  static void Main(){}
}
`
`
namespace JitTest
{
	using System;

	struct SimpleStruct
	{
		public sbyte m_sbyte;
	}

	struct RefComplexStruct
	{
		public SimpleStruct ss1;
	}
	
	struct Test
	{
		static int Main()
		{
      return new RefComplexStruct().ss1.m_sbyte;
		}
	}
}
`
`
// Testing #pragma warning without args.
using System;

class Test
{
    public enum TestEnum : byte
    {
        Red = 2,
        Blue = 7,
        Green = 25
    }

    [Flags]
    public enum TestFlagEnum
    {
        None = 0,
        Bit1 = 0x2
    }

    private static bool CheckSameColor(TestEnum color1, TestEnum color2)
    {
        return (color1 == color2);
    }

    private static bool TestSwitch(TestEnum color)
    {
        switch (color)
        {
            case TestEnum.Red: return false;
            case TestEnum.Blue: return false;
            default: return true;
        }
    }

    private static bool CheckEnumType(Object o)
    {
        if (!(o is System.ValueType))
            return false;
        if (!(o is System.Enum))
            return false;
        if (!(o is TestEnum))
            return false;
        return true;
    }

    static int Main(string[] args)
    {
        if (CheckSameColor(TestEnum.Red, TestEnum.Blue))
        {
            Console.WriteLine("Compare Red/Blue failed");
            return 1111;
        }

        if (TestSwitch(TestEnum.Red))
            return 2222;

        if (TestSwitch(TestEnum.Blue))
            return 3333;

        if (CheckSameColor(TestEnum.Red, (TestEnum)34))
            return 4444;

        if (!CheckSameColor(TestEnum.Blue, (TestEnum)7))
            return 5555;

        if (!CheckEnumType((Object)(TestEnum)7))
            return 6666;

#pragma warning disable 0162
        if ((0x46 & (int)TestFlagEnum.Bit1) == 0)
            return 7777;
#pragma warning restore

        Console.WriteLine("Enum tests worked");
        return 0;
    }
}
`
Enum tests worked
`
`/unsafe
class T {

  unsafe public static void Main() {
    byte[] arr = new byte[0];

    fixed(byte* ptr = arr) { // no throw
    }
  }
}
`
`
`/unsafe
using System;

unsafe class Test 
{
  void*[] A = { (int*)0};
  static void Main()
  {
  }
}
`
`
`/unsafe
// Test that if we take pointer to a null string, we get null
using System;

unsafe class Test {
  public static void Main() {
    string s = null;
    fixed (char* ptr = s) {
      if (ptr == null) {
        Console.WriteLine("okay");
      }
      else {
        Console.WriteLine("not okay");
      }
    }
  }
}
`
okay
`
